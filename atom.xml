<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

  <title><![CDATA[kk Blog —— 通用基础]]></title>
  <link href="http://abcdxyzk.github.io/atom.xml" rel="self"/>
  <link href="http://abcdxyzk.github.io/"/>
  <updated>2025-07-21T17:22:06+08:00</updated>
  <id>http://abcdxyzk.github.io/</id>
  <author>
    <name><![CDATA[kk]]></name>
    
  </author>
  <generator uri="http://octopress.org/">Octopress</generator>

  
  <entry>
    <title type="html"><![CDATA[PerformanceObserver监测网页性能]]></title>
    <link href="http://abcdxyzk.github.io/blog/2025/07/21/lang-web-perf/"/>
    <updated>2025-07-21T17:08:00+08:00</updated>
    <id>http://abcdxyzk.github.io/blog/2025/07/21/lang-web-perf</id>
    <content type="html"><![CDATA[<p><a href="https://segmentfault.com/a/1190000012833867?utm_source=sf-related">https://segmentfault.com/a/1190000012833867?utm_source=sf-related</a></p>

<p><a href="https://www.5axxw.com/questions/content/e8hdl8">https://www.5axxw.com/questions/content/e8hdl8</a></p>

<p><a href="https://www.cnblogs.com/momo798/p/17292621.html">https://www.cnblogs.com/momo798/p/17292621.html</a></p>

<h4>处理模型</h4>

<p><img src="http://abcdxyzk.github.io/images/lang/20250721-11.png" alt="" /></p>

<p>参数说明</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
<span class='line-number'>16</span>
<span class='line-number'>17</span>
<span class='line-number'>18</span>
<span class='line-number'>19</span>
<span class='line-number'>20</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>navigationStart 加载起始时间
</span><span class='line'>redirectStart 重定向开始时间（如果发生了HTTP重定向，每次重定向都和当前文档同域的话，就返回开始重定向的fetchStart的值。其他情况，则返回0）
</span><span class='line'>redirectEnd 重定向结束时间（如果发生了HTTP重定向，每次重定向都和当前文档同域的话，就返回最后一次重定向接受完数据的时间。其他情况则返回0）
</span><span class='line'>fetchStart 浏览器发起资源请求时，如果有缓存，则返回读取缓存的开始时间
</span><span class='line'>domainLookupStart 查询DNS的开始时间。如果请求没有发起DNS请求，如keep-alive，缓存等，则返回fetchStart
</span><span class='line'>domainLookupEnd 查询DNS的结束时间。如果没有发起DNS请求，同上
</span><span class='line'>connectStart 开始建立TCP请求的时间。如果请求是keep-alive，缓存等，则返回domainLookupEnd
</span><span class='line'>(secureConnectionStart) 如果在进行TLS或SSL，则返回握手时间
</span><span class='line'>connectEnd 完成TCP链接的时间。如果是keep-alive，缓存等，同connectStart
</span><span class='line'>requestStart 发起请求的时间
</span><span class='line'>responseStart 服务器开始响应的时间
</span><span class='line'>domLoading 从图中看是开始渲染dom的时间，具体未知
</span><span class='line'>domInteractive 未知
</span><span class='line'>domContentLoadedEventStart 开始触发DomContentLoadedEvent事件的时间
</span><span class='line'>domContentLoadedEventEnd DomContentLoadedEvent事件结束的时间
</span><span class='line'>domComplete 从图中看是dom渲染完成时间，具体未知
</span><span class='line'>loadEventStart 触发load的时间，如没有则返回0
</span><span class='line'>loadEventEnd load事件执行完的时间，如没有则返回0
</span><span class='line'>unloadEventStart unload事件触发的时间
</span><span class='line'>unloadEventEnd unload事件执行完的时间</span></code></pre></td></tr></table></div></figure>


<h4>兼容性：</h4>

<p><img src="http://abcdxyzk.github.io/images/lang/20250721-12.png" alt="" /></p>

<h4>案例</h4>

<p>DNS解析时间： domainLookupEnd - domainLookupStart</p>

<p>TCP建立连接时间： connectEnd - connectStart</p>

<p>白屏时间： responseStart - navigationStart</p>

<p>dom渲染完成时间： domContentLoadedEventEnd - navigationStart</p>

<p>页面onload时间： loadEventEnd - navigationStart</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>&lt;script type="text/javascript"&gt;
</span><span class='line'>&#9;const perfObserver = new PerformanceObserver((observedEntries) =&gt; {
</span><span class='line'>&#9;&#9;const entry = observedEntries.getEntriesByType('navigation')[0];
</span><span class='line'>&#9;&#9;tim = entry.loadEventEnd - entry.domainLookupStart;
</span><span class='line'>&#9;&#9;//console.log('pageload time: ', tim);
</span><span class='line'>&#9;&#9;if (tim &lt; 1000)
</span><span class='line'>&#9;&#9;&#9;&#9;document.getElementById('pageTimeShow').innerHTML = '耗时: ' + Math.round(tim) + '毫秒';
</span><span class='line'>&#9;&#9;else
</span><span class='line'>&#9;&#9;&#9;&#9;document.getElementById('pageTimeShow').innerHTML = '耗时: ' + (Math.round(tim/10) / 100) + '秒';
</span><span class='line'>&#9;})
</span><span class='line'>&#9;perfObserver.observe({ entryTypes: ['navigation'] });
</span><span class='line'>&#9;//console.log(performance.getEntriesByType("navigation")[0]);
</span><span class='line'>&#9;//console.log(performance.timing);
</span><span class='line'>&lt;/script&gt;</span></code></pre></td></tr></table></div></figure>


<h4>字段说明</h4>

<table>
<thead>
<tr>
<th style="text-align: left"><strong>key</strong></th>
<th style="text-align: left"><strong>说明</strong></th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align: left">connectEnd</td>
<td style="text-align: left">HTTP（TCP） 完成建立连接的时间（完成握手），如果是持久连接，则与 fetchStart 值相等,如果在传输层发生了错误且重新建立连接，则这里显示的是新建立的连接完成的时间</td>
</tr>
<tr>
<td style="text-align: left">connectStart</td>
<td style="text-align: left">HTTP（TCP） 开始建立连接的时间，如果是持久连接，则与 fetchStart 值相等,如果在传输层发生了错误且重新建立连接，则这里显示的是新建立的连接开始的时间</td>
</tr>
<tr>
<td style="text-align: left">decodedBodySize</td>
<td style="text-align: left">从HTTP或缓存中获取的消息体积大小</td>
</tr>
<tr>
<td style="text-align: left">domainLookupEnd</td>
<td style="text-align: left">DNS 域名查询完成的时间，如果使用了本地缓存（即无 DNS 查询）或持久连接，则与 fetchStart 值相等</td>
</tr>
<tr>
<td style="text-align: left">domainLookupStart</td>
<td style="text-align: left">DNS 域名查询开始的时间，如果使用了本地缓存（即无 DNS 查询）或持久连接，则与 fetchStart 值相等</td>
</tr>
<tr>
<td style="text-align: left">duration</td>
<td style="text-align: left">加载时间</td>
</tr>
<tr>
<td style="text-align: left">encodedBodySize</td>
<td style="text-align: left">从HTTP或缓存中获取的body体积大小</td>
</tr>
<tr>
<td style="text-align: left">entryType</td>
<td style="text-align: left">资源类型，entryType类型不同数组中的对象结构也不同</td>
</tr>
<tr>
<td style="text-align: left">fetchStart</td>
<td style="text-align: left">浏览器准备好使用 HTTP 请求抓取文档的时间，这发生在检查本地缓存之前</td>
</tr>
<tr>
<td style="text-align: left">initiatorType</td>
<td style="text-align: left">谁发起的请求</td>
</tr>
<tr>
<td style="text-align: left">name</td>
<td style="text-align: left">资源名称，是资源的绝对路径或调用mark方法自定义的名称</td>
</tr>
<tr>
<td style="text-align: left">nextHopProtocol</td>
<td style="text-align: left">获取资源使用的网络协议</td>
</tr>
<tr>
<td style="text-align: left">redirectEnd</td>
<td style="text-align: left">最后一个 HTTP 重定向完成时的时间。有跳转且是同域名内的重定向才算，否则值为 0</td>
</tr>
<tr>
<td style="text-align: left">redirectStart</td>
<td style="text-align: left">第一个 HTTP 重定向发生时的时间。有跳转且是同域名内的重定向才算，否则值为 0</td>
</tr>
<tr>
<td style="text-align: left">requestStart</td>
<td style="text-align: left">HTTP 请求读取真实文档开始的时间（完成建立连接），包括从本地读取缓存,连接错误重连时，这里显示的也是新建立连接的时间</td>
</tr>
<tr>
<td style="text-align: left">responseEnd</td>
<td style="text-align: left">HTTP 响应全部接收完成的时间（获取到最后一个字节），包括从本地读取缓存</td>
</tr>
<tr>
<td style="text-align: left">responseStart</td>
<td style="text-align: left">HTTP 开始接收响应的时间（获取到第一个字节），包括从本地读取缓存</td>
</tr>
<tr>
<td style="text-align: left">secureConnectionStart</td>
<td style="text-align: left">HTTPS 连接开始的时间，如果不是安全连接，则值为 0</td>
</tr>
<tr>
<td style="text-align: left">serverTiming</td>
<td style="text-align: left">包含服务时间元数据的数组</td>
</tr>
<tr>
<td style="text-align: left">startTime</td>
<td style="text-align: left">开始时间</td>
</tr>
<tr>
<td style="text-align: left">transferSize</td>
<td style="text-align: left">加载资源的体积大小，包含请求头及请求体</td>
</tr>
<tr>
<td style="text-align: left">workerStart</td>
<td style="text-align: left">DOMHighResTimeStamp</td>
</tr>
</tbody>
</table>



]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[sqlserver的`_log.ldf`日志文件容量太大 如何删除]]></title>
    <link href="http://abcdxyzk.github.io/blog/2025/07/21/sqlserver-logldf/"/>
    <updated>2025-07-21T16:46:00+08:00</updated>
    <id>http://abcdxyzk.github.io/blog/2025/07/21/sqlserver-logldf</id>
    <content type="html"><![CDATA[<p><a href="https://www.lcmin.top/sql/detail/10.html">https://www.lcmin.top/sql/detail/10.html</a></p>

<p>数据库日志文件是随着时间增长而增长的，如果长时间不清理，文件会变得特别大，因此需要定期清空，但是日至文件是恢复数据库的重要依据，不用日志文件也是不明智的。手工清除单个数据库的还好说，但数据库多了，或者临时没有来得及清理，可能硬盘空间就会占满了，影响访问。</p>

<p>手动清理方法：</p>

<p>右键单击需要清理的数据库，选择“属性”，在“选项”卡上，把恢复模式设定为简单，确定后关闭;再右键单击该数据库，“所有任务”-“收缩数据库”，确认后即可清除日志文件，最后记得重新选择“属性”，将恢复模式设置为完全。</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[华为2288H v5服务器配置JBOD（硬盘直通）]]></title>
    <link href="http://abcdxyzk.github.io/blog/2025/07/21/2288H-JBOD/"/>
    <updated>2025-07-21T16:41:00+08:00</updated>
    <id>http://abcdxyzk.github.io/blog/2025/07/21/2288H-JBOD</id>
    <content type="html"><![CDATA[<p><a href="https://blog.csdn.net/yert_alan/article/details/102560219">https://blog.csdn.net/yert_alan/article/details/102560219</a></p>

<p>对服务器输入“ctrl + alt + delete”，按del键进入BIOS配置界面：</p>

<p>选择Device Manager：</p>

<p>选择阵列卡SAS3508，按enter进入：</p>

<p>选中Main Menu，并回车：</p>

<p>选中Controller Management，并回车：</p>

<p>进入Controller Management，选中Advanced Controller Properties：</p>

<p>进入后下拉，选中到JBOD Mode，按enable，使能JBOD硬盘直通模式：</p>

<p>选择“Apply Changes”并按“Enter”，提示The operation has been performed successfully。</p>

<p>单击“OK”完成配置。</p>

<p>完成上述步骤后，返回到Main Menu，选中Drive Management：</p>

<p>进入Drive Management，可以看到硬盘列表，（硬盘必须是Unconfigured Good，才可以配置JBOD直通模式）：</p>

<p>在使能JBOD模式后，阵列卡会自动将未配置RAID的硬盘设置为JBOD，如果没有，执行下列操作。</p>

<p>选择要配置硬盘直通的硬盘，按回车，进入硬盘详细操作界面：</p>

<p>选择Operation，将“Operation”设置为“Make JBOD”。 选择“Go”并按“Enter”。</p>

<p>进入操作确认界面。</p>

<p>将“Confirm”设置为“Enable”。</p>

<p>选择“Yes”并按“Enter”，显示The operation has been performed successfully。</p>

<p>按“Enter”完成配置并返回上级界面。</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Snmp的基本概念]]></title>
    <link href="http://abcdxyzk.github.io/blog/2025/07/21/snmp/"/>
    <updated>2025-07-21T16:28:00+08:00</updated>
    <id>http://abcdxyzk.github.io/blog/2025/07/21/snmp</id>
    <content type="html"><![CDATA[<p><a href="https://www.cnblogs.com/syy714363310/p/11572976.html">https://www.cnblogs.com/syy714363310/p/11572976.html</a></p>

<h2>一、SNMP简单概述</h2>

<h4>1.1、什么是Snmp</h4>

<p>　SNMP是英文"Simple Network Management Protocol"的缩写，中文意思是"简单网络管理协议"。SNMP是一种简单网络管理协议，它属于TCP/IP五层协议中的应用层协议，用于网络管理的协议。SNMP主要用于网络设备的管理。由于SNMP协议简单可靠 ，受到了众多厂商的欢迎，成为了目前最为广泛的网管协议。</p>

<p>　SNMP协议主要由两大部分构成：SNMP管理站和SNMP代理。SNMP管理站是一个中心节点，负责收集维护各个SNMP元素的信息，并对这些信息进行处理，最后反馈给网络管理员；而SNMP代理是运行在各个被管理的网络节点之上，负责统计该节点的各项信息，并且负责与SNMP管理站交互，接收并执行管理站的命令，上传各种本地的网络信息。</p>

<p>　SNMP管理站和SNMP代理之间是松散耦合。他们之间的通信是通过UDP协议完成的。一般情况下，SNMP管理站通过UDP协议向SNMP代理发送各种命令，当SNMP代理收到命令后，返回SNMP管理站需要的参数。但是当SNMP代理检测到网络元素异常的时候，也可以主动向SNMP管理站发送消息，通告当前异常状况。</p>

<p>　SNMP的基本思想：为不同种类的设备、不同厂家生产的设备、不同型号的设备，定义为一个统一的接口和协议，使得管理员可以是使用统一的外观面对这些需要管理的网络设备进行管理。通过网络，管理员可以管理位于不同物理空间的设备，从而大大提高网络管理的效率，简化网络管理员的工作。</p>

<p>　SNMP的工作方式：管理员需要向设备获取数据，所以SNMP提供了【读】操作；管理员需要向设备执行设置操作，所以SNMP提供了【写】操作；设备需要在重要状况改变的时候，向管理员通报事件的发生，所以SNMP提供了【Trap】操作。</p>

<p>  SNMP简单说，包括了被管的设备，代理和网管系统三个部分。被管的设备指的就是我们要获取信息的设备，这个任务里我需要获取它的磁盘空间。但是被管理设备只是产生这些数据，真正将数据报告回来的工作是由代理完成的。代理说白了就是一个运行在被管设备上的程序。网络编程的角度讲它就是一个小的socket服务程序，监听着好像是161端口。通过在被管设备上，需要启动snmp服务。比如在linux上，就需要执行service snmpd start来启动snmp服务，也就是把代理跑起来。实际过程中，代理包含在各种网络设备上，包括交换机，路由器甚至打印机，手机，调制解调器上。网管系统就是我们要从被管设备获取数据并进行分析处理的这个程序。可以想像它运行在本地。只要我将一个合格的请求发往正在运行的代理处，代理从请求中，理解请求的内容，并从被管设备上用它自己的方式搜集到所需的信息，并发送回来，这样一个网管的简单过程就完成了。</p>

<p>  这样的管理方式，还是很灵活的，只要请求包符合协议标准，用哪种语言开发网管系统无所谓；从代理角度讲，只要能正常监听并处理请求，代理可以任意实现。我不太清楚国际上有没有一个统一的标准，比如让我写代理，有请求要查询网络端口的数量，我非把显示器尺寸返回去，不知道警察抓不抓我，至少客户会要求退货吧。也正是因为这种灵活，SNMP也可以支持大规模的集中管理，我同样一个查询存储空间的请求，可以发给我的PC，也可以发给我的诺基亚手机，可能得到的会是存储卡的容量吧，就看代理怎么实现了。</p>

<h4>1.2、SNMP 和 UDP</h4>

<p>　SNMP采用UDP协议在管理端和agent之间传输信息。 SNMP采用UDP 161端口接收和发送请求，162端口接收trap，执行SNMP的设备缺省都必须采用这些端口。SNMP消息全部通过UDP端口161接收，只有Trap信息采用UDP端口162。</p>

<h4>1.3、Snmp版本</h4>

<p>　SNMP目前共有v1，v2，v3这三个版本：</p>

<p>  SNMP v1是SNMP协议的最初版本，不过依然是众多厂家实现SNMP基本方式。</p>

<p>  SNMP v2通常被指是基于community的SNMP V2。Community实质上就是密码。</p>

<p>  SNMP v3 是最新版本的SNMP。它对网络管理最大的贡献在于其安全性。增加了对认证和密文传输的支持。</p>

<h2>二、Snmp的实现结构</h2>

<p>　在具体实现上，SNMP为管理员提供了一个网管平台(NMS)，又称为【管理站】，负责网管命令的发出、数据存储、及数据分析。【被】监管的设备上运行一个SNMP代理(Agent))，代理实现设备与管理站的SNMP通信。</p>

<p><img src="http://abcdxyzk.github.io/images/tools/20250721-1.png" alt="" /></p>

<p>管理站与代理端通过MIB进行接口统一，MIB定义了设备中的被管理对象。管理站和代理都实现了相应的MIB对象，使得双方可以识别对方的数据，实现通信。管理站向代理申请MIB中定义的数据，代理识别后，将管理设备提供的相关状态或参数等数据转换为MIB定义的格式，应答给管理站，完成一次管理操作。</p>

<h2>三、Snmp有关的基本概念</h2>

<h4>3.1、代理和管理站的模型</h4>

<p>　Snmp分2种角色：SNMP管理站（manager，我们的本机127.0.0.1）和SNMP代理（agent， 我们要操作的机器，比如 192.168.1.144）。管理站指的是运行了可以执行网络管理任务软件的服务器，通常被称作为网络管理工作站（NMS）,NMS负责采样网络中agent的信息，并接受agent的trap。代理是实际网络设备中用来实现SNMP功能的部分。代理在UDP的161端口接收NMS的读写请求消息，管理站在UDP的162端口接收代理的事件通告消息。所以，一旦获取设备的访问权限（community，默认为public），就可以访问设备信息、改写和配置设备参数。由于采用UDP协议，不需要在代理和管理站之间保持连接。</p>

<p><img src="http://abcdxyzk.github.io/images/tools/20250721-2.png" alt="" /></p>

<h4>3.2、SNMP的操作命令</h4>

<p>　SNMP协议之所以易于使用，这是因为它对外提供了三种用于控制MIB对象的基本操作命令。它们是：Get、Set 和 Trap。</p>

<p>  Get：管理站读取代理者处对象的值。它是SNMP协议中使用率最高的一个命令，因为该命令是从网络设备中获得管理信息的基本方式。</p>

<p>  Set：管理站设置代理者处对象的值。它是一个特权命令，因为可以通过它来改动设备的配置或控制设备的运转状态。它可以设置设备的名称，关掉一个端口或清除一个地址解析表中的项等。</p>

<p>  Trap： 代理者主动向管理站通报重要事件。它的功能就是在网络管理系统没有明确要求的前提下，由管理代理通知网络管理系统有一些特别的情况或问题 发生了。如果发生意外情况，客户会向服务器的162端口发送一个消息，告知服务器指定的变量值发生了变化。通常由服务器请求而获得的数据由服务器的161 端口接收。Trap 消息可以用来通知管理站线路的故障、连接的终端和恢复、认证失败等消息。管理站可相应的作出处理。</p>

<h4>3.3、SNMP的消息构成</h4>

<p>　SNMP协议定义了数据包的格式，及网络管理员和管理代理之间的信息交换，它还控制着管理代理的MIB数据对象。因此，可用于处理管理代理定义的各种任务。     一条SNMP消息由"版本号"、"SNMP共同体名"和"协议数据单元(PDU)&ldquo;构成，数据包的长度不是固定的。</p>

<p><img src="http://abcdxyzk.github.io/images/tools/20250721-3.png" alt="" /></p>

<p>  版本识别符(version identifier)：用于说明现在使用的是哪个版本的SNMP协议，确保SNMP代理使用相同的协议，每个SNMP代理都直接抛弃与自己协议版本不同的数据报。</p>

<p>  团体名(Community Name)：团体（community）是基本的安全机制，用于实现SNMP网络管理员访问SNMP管理代理时的身份验证。类似于密码，默认值为 public。团体名（Community name）是管理代理的口令，管理员被允许访问数据对象的前提就是网络管理员知道网络代理的口令。如果把配置管理代理成可以执行Trap命令，当网络管理 员用一个错误的分区名查询管理代理时，系统就发送一个autenticationFailure trap报文。</p>

<p>  协议数据单元（PDU）：PDU (协议数据单元)是SNMP消息中的数据区， 即Snmp通信时报文数据的载体。PDU指明了SNMP的消息类型及其相关参数</p>

<p>3.4、PDU(协议数据单元)</p>

<p>　PDU (协议数据单元)是SNMP消息中的数据区， 即Snmp通信时报文数据的载体。</p>

<p>3.5、MIB(管理信息库)</p>

<p>　管理信息(MIB)库可以理解成为agent维护的管理对象数据库，MIB中定义的大部分管理对象的状态和统计信息都可以被NMS访问。MIB是一个按照层次结构组织的树状结构，每个被管对象对应树形结构的一个叶子节点，称为一个object，拥有唯一的数字标识符</p>

<p>　MIB数据对象以一种树状分层结构进行组织，这个树状结构中的每个分枝都有一个专用的名字和一个数字形式的标识符。结构树的分枝实际表示的是数据对象的逻 辑分组。而树叶，有时候也叫节点（node），代表了各个数据对象。在结构树中使用子树表示增加的中间分枝和增加的树叶。      使用这个树状分层结构，MIB浏览器能够以一种方便而且简洁的方式访问整个MIB数据库。MIB浏览器是这样一种工具，它可以遍历整棵MIB结构树，通常 以图形显示的形式来表示各个分枝和树叶对象。可以通过其数字标识符来查找MIB中的数据对象，这个数字标识符号从结构树的顶部（或根部）开始，直到各个叶 子节点（即数据对象）为止。这种访问方式和文件系统的组织方式一致。两者的主要区别在于文件系统中的路径名可以以绝对也可以以相对方式表示，而MIB数据 对象只能以绝对方式表示，不能使用相对方式。      每一个节点都有一个对象标识符（OID）来唯一的标识，每个节点用数字和字符两种方式显示，其中对象标识符OID是由句点隔开的一组整数，也就是从根节点 通向它的路径。一个带标号节点可以拥有包含其它带标号节点为它的子树，如果没有子树它就是叶子节点，它包含一个值并被称为对象。比如网络设备名的oid 是.1.3.6.1.2.1.1.5.0，其值为设备名称的字符串。      网络资源被抽象为对象进行管理。但SNMP中的对象是表示被管资源某一方面的数据变量。对象被标准化为跨系统的类，对象的集合被组织为管理信息库 （MIB）。MIB作为设在代理者处的管理站访问点的集合，管理站通过读取MIB中对象的值来进行网络监控。管理站可以在代理者处产生动作，也可以通过修改变量值改变代理者处的配置。</p>

<p>3.6、OID(Object Identifier)</p>

<p>　每个管理对象都有自己的OID(Object Identifier)，管理对象通过树状结构进行组织，OID由树上的一系列整数组成，整数之间用点( . )分隔开，树的叶子节点才是真正能够被管理的对象。</p>

<h2>四、Snmp的初步体验</h2>

<p>　我们来做一个最简单的Snmp操作：获取一台IP为192.168.1.144的电脑的名称。      首先要给为192.168.1.144的电脑安装Snmp环境。Window组件的管理监视工具里包含Snmp，只需要安装一下就可以了。具体的安装步骤后面的博文会有详细的介绍，Snmp默认的通信端口是161/162</p>

<p>　接下来需要一个能够进行Snmp通信的工具，比较简单的有snmputil，snmputil下载地址：<a href="http://download.csdn.net/detail/aliang0708/4180259">http://download.csdn.net/detail/aliang0708/4180259</a></p>

<p>　将下载下来的【snmputil.zip】压缩包解压后就可以得到如下图所示的两个工具了，其中snmputil是我们要用来进行Snmp通信的工具。</p>

<p><img src="http://abcdxyzk.github.io/images/tools/20250721-4.png" alt="" /></p>

<p>  agent community oid [oid &hellip;] 　　[get|getnext|walk]：为消息类型，我们此次进行的操作是get 　　agent：指Snmp代理即你想进行操作的网络设备的ip或名称，即192.168.1.144 　　community：分区域，即密码，默认是public 　　oid：想要操作的MIB数据对象号，设备名称对应的MIB对象号是.1.3.6.1.2.1.1.5.0</p>

<p>　打开命令行窗口，进入snmputil所在路径，键入：snmputil get 192.168.1.144 public .1.3.6.1.2.1.1.5.0 　　如果参数都正确，控制台就会显示出192.168.1.144的机器名。如下图所示：</p>

<p><img src="http://abcdxyzk.github.io/images/tools/20250721-5.png" alt="" /></p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[华为交换机telnet登录失败故障的排查方法]]></title>
    <link href="http://abcdxyzk.github.io/blog/2025/07/21/network-telnet-err/"/>
    <updated>2025-07-21T16:18:00+08:00</updated>
    <id>http://abcdxyzk.github.io/blog/2025/07/21/network-telnet-err</id>
    <content type="html"><![CDATA[<p><a href="https://blog.csdn.net/mengmeng_921/article/details/143019661">https://blog.csdn.net/mengmeng_921/article/details/143019661</a></p>

<p><img src="http://abcdxyzk.github.io/images/network/20250721.png" alt="" /></p>

<h2>检查网络状态</h2>

<p>操作步骤</p>

<p>1、执行命令ping xxx.xxx.xxx.xxx(目的IP网段)</p>

<p>根据报文是否丢包确认是否可以访问该设备，网络不通请检查组网及网络地址、静态路由等相关配置。</p>

<h2>检查VTY通道是否已占满？</h2>

<p>操作步骤</p>

<p>1、在任意视图下，执行命令display users，检查当前用户登录数量。</p>

<p>2、在任意视图下，执行命令display current-configuration configuration user-interface include-default，检查登录用户的最大数目。缺省情况下，Telnet、SSH（STelnet）用户最大数目共为5个。</p>

<p>3、如果当前用户登录数量等于系统设置的登录用户最大数量，可以通过以下两种方式修改：</p>

<p>调整登录用户的最大数目。操作方法：系统视图下，执行命令user-interface maximum-vty number，number取值范围是0～21。</p>

<p>在保证业务不中断的前提下，断开部分用户的连接。操作方法：用户视图下，执行命令kill user-interface { ui-number | ui-type ui-number1 }</p>

<p>推荐使用第一种方式。</p>

<h2>检查SSH服务器状态</h2>

<p>操作步骤</p>

<p>1、在任意视图下，执行命令display ssh server status，检查SSH服务器状态。</p>

<p>根据STelnet server项查看是否使能了SSH服务器功能，缺省情况下，SSH服务器功能未使能。如果显示“Disable”，表示未使能SSH服务器功能，则客户端无法登录服务器，需要在系统视图下，执行命令stelnet server enable命令使能SSH服务器功能。</p>

<p>根据SSH version 1.x compatibility项查看是否配置服务器兼容低版本功能，缺省情况下，未使能兼容低版本功能。</p>

<p>SSH有两种不兼容的版本：1.x和2.0，缺省情况下，服务器SSH版本是2.0。当服务器的SSH版本高于客户端的SSH版本时，需要在系统视图下，执行命令ssh server compatible-ssh1x enable，使能SSH服务器兼容低版本功能，来解决由版本不匹配带来的登录失败故障。</p>

<p>说明：</p>

<p>SSH2.0协议相比SSH1.x协议来说，在结构上做了扩展，可以支持更多的认证方法和密钥交换方法，安全性更高（可以规避SSH1.X存在的安全风险），推荐用户使用SSH2.0。</p>

<p>根据ACL name和ACL number、或者ACL6 name和ACL6 number项查看是否配置ACL访问控制列表，如果显示“–”，表示没有配置访问列表控制项；如果显示具体名，则说明配置了ACL规则，控制了SSH客户端的访问权限，请参考“检查是否有ACL绑定”。</p>

<h2>检查是否有ACL绑定</h2>

<p>操作步骤</p>

<p>1、查看用户界面视图下是否绑定ACL规则。</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>system-view [~HUAWEI] user-interface vty 0
</span><span class='line'>[~HUAWEI-ui-vty0] display this
</span><span class='line'>user-interface con 0 authentication-mode password set authentication password cipher
</span><span class='line'>
</span><span class='line'>$1aKaTeX parse error: Expected 'EOF', got '#' at position 9: 7`mtJ5Q7#̲D^Je8&lt;I6[VDV]a4CBeoz=1O#Q8!5NH&lt;yUfr3&&lt;w*D$
</span><span class='line'>user-interface vty 0 14 acl 2000 inbound authentication-mode password user privilege level 3 set authentication password cipher
</span><span class='line'>
</span><span class='line'>1a1a1ar;iO"UhF_/"6CO&lt;K@Si89EOnHj p0′xAP574AY1KdVS.zG∗−4"6CO&lt;K@Si89EOnHj\:p0'xAP574AY1KdVS.zG*-4"6CO&lt;K@Si89EOnHjp0′xAP574AY1KdVS.zG∗−4 idle-timeout
</span><span class='line'>120 0
</span><span class='line'>return</span></code></pre></td></tr></table></div></figure>


<p>由上述回显可以看出，当前配置绑定了ACL 2000。</p>

<p>2、如果绑定了ACL规则，则需要查看ACL规则的内容，判断是否配置了允许或者阻止登录的用户访问控制列表。</p>

<p>查看ACL 2000配置。</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>sys
</span><span class='line'>acl 2000
</span><span class='line'>display this
</span><span class='line'>
</span><span class='line'>acl number 2000
</span><span class='line'>rule 1 permit source 1.1.1.1 0
</span><span class='line'>rule 2 deny</span></code></pre></td></tr></table></div></figure>


<p>确认客户端IP是否在permit的IP范围之内，如果不在，则需要在当前ACL视图下，执行命令rule [ rule-id ] permit source source-ip-address，配置允许该IP登录。</p>

<h2>检查VTY界面是否配置了SSH协议？</h2>

<p>操作步骤</p>

<p>1、在任意视图下，执行命令display current-configuration | section include protocol inbound，检查VTY用户界面支持的协议类型。缺省情况下，V100R003C00版本系统支持Telnet协议类型；V100R003C10及以后版本系统支持所有协议类型。</p>

<p>2、如果protocol inbound配置的为all或者ssh，说明允许SSH通过，如果配置不是上述配置，则需要在user-interface视图下增加protocol inbound { all | ssh }，配置方法如下所示。</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>user-interface vty 0 4
</span><span class='line'>protocol inbound all
</span><span class='line'>commit</span></code></pre></td></tr></table></div></figure>


<h2>检查服务器端是否存在该用户？</h2>

<p>操作步骤</p>

<p>1、任意视图下，执行命令display ssh user-information，查看本地用户配置信息。</p>

<p>User Name表示SSH用户名，根据这项内容判断是否存在当前登录的用户。如果没有当前登录的用户，可以参考如下步骤配置该用户：</p>

<p>执行命令system-view，进入系统视图。</p>

<p>执行命令ssh user user-name，创建用户名。</p>

<p>执行命令ssh authentication-type default password，配置SSH用户缺省采用密码认证。
用户也可以通过执行命令ssh user user-name authentication-type password配置SSH用户 认证方式为密码认证。</p>

<p>执行命令ssh user user-name service-type { stelnet | all }，配置SSH用户的服务方式。缺省情况下，服务方式为空。</p>

<p>执行命令commit，提交配置。</p>

<h2>检查AAA配置</h2>

<p>操作步骤</p>

<p>1、执行命令display current-configuration configuration aaa，确认待登录用户为本地用户，还是远端认证用户。</p>

<p>local-user表示root为本地用户，本地用户需要支持ssh服务。如果显示不是local-user，则表示为远端认证用户，远端认证用户需要检查远端认证服务器设置，主要检查用户分组、账号密码、权限级别等。</p>

<h2>收集信息并寻求技术支持</h2>

<p>操作步骤</p>

<p>1、收集上述步骤的操作结果，并记录到文件中。</p>

<p>2、一键式收集设备的所有诊断信息并导出文件。</p>

<p>a.在用户视图下，执行display diagnostic-information file-name命令，采集设备诊断信息并保存为文件。</p>

<p>说明：</p>

<p>生成的文本文件的缺省保存路径为flash:/，您可以在用户视图下使用dir命令可以确认文件是否正确生成。</p>

<p>b.当诊断信息文件生成之后，您可以通过FTP、SFTP、SCP等方式将其从设备上导出，详细操作可参考“管理本地文件”。</p>

<p>说明：</p>

<p>您也可以直接执行display diagnostic-information命令，并通过终端日志存盘方式获取设备诊断信息文件，详细操作可参见“设备诊断信息文件获取指导”。</p>

<p>3、收集设备的日志和告警信息并导出文件。</p>

<p>a.执行以下命令，将缓冲区的日志和告警信息保存为文件。</p>

<p>b.当日志信息文件生成之后，您可以通过FTP、SFTP、SCP等方式将其从设备上导出，详细操作可参考“管理本地文件”。</p>

<p>说明：</p>

<p>您也可以直接执行display logbuffer和display trapbuffer命令查看设备的日志和告警信息，并通过终端日志存盘方式获取日志和告警信息文件，操作方法与设备诊断信息文件的获取方式相同，可参见“设备诊断信息文件获取指导”。</p>

<h2>寻求技术支持</h2>

<p>请您参考如下网页链接信息<a href="http://e.huawei.com/cn/how-to-buy/contact-us%EF%BC%8C%E5%AF%BB%E6%B1%82%E6%8A%80%E6%9C%AF%E6%94%AF%E6%8C%81%E3%80%82">http://e.huawei.com/cn/how-to-buy/contact-us%EF%BC%8C%E5%AF%BB%E6%B1%82%E6%8A%80%E6%9C%AF%E6%94%AF%E6%8C%81%E3%80%82</a></p>

<p>说明：</p>

<p>在技术支持过程中，请按技术支持人员的指导，将收集的所有信息和文件完整提交，方便技术支持人员进行问题定位。</p>
]]></content>
  </entry>
  
</feed>
