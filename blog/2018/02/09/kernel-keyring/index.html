
<!DOCTYPE html>
<!--[if IEMobile 7 ]><html class="no-js iem7"><![endif]-->
<!--[if lt IE 9]><html class="no-js lte-ie8"><![endif]-->
<!--[if (gt IE 8)|(gt IEMobile 7)|!(IEMobile)|!(IE)]><!--><html class="no-js" lang="en"><!--<![endif]-->
<head>
  <meta charset="utf-8">
  <title>内核模块签名--密匙 - kk Blog —— 通用基础</title>

  <link href="/favicon.png" rel="icon">
  <link href="/stylesheets/screen.css" media="screen, projection" rel="stylesheet" type="text/css">
  <link href="/atom.xml" rel="alternate" title="kk Blog —— 通用基础" type="application/atom+xml">
  <script src="/javascripts/modernizr-2.0.js"></script>
  <script src="/javascripts/libs/jquery.min.js"></script>
<!--  <script>!window.jQuery && document.write(unescape('%3Cscript src="/javascripts/libs/jquery.min.js"%3E%3C/script%3E'))</script> -->
  <script src="/javascripts/octopress.js" type="text/javascript"></script>
  <script src="/javascripts/category.js" type="text/javascript"></script>

<script async src="https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js?client=ca-pub-8245190595992760"
     crossorigin="anonymous"></script>

</head>

<body   >
  <header role="banner"><hgroup>
  <h1><a href="/">kk Blog —— 通用基础</a></h1>
  
    <h2><br>date [-d @int|str] [+%s|"+%F %T"]<br>netstat -ltunp<br>sar -n DEV 1</h2>
  
  <div class="hwx" style='text-align: left; position: absolute; margin-top: -130px; white-space: nowrap;'>
	  <img src="/images/wx_ok.png" width=130px; height=130px;>
	  <img src="/images/ali_ok.png" width=130px; height=130px; style="margin-left:30px;">
  </div>
</hgroup>

</header>
  <nav role="navigation" style='white-space: nowrap; min-width=1120px;'><form action="/search" method="get">
    <input class="search" name="query" id="query" type="text" placeholder="search..." style="height:1.5em;">
    <input id="btnSubmit" value="search" type="submit">
</form>
<script type="text/javascript">

function StringToAscii(str) {
	return str.charCodeAt(0).toString(16);
}

function AsciiToString(asccode) {
	return String.fromCharCode(asccode);
}

function UrlDecode(zipStr) {
	var uzipStr = '';
	for (var i = 0; i < zipStr.length; i += 1) {
		var chr = zipStr.charAt(i);
		if (chr === '+') {
			uzipStr += ' ';
		} else if (chr === '%') {
			var asc = zipStr.substring(i + 1, i + 3);
			if (parseInt('0x' + asc) > 0x7f) {
				uzipStr += decodeURI('%' + asc.toString() + zipStr.substring(i+3, i+9).toString());
				i += 8;
			} else {
				uzipStr += AsciiToString(parseInt('0x' + asc));
				i += 2;
			}
		} else {
			uzipStr += chr;
		}
	}
	return uzipStr;
}

/*
var query = GetRequest("query");
if (query != null) {
	document.getElementById("query").value = UrlDecode(query);
}
*/

var query = window.location.search.substring(1);
var vars = query.split("&");
for (var i = 0; i < vars.length; i ++) {
	var pair = vars[i].split("=");
	if (pair[0] == 'query') {
		document.getElementById('query').value = UrlDecode(pair[1]);
		break;
	}
}

</script>

<!-- Start of Site Search 360 Scripts -->
<!-- Search 360 达到次数后要收费，换成静态索引
<script type="text/javascript">
var ss360Config = {
    siteId: "abcdxyzk.github.io",
    searchBox: {
        selector: "input#query",
        searchButton: "input#query+input[type='submit']"
    }
}
</script>
<script src="https://cdn.sitesearch360.com/v13/sitesearch360-v13.min.js" async></script>
-->
<!-- End of Site Search 360 Scripts -->

<ul class="subscription" data-subscription="rss">
<li>
</li>
  <li><a href="/atom.xml" rel="subscribe-rss">RSS</a></li>
  
</ul>
  
  
<ul class="main-navigation">
  <li><a href="/">Blog</a></li>
  <li><a href="/blog/archives">Archives</a></li>
  <li><a href="/download">Download</a></li>
  <li><a href="/search">Search</a></li>
  <li><a href="/about">About</a></li>
</ul>

</nav>
  <div id="main">
    <div id="content">
      <div>
<article class="hentry" role="article">
  
  <header>
    
      <h2 class="entry-title">内核模块签名--密匙</h2>
    
    
      <p class="meta">
        




<time class='entry-date' datetime='2018-02-09T01:37:00+08:00'><span class='date'>2018-02-09</span> <span class='time'>01:37:00</span></time>
        
      </p>
    
  </header>


<div class="entry-content"><p><a href="https://www.ibm.com/developerworks/cn/linux/l-key-retention.html">https://www.ibm.com/developerworks/cn/linux/l-key-retention.html</a></p>

<p>Linux 密钥保留服务（Linux key retention service）是在 Linux 2.6 中引入的，它的主要意图是在 Linux 内核中缓存身份验证数据。远程文件系统和其他内核服务可以使用这个服务来管理密码学、身份验证标记、跨域用户映射和其他安全问题。它还使 Linux 内核能够快速访问所需的密钥，并可以用来将密钥操作（比如添加、更新和删除）委托给用户空间。</p>

<p>本文将概述 Linux 密钥保留服务，定义它的术语，帮助您快速掌握 Linux 密钥的使用方法。您将通过示例代码了解如何在内核模块中使用 Linux 密钥保留服务。在编写本文时使用的内核版本是 2.6.20。</p>

<h4>什么是密钥？</h4>

<p>密钥（key）是一组密码学数据、身份验证标记或某些相似的元素，它在内核中由 struct key 表示。在 Linux 内核源代码中，struct key 是在 include/linux/key.h 下定义的。</p>

<p>清单 1 给出 struct key 中一些重要的字段。注意，为了支持密钥，已经修改了 task_struct、user_struct 和 signal_struct。
清单 1. struct key 中的重要字段</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
<span class='line-number'>16</span>
<span class='line-number'>17</span>
<span class='line-number'>18</span>
<span class='line-number'>19</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>struct key {
</span><span class='line'>&#9;atomic_t             usage;         /* number of references */
</span><span class='line'>&#9;key_serial_t         serial;        /* key serial number */
</span><span class='line'>&#9;struct key_type      *type;         /* type of key */
</span><span class='line'>&#9;time_t               expiry;        /* time at which key expires (or 0) */
</span><span class='line'>&#9;uid_t                uid;           /* UID */
</span><span class='line'>&#9;gid_t                gid;           /* GID */
</span><span class='line'>&#9;key_perm_t           perm;          /* access permissions */
</span><span class='line'>&#9;unsigned short       quotalen;      /* length added to quota */
</span><span class='line'>&#9;unsigned short       datalen;       /* payload data length
</span><span class='line'>&#9;char                 *description;
</span><span class='line'>&#9;union {
</span><span class='line'>&#9;&#9;unsigned long       value;
</span><span class='line'>&#9;&#9;void                *data;
</span><span class='line'>&#9;&#9;struct keyring_list *subscriptions;
</span><span class='line'>&#9;} payload;                          /* Actual security data */
</span><span class='line'>&#9;....
</span><span class='line'>&#9;....
</span><span class='line'>};</span></code></pre></td></tr></table></div></figure>


<h4>密钥的属性</h4>

<p>密钥具有以下属性：</p>

<p>  序号（Serial number）：一个惟一的 32 位非零正数。</p>

<p>  类型（Type）：Linux 密钥保留服务定义两个标准密钥类型：user 和 keyring。要添加新的密钥类型，必须由一个内核服务注册它。用户空间程序不允许创建新的密钥类型。密钥类型在内核中由 struct key_type 表示，这是在 include/linux/key.h 中定义的。key_type 结构的一些重要字段见清单 2。</p>

<p>  清单 2. key_type 的重要字段</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>struct key_type {
</span><span class='line'>&#9;const char *name;
</span><span class='line'>&#9;size_t def_datalen;
</span><span class='line'>     
</span><span class='line'>&#9;/* Operations that can be defined for a key_type */
</span><span class='line'>&#9;int (*instantiate)(struct key *key, const void *data, size_t datalen);
</span><span class='line'>&#9;int (*update)(struct key *key, const void *data, size_t datalen);
</span><span class='line'>&#9;int (*match)(const struct key *key, const void *desc);
</span><span class='line'>&#9;void (*revoke)(struct key *key);
</span><span class='line'>&#9;void (*destroy)(struct key *key);
</span><span class='line'>&#9;void (*describe)(const struct key *key, struct seq_file *p);
</span><span class='line'>&#9;long (*read)(const struct key *key, char __user *buffer, size_t buflen);
</span><span class='line'>&#9;....
</span><span class='line'>&#9;....
</span><span class='line'>};</span></code></pre></td></tr></table></div></figure>


<p>  还可以将一组操作与一个密钥类型相关联。key_type 可以定义以下操作：</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
<span class='line-number'>16</span>
<span class='line-number'>17</span>
<span class='line-number'>18</span>
<span class='line-number'>19</span>
<span class='line-number'>20</span>
<span class='line-number'>21</span>
<span class='line-number'>22</span>
<span class='line-number'>23</span>
<span class='line-number'>24</span>
<span class='line-number'>25</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>    instantiate 创建指定类型的一个新密钥。
</span><span class='line'>    describe 输出描述这个密钥的文本。
</span><span class='line'>    match 根据描述搜索密钥。
</span><span class='line'>    destroy 清除与一个密钥相关的所有数据。
</span><span class='line'>    request_key 搜索密钥。
</span><span class='line'>    revoke 清除密钥数据并将密钥的状态改为 REVOKED。
</span><span class='line'>    read 读取密钥数据。
</span><span class='line'>    update 修改密钥。
</span><span class='line'>  描述（Description）：一个描述密钥的可输出字符串。这个属性还可以用来执行搜索操作。
</span><span class='line'>  访问控制信息（Access control information）：每个密钥有一个所有者 ID、一个 GID 和一个权限掩码，权限掩码表示如何响应用户级或内核级程序。权限掩码给四个可能的密钥访问者类型各分配 8 位：所有者、用户、组和其他。在这 8 位中，只定义了 6 位。可能的权限如下：
</span><span class='line'>    View 允许权限持有者查看密钥属性。
</span><span class='line'>    Read 允许权限持有者读取密钥并列出 keyring 的密钥。
</span><span class='line'>    Write 允许权限持有者修改密钥或 keyring 的有效内容和修改链接的密钥。
</span><span class='line'>    Search 允许权限持有者搜索 keyring 和寻找密钥。
</span><span class='line'>    Link 允许权限持有者将特定的密钥或 keyring 链接到 keyring。
</span><span class='line'>    Set Attribute 允许权限持有者设置密钥的 UID、GID 和权限掩码。 
</span><span class='line'>过期时间（Expiry Time）：密钥的生存期。密钥也可以是永久的。
</span><span class='line'>有效内容（Payload）：实际的安全内容。可以通过 struct key_type 定义的操作用数据对有效内容进行实例化，还可以读取数据或修改数据。对于内核来说，有效内容仅仅是一组数据。
</span><span class='line'>状态（State）：密钥可以处于以下状态：
</span><span class='line'>    UNINSTANTIATED：已经创建了密钥，但是还没有附加任何数据。
</span><span class='line'>    INSTANTIATED：密钥已经实例化并附加了数据；这是一个完整的 状态。
</span><span class='line'>    NEGATIVE：这是一个临时状态，表示前面对用户空间的调用失败了。
</span><span class='line'>    EXPIRED：表示密钥已经超过了预定义的生存期。
</span><span class='line'>    REVOKED：一个用户空间操作将密钥转移到这个状态。
</span><span class='line'>    DEAD：key_type 取消了注册。</span></code></pre></td></tr></table></div></figure>


<h4>密钥类型</h4>

<p>有两种预定义的密钥类型：keyring 和 user。</p>

<p>keyring 包含一组到其他密钥或 keyring 的链接。有六种标准的 keyring：</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>线程特有的
</span><span class='line'>进程特有的
</span><span class='line'>会话特有的
</span><span class='line'>用户特有的会话
</span><span class='line'>用户默认的会话
</span><span class='line'>组特有的（还未实现）</span></code></pre></td></tr></table></div></figure>


<h5>限额</h5>

<p>对于一个用户可以拥有的密钥和 keyring 的数量有限制（密钥数量限额），对于在密钥描述和有效内容中使用的信息量也有限制（密钥大小限额）。进程特有的和线程特有的 keyring 不在用户限额的范围内。</p>

<p>只有前三个 keyring 被自动搜索，自动搜索会按照次序进行。第四种类型（用户特有的会话 keyring）不被直接搜索，但是，它通常会链接到一个会话特有的 keyring。登录进程（比如 PAM）将绑定到用户默认的会话 keyring，直到创建另一个会话为止。</p>

<p>用户密钥由用户空间程序操作。</p>

<h3>三个新的系统调用</h3>

<p>Linux 密钥保留服务提供三个新的系统调用，用来在用户空间中操作密钥。第一个是 add_key：</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>key_serial_t add_key(const char *type, const char *desc,
</span><span class='line'>&#9;&#9;     const void *payload, size_t plen,
</span><span class='line'>&#9;&#9;     key_serial_t ring);</span></code></pre></td></tr></table></div></figure>


<p>add_key 系统调用用来创建类型为 type、长度为 plen 的密钥。密钥描述由 desc 定义，它的有效内容由 payload 指定。密钥链接到 keyring ring。密钥类型可以是 user 或 keyring。其他任何密钥类型必须已经通过内核服务向内核注册，然后才能使用。如果密钥是 keyring 类型的，有效内容就应该是 NULL，plen 应该是零。</p>

<p>下一个新的系统调用是 request_key：</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>key_serial_t request_key(const char *type, const char *desc,
</span><span class='line'>&#9;&#9;&#9; const char *callout_info, 
</span><span class='line'>&#9;&#9;&#9; key_serial_t dest_keyring);</span></code></pre></td></tr></table></div></figure>


<p>request_key 系统调用搜索一个进程 keyring，寻找一个密钥。搜索密钥的基本算法见清单 3。
清单 3. request_key 算法</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>search_into_each_subscribed_keyrings {
</span><span class='line'>&#9;if (key is found) {
</span><span class='line'>&#9;&#9;return(found key);
</span><span class='line'>&#9;} else {
</span><span class='line'>&#9;&#9;if (callout_info is NULL) {
</span><span class='line'>&#9;&#9;&#9;return(ERROR);
</span><span class='line'>&#9;&#9;} else {
</span><span class='line'>&#9;&#9;&#9;Execute /sbin/request-key and pass callout_info as argument;
</span><span class='line'>&#9;&#9;}
</span><span class='line'>&#9;}
</span><span class='line'>}</span></code></pre></td></tr></table></div></figure>


<p>关于 request_key 算法的工作原理的详细信息，请参考 Documentation/keys-request-key.txt（参见 参考资料 中的链接）。</p>

<p>最后，系统调用 keyctl 提供许多用来管理密钥的函数。可以根据传递给 keyctl 的第一个参数在密钥上执行各种操作。下面列出 keyctl 的一部分操作：</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>KEYCTL_DESCRIBE 描述一个密钥。
</span><span class='line'>KEYCTL_READ 从一个密钥读取有效内容数据。
</span><span class='line'>KEYCTL_UPDATE 更新指定的密钥。
</span><span class='line'>KEYCTL_LINK 将一个密钥链接到一个 keyring。
</span><span class='line'>KEYCTL_UNLINK 将密钥或 keyring 与另一个 keyring 的链接取消。
</span><span class='line'>KEYCTL_JOIN_SESSION_KEYRING 将一个会话 keyring 替换为新的会话 keyring。
</span><span class='line'>KEYCTL_REVOKE 取消一个密钥。
</span><span class='line'>KEYCTL_CHOWN 修改密钥的所有者。
</span><span class='line'>KEYCTL_SETPERM 修改密钥的权限掩码。
</span><span class='line'>KEYCTL_CLEAR 清除一个 keyring。
</span><span class='line'>KEYCTL_SEARCH 在一个 keyring 树中搜索密钥。
</span><span class='line'>KEYCTL_INSTANTIATE 对部分构造好的密钥进行实例化。
</span><span class='line'>KEYCTL_NEGATE 取消对部分构造好的密钥的实例化。</span></code></pre></td></tr></table></div></figure>


<p>关于 keyctl 的原型和 keyctl 可以执行的其他操作的更多信息，请参考 Linux 手册页。</p>

<h4>管理密钥的内核 API</h4>

<p>下面是几个用来管理密钥的最重要的 Linux 内核 API。要想了解更全面的信息，请下载并参考 Linux 密钥实现源代码文件（参见下面的 下载）。</p>

<p>register_key_type 用来定义新的密钥类型。</p>

<p>如果已经存在名称相同的密钥类型，那么 int register_key_type(struct key_type *type) 返回 EEXIT。</p>

<p>unregister_key_type 用来取消密钥类型的注册：</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>void unregister_key_type(struct key_type *type);</span></code></pre></td></tr></table></div></figure>


<p>key_put 发布一个密钥：</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>void key_put(struct key *key);</span></code></pre></td></tr></table></div></figure>


<p>request_key 搜索与给定的描述匹配的密钥：</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>struct key *request_key(const struct key_type *type,
</span><span class='line'>                        const char *description,
</span><span class='line'>                        const char *callout_string);</span></code></pre></td></tr></table></div></figure>


<p>key_alloc 分配指定类型的密钥：</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>struct key *key_alloc(struct key_type *type, const char *desc, 
</span><span class='line'>                      uid_t uid, gid_t gid, struct task_struct *ctx,
</span><span class='line'>                      key_perm_t perm, unsigned long flags);</span></code></pre></td></tr></table></div></figure>


<p>key_instantiate_and_link 对密钥进行实例化并将它链接到目标 keyring：</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>int key_instantiate_and_link(struct key *key,  const void *data,
</span><span class='line'>                             size_t datalen, struct key *keyring,
</span><span class='line'>                             struct key *instkey);</span></code></pre></td></tr></table></div></figure>


<h4>启用密钥服务</h4>

<p>因为 Linux 密钥保留服务仍然非常新，在默认情况下 Linux 内核中关闭了这个服务。要想启用密钥服务，必须使用 CONFIG_KEYS=y 选项对内核进行配置。可以在内核编译的 make *config 步骤中 Security options 下面找到这个选项。</p>

<p>清单 4 给出在 Linux 内核中启用密钥服务的配置。
清单 4. 在 Linux 内核中启用密钥服务</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>".config" file ...
</span><span class='line'>#
</span><span class='line'># Security options
</span><span class='line'>#
</span><span class='line'>CONFIG_KEYS=y
</span><span class='line'>CONFIG_KEYS_DEBUG_PROC_KEYS=y
</span><span class='line'>CONFIG_SECURITY=y
</span><span class='line'>CONFIG_SECURITY_NETWORK=y
</span><span class='line'>CONFIG_SECURITY_CAPABILITIES=y</span></code></pre></td></tr></table></div></figure>


<p>密钥的源代码被组织在目录 linux-2.6.x/security/keys 中。</p>

<p>接下来，需要 下载并安装 keyutils 包。keyutils 包含 keyctl 命令，可以使用这个命令在密钥上执行各种操作。前面已经列出了 keyctl 的一部分操作。更多信息参见 Linux 手册页。</p>

<h4>创建新的密钥类型</h4>

<p>学习 Linux 密钥保留服务最容易的方式就是进行实践。下面的示例使用 Linux 密钥保留服务创建一个新类型的密钥。如果还没有 下载示例程序， 现在就执行这个步骤。执行 make 来构建内核模块和用户级程序的二进制代码。这些代码已经在 Linux 内核版本 2.6.20 上测试过了。</p>

<p>示例程序有两个组件：一个内核模块和一个用户空间程序。这个内核模块注册一个新的密钥类型。这个用户空间程序在预定义的 proc-entries 上执行 ioctl，这会导致对内核模块的调用。这个调用会产生一个新的密钥。然后，一个 “bash” shell 返回给用户，它带有新的会话 keyring 和链接到这个 keyring 的新类型的密钥。</p>

<p>因为这个用户空间程序将执行 ioctl，内核模块必须注册 proc_ioctl() 函数来处理 ioctl 请求。所有 ioctl 通信都使用 /proc 接口来进行。清单 5 给出在内核模块中声明的一个新的密钥类型。
清单 5. 声明新的密钥类型</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>truct key_type new_key_type = {
</span><span class='line'>&#9;.name = "mykey",
</span><span class='line'>&#9;.instantiate = instantiate_key,
</span><span class='line'>&#9;.describe = key_desc,
</span><span class='line'>&#9;.destroy = key_destroy,
</span><span class='line'>&#9;.match = key_match,
</span><span class='line'>;</span></code></pre></td></tr></table></div></figure>


<p>然后，模块在它的 init 函数中调用 register_key_type() 来注册这个新密钥类型（名为 mykey）。当内核模块收到 ioctl 请求时，它首先调用 key_alloc() 来分配一个新的密钥，从而创建一个会话 keyring。在成功调用 key_alloc() 之后，调用 key_instantiate_and_link() 对密钥进行实例化。在创建并实例化会话 keyring 之后，为用户的会话创建密钥。同样，依次调用 key_alloc() 和 key_instantiate_and_link()。成功完成这些调用之后，用户空间会话就有了一个新密钥。</p>

<p>示例程序中演示了所有这些步骤。</p>

<h4>使用模块</h4>

<p>创建了新的密钥类型之后，我们来试用一下这个内核模块。模块中的一个基本操作是查看一个进程与哪些 keyring 相关联，以及这些 keyring 包含哪些密钥和其他 keyring。调用 keyctl show 就可以在树结构中显示密钥。清单 6 显示在运行程序之前密钥的状态。
清单 6. 查看进程的 keyring</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>root@phoenix set.5]# keyctl show
</span><span class='line'>ession Keyring
</span><span class='line'>      -3 --alswrv      0     0  keyring: _ses.1976
</span><span class='line'>       2 --alswrv      0     0   \_ keyring: _uid.0</span></code></pre></td></tr></table></div></figure>


<p>清单 7 显示插入模块或者卸载模块或用户级程序的命令的输出。这些消息会放在一个系统日志文件中（通常是 /var/log/messages）。
清单 7. 插入内核模块</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>root@phoenix set.5]# insmod ./kernel.land/newkey.ko
</span><span class='line'>oading the module ...
</span><span class='line'>egistered "learning_key"</span></code></pre></td></tr></table></div></figure>


<p>接下来，执行用户级程序。
清单 8. 执行用户级程序</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>root@phoenix set.5]# ./user.land/session
</span><span class='line'>  
</span><span class='line'>n /var/log/message, you will see similar output
</span><span class='line'>nstalling session keyring:
</span><span class='line'>eyring allocated successfully.
</span><span class='line'>eyring instantiated and linked successfully.
</span><span class='line'>ew session keyring installed successfully.
</span><span class='line'>ey of new type allocated successfully.
</span><span class='line'>ew key type linked to current session.</span></code></pre></td></tr></table></div></figure>


<p>再看一下密钥的状态，见清单 9。
清单 9. 运行用户级程序之后的密钥状态</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
<span class='line-number'>16</span>
<span class='line-number'>17</span>
<span class='line-number'>18</span>
<span class='line-number'>19</span>
<span class='line-number'>20</span>
<span class='line-number'>21</span>
<span class='line-number'>22</span>
<span class='line-number'>23</span>
<span class='line-number'>24</span>
<span class='line-number'>25</span>
<span class='line-number'>26</span>
<span class='line-number'>27</span>
<span class='line-number'>28</span>
<span class='line-number'>29</span>
<span class='line-number'>30</span>
<span class='line-number'>31</span>
<span class='line-number'>32</span>
<span class='line-number'>33</span>
<span class='line-number'>34</span>
<span class='line-number'>35</span>
<span class='line-number'>36</span>
<span class='line-number'>37</span>
<span class='line-number'>38</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>root@phoenix set.5]# keyctl show
</span><span class='line'>ession Keyring
</span><span class='line'>      -3 --alswrv      0     0  keyring: session.2621
</span><span class='line'>39044642 --alswrv      0     0   \_ mykey: New key type
</span><span class='line'>  
</span><span class='line'>root@phoenix set.5]# cat /proc/keys
</span><span class='line'>0000001 I-----     1 perm 1f3f0000     0     0 keyring   _uid_ses.0: 1/4
</span><span class='line'>0000002 I-----     5 perm 1f3f0000     0     0 keyring   _uid.0: empty
</span><span class='line'>253c622 I--Q--     1 perm 3f3f0000     0     0 mykey   New key type: 0
</span><span class='line'>1a490da I--Q--     2 perm 3f3f0000     0     0 keyring   session.2621: 1/4
</span><span class='line'>3670439 I--Q--     2 perm 1f3f0000     0     0 keyring   _ses.1977: 1/4
</span><span class='line'>59d39b8 I--Q--     5 perm 1f3f0000     0     0 keyring   _ses.1976: 1/4
</span><span class='line'>a14f259 I--Q--     3 perm 1f3f0000     0     0 keyring   _ses.1978: 1/4
</span><span class='line'>root@phoenix set.5]# cat /proc/key-users
</span><span class='line'>   0:     8 7/7 5/100 136/10000
</span><span class='line'>  43:     2 2/2 2/100 56/10000
</span><span class='line'>  48:     2 2/2 2/100 56/10000
</span><span class='line'>  81:     2 2/2 2/100 56/10000
</span><span class='line'>  786:     4 4/4 4/100 113/10000
</span><span class='line'>
</span><span class='line'>"keyctl describe &lt;Key&gt;" command gives the description of key.
</span><span class='line'>  
</span><span class='line'>[root@phoenix set.5]# keyctl describe -3
</span><span class='line'>       -3: alswrvalswrv------------     0     0 keyring: session.2621
</span><span class='line'>[root@phoenix set.5]# keyctl describe 39044642
</span><span class='line'> 39044642: alswrvalswrv------------     0     0 mykey: New key type
</span><span class='line'>[avinesh@phoenix set.5]$ keyctl search -3 mykey "New key type"
</span><span class='line'>39044642
</span><span class='line'>[root@phoenix set.5]# exit
</span><span class='line'>exit
</span><span class='line'>Now back to our previous state  
</span><span class='line'>[root@phoenix set.5]# keyctl show
</span><span class='line'>Session Keyring
</span><span class='line'>       -3 --alswrv      0     0  keyring: _ses.1976
</span><span class='line'>        2 --alswrv      0     0   \_ keyring: _uid.0
</span><span class='line'>[root@phoenix set.5]# rmmod ./kernel.land/newkey.ko 
</span><span class='line'>Unloading the module.
</span><span class='line'>Unregistered "learning_key"</span></code></pre></td></tr></table></div></figure>


<h4>与密钥相关的 proc 文件</h4>

<p>/proc 中添加了两个文件来管理密钥：/proc/keys 和 /proc/key-users。我们来仔细看看这些文件。</p>

<h5>/proc/keys</h5>

<p>如果一个进程希望了解它可以查看哪些密钥，它可以通过读取 /proc/keys 获得这些信息。在配置内核时，必须启用这个文件，因为它允许任何用户列出密钥数据库。
清单 10. /proc/keys 文件</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>[root@phoenix set.5]# cat /proc/keys
</span><span class='line'>00000001 I-----  1     perm    1f3f0000      0    0    keyring    _uid_ses.0 : 1/4
</span><span class='line'>00000002 I-----  5     perm    1f3f0000      0    0    keyring    _uid.0     : empty
</span><span class='line'>13670439 I--Q--  2     perm    1f3f0000      0    0    keyring    _ses.1977  : 1/4
</span><span class='line'>159d39b8 I--Q--  6     perm    1f3f0000      0    0    keyring    _ses.1976  : 1/4
</span><span class='line'>3a14f259 I--Q--  3     perm    1f3f0000      0    0    keyring    _ses.1978  : 1/4
</span><span class='line'>[Serial][Flags][Usage][Expiry][Permissions][UID][GID][TypeName][Description] :[Summary]</span></code></pre></td></tr></table></div></figure>


<p>*Source: linux_kernel_source/security/keys/proc.c:proc_keys_show()</p>

<p>在以上文件中看到的大多数字段来自 include/linux/key.h 中定义的 struct key。可能的标志值见清单 11。
清单 11. struct key 字段可能的标志值</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>I        Instantiated
</span><span class='line'>R        Revoked
</span><span class='line'>D        Dead
</span><span class='line'>Q        Contributes to user's quota
</span><span class='line'>U        Under construction by callback to user-space
</span><span class='line'>N        Negative key</span></code></pre></td></tr></table></div></figure>


<h5>/proc/key-users</h5>

<p>清单 12 显示 /proc/key-users 文件。
清单 12. /proc/key-users 文件</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>[root@phoenix set.5]# cat /proc/key-users
</span><span class='line'>    0:     6 5/5 3/100 90/10000
</span><span class='line'>   43:     2 2/2 2/100 56/10000
</span><span class='line'>   48:     2 2/2 2/100 56/10000
</span><span class='line'>   81:     2 2/2 2/100 56/10000
</span><span class='line'>  786:     4 4/4 4/100 113/10000</span></code></pre></td></tr></table></div></figure>


<p>清单 13 给出每个字段的含义。
清单 13. /proc/key-users 文件的字段</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>&lt;UID&gt;            User ID
</span><span class='line'>&lt;usage&gt;          Usage count
</span><span class='line'>&lt;inst&gt;/&lt;keys&gt;    Total number of keys and number instantiated
</span><span class='line'>&lt;keys&gt;/&lt;max&gt;     Key count quota
</span><span class='line'>&lt;bytes&gt;&lt;max&gt;     Key size quota</span></code></pre></td></tr></table></div></figure>


<p>*Source: linux_kernel_source/security/keys/proc.c:proc_key_users_show()</p>

<p>大多数字段是 security/keys/internal.h 中定义的 struct key_user 的字段。</p>

<h4>结束语</h4>

<p>Linux 密钥保留服务是一种新的机制，其用途是保存与安全相关的信息，让 Linux 内核可以快速地访问这些信息。这个服务仍然处于初级阶段，刚刚开始获得认可。OpenAFS 使用 Linux 密钥保留服务来实现进程身份验证组（PAG），NFSv4 和 MIT Kerberos 也使用它。Linux 密钥保留服务仍然在进行开发，以后可能会修改或改进。</p>

<h4>下载资源</h4>

<p>  使用 Linux 密钥保留服务的示例应用程序 (key.retention.services.zip | 4KB)</p>

<h4>相关主题</h4>

<ul>
    <li>您可以参阅本文在 developerWorks 全球站点上的 <a href="http://www.ibm.com/developerworks/linux/library/l-key-retention.html?S_TACT=105AGX52&amp;S_CMP=cn-a-l" target="_blank">英文原文</a> 。</li>
    <li>“<a href="http://www.ibm.com/developerworks/cn/linux/l-seclnx1.html">让 Linux 更安全</a>”（developerWorks，2004 年 7 月）是分三部分的文章，介绍了 Linux 安全性。</li>
    <li>“<a href="http://www.ibm.com/developerworks/cn/linux/l-system-calls/">使用 Linux 系统调用的内核命令</a>”（developerWorks，2007 年 3 月）介绍了 Linux 系统调用，并解释了如何将系统调用从用户空间传递到内核。</li>
    <li>阅读 <a href="http://lxr.linux.no/source/Documentation/keys.txt">Documentation/keys.txt</a>和
        <a href="http://lxr.linux.no/source/Documentation/keys-request-key.txt">Documentation/keys-request-key.txt</a>，进一步了解 Linux 2.6 内核中密钥的概念和创建密钥的过程。</li>
    <li><a href="http://lxr.linux.no/source/security/keys/">Linux key implementation sources</a> 是用来管理密钥的 Linux 内核 API。</li>
    <li>David Howells 是 Linux 密钥保留服务的创建者。请参阅他在 2006 年渥太华 Linux 研讨会上 <a href="http://people.redhat.com/~dhowells/keys/keyrings-bof-ols2006.odp">讲话的幻灯片</a>。</li>
    <li>“<a href="http://lwn.net/Articles/210502/">Kernel key management</a>” 提供了用来管理密钥的 Linux 内核 API 的更多信息。</li>
    <li><a href="http://www.openafs.org/">OpenAFS</a> 使用 Linux 密钥保留服务实现它的进程身份验证组（PAG）。请查看 <a href="http://openafs.org/cgi-bin/cvsweb.cgi/openafs/src/afs/LINUX/osi_groups.c">源代码</a>。</li>
    <li>下载 <a href="http://people.redhat.com/~dhowells/keyutils/">keyutils 包</a>，开始试用 Linux 密钥保留服务。</li>
    <li>在 <a href="http://www.ibm.com/developerworks/cn/linux/">developerWorks Linux 专区</a> 中可以找到为 Linux 开发人员准备的更多参考资料。 </li>
    <li>使用 <a href="http://www.ibm.com/developerworks/downloads/?S_TACT=105AGX52&amp;S_CMP=cn-a-l">IBM 试用软件</a> 构建您的下一个 Linux 开发项目，这些软件可以从 developerWorks 直接下载。 </li>
</ul>



</div>


  <footer>
    <p class="meta">
      
  

<span class="byline author vcard">Posted by <span class="fn">kk</span></span>

      




<time class='entry-date' datetime='2018-02-09T01:37:00+08:00'><span class='date'>2018-02-09</span> <span class='time'>01:37:00</span></time>
      

<span class="categories">
  
    <a class='category' href='/blog/cats/kernel/'>kernel</a>, <a class='category' href='/blog/cats/kernel~signature/'>signature</a>
  
</span>


    </p>
    
      
    
    <p class="meta">
      
        <a class="basic-alignment left" href="/blog/2018/02/09/tools-openssl/" title="Previous Post: openssl常用命令，签名、非对称加解密">&laquo; openssl常用命令，签名、非对称加解密</a>
      
      
        <a class="basic-alignment right" href="/blog/2018/02/09/kernel-signature-command/" title="Next Post: 内核模块签名--命令行">内核模块签名--命令行 &raquo;</a>
      
    </p>
    <p class="meta">
	<div style='white-space: nowrap;'>
	<img src="/images/wx_ok.png" width=150px; height=150px; style="margin-left:100px;">
	<img src="/images/ali_ok.png" width=150px; height=150px; style="margin-left:100px;">
	</div>
    </p>


<!-- alert 替代 -->
<script type="text/javascript">
	cssCode = "<style type='text/css'>"
		+ ".nbaMask { position: fixed; z-index: 1000; top: 0; right: 0; left: 0; bottom: 0; background: rgba(0, 0, 0, 0.5); } "
		+ ".nbaMaskTransparent { position: fixed; z-index: 1000; top: 0; right: 0; left: 0; bottom: 0; } "
		+ ".nbaDialog { position: fixed; z-index: 5000; width: 80%; max-width: 500px; top: 50%; left: 50%; -webkit-transform: translate(-50%, -50%); transform: translate(-50%, -50%); background-color: #fff; text-align: center; border-radius: 8px; overflow: hidden; opacity: 1; color: white; }"
		+ ".nbaDialog .nbaDialogHd { padding: .2rem .27rem .08rem .27rem; text-align: left; padding-left: 10px; padding-top: 10px; } "
		+ ".nbaDialog .nbaDialogHd .nbaDialogTitle { color:black; font-size: 17px; font-weight: 400; } "
		+ ".nbaDialog .nbaDialogBd { padding: 0 .27rem; font-size: 15px; line-height: 1.3; word-wrap: break-word; word-break: break-all; color: #000000; } "
		+ ".nbaDialog .nbaDialogFt { background: #1a6ada; float: right; margin-right:10px; margin-bottom:10px; position: relative; border-radius: 5px; width:60px;  line-height: 30px; font-size: 15px; display: -webkit-box; display: -webkit-flex; display: flex; } "
		+ ".nbaDialog .nbaDialogFt:after { content: ' '; position: absolute; left: 0; top: 0; right: 0; height: 1px; border-top: 1px solid #e6e6e6; color: #e6e6e6; -webkit-transform-origin: 0 0; transform-origin: 0 0; -webkit-transform: scaleY(0.5); transform: scaleY(0.5); } "
		+ ".nbaDialog .nbaDialogBtn { display: block; -webkit-box-flex: 1; -webkit-flex: 1; flex: 1; color: white; text-decoration: none; -webkit-tap-highlight-color: transparent; position: relative; margin-bottom: 0; } "
		+ ".nbaDialog .nbaDialogBtn:after { content: ' '; position: absolute; left: 0; top: 0; width: 1px; bottom: 0; border-left: 1px solid #e6e6e6; color: #e6e6e6; -webkit-transform-origin: 0 0; transform-origin: 0 0; -webkit-transform: scaleX(0.5); transform: scaleX(0.5); } "
		+ ".nbaDialog a { text-decoration: none; -webkit-tap-highlight-color: transparent; }"
		+ "</style>";

	htmlCode = "<div id='dialogs2' style='display: none'>"
		+ "  <div class='nbaMask'></div>"
		+ "  <div class='nbaDialog'>"
		+ "    <div class='nbaDialogHd'>"
		+ "        <strong class='nbaDialogTitle'>提示：</strong>"
		+ "    </div><br>"
		+ ' <div style="white-space: nowrap;"> <img src="/images/wx_ok.png" width="130px;" height="130px;"> <img src="/images/ali_ok.png" width="130px;" height="130px;" style="margin-left:100px;"> </div> '
		+ "    <div class='nbaDialogBd' id='dialog_msg2' style='white-space:normal;'>弹窗内容，告知当前状态、信息和解决方法，描述文字尽量控制在三行内</div>"
		+ "    <div class='nbaDialogHd'>"
		+ "        <strong class='nbaDialogTitle'></strong>"
		+ "    </div><br>"
		+ "    <div class='nbaDialogFt'>"
		+ "        <a href='javascript:;' class='nbaDialogBtn nbaDialogBtnPrimary' style='display:none;' id='dialog_ok2'>确定</a>"
		+ "    </div>"
		+ "  </div>"
		+ "</div>";

	htmlCode2 = "<div id='dialogs22' style='display: none;'>"
		+ "  <div class='nbaDialog' id='dialogs22_s' style='background:gray; top:50%; border-radius: 18px;'>"
		+ "    <div class='nbaDialogBd' id='dialog_msg22' style='white-space:normal; color:white;padding-top:10px;'>弹窗内容，告知当前状态、信息和解决方法，描述文字尽量控制在三行内</div>"
		+ "    <div class='nbaDialogHd'>"
		+ "        <strong class='nbaDialogTitle'></strong>"
		+ "    </div>"
		+ "  </div>"
		+ "</div>";

function showd()
{
	document.getElementById("dialog_ok2").style.display = '';
}

function alert_money(msg) {
	var div = document.createElement("div");
	div.innerHTML = cssCode + htmlCode;
	document.body.appendChild(div);

	var dialogs2 = document.getElementById("dialogs2");
	dialogs2.style.display = 'block';

	var dialog_msg2 = document.getElementById("dialog_msg2");
	dialog_msg2.innerHTML = msg;

	// var dialog_cancel = document.getElementById("dialog_cancel");
	//	dialog_cancel.onclick = function() {
	//	dialogs2.style.display = 'none';
	// };
	var dialog_ok2 = document.getElementById("dialog_ok2");
	dialog_ok2.onclick = function() {
		dialogs2.style.display = 'none';
		//callback();
	};

	setTimeout("showd()", 10*1000);
};

alert_money('');

</script>


  </footer>
</article>

</div>
<aside class="sidebar" id='load_sidebar'>
</aside>
<script type="text/javascript">
  $('#load_sidebar').load('/sidebar.html');
</script>

    </div>
  </div>
  <footer role="contentinfo">  Copyright &copy; 2024 - kk -
  <span class="credit">Powered by <a href="http://octopress.org">Octopress</a></span>
  <a title="Top" href="#" id="scroll2top" style="position: fixed; height: 50px; bottom: 30px; right: 25px; cursor: pointer; z-index: 9999; display: block; opacity: 1;"><img src="/images/scrollup.png"></a>
  <script src="/javascripts/scroll2top.js"></script>

<!-- Matomo -->
<script>
  var _paq = window._paq = window._paq || [];
  /* tracker methods like "setCustomDimension" should be called before "trackPageView" */
  _paq.push(['trackPageView']);
  _paq.push(['enableLinkTracking']);
  (function() {
    var u="//www.abcxyzkk.xyz/matomo/";
    _paq.push(['setTrackerUrl', u+'matomo.php']);
    _paq.push(['setSiteId', '1']);
    var d=document, g=d.createElement('script'), s=d.getElementsByTagName('script')[0];
    g.async=true; g.src=u+'matomo.js'; s.parentNode.insertBefore(g,s);
  })();
</script>
<!-- End Matomo Code -->


<!-- Histats.com  (div with counter) --><div id="histats_counter"></div>
<!-- Histats.com  START  (aync)-->
<!--
<script type="text/javascript">var _Hasync= _Hasync|| [];
_Hasync.push(['Histats.start', '1,4673876,4,107,170,20,00010000']);
_Hasync.push(['Histats.fasi', '1']);
_Hasync.push(['Histats.track_hits', '']);
(function() {
var hs = document.createElement('script'); hs.type = 'text/javascript'; hs.async = true;
hs.src = ('//s10.histats.com/js15_as.js');
(document.getElementsByTagName('head')[0] || document.getElementsByTagName('body')[0]).appendChild(hs);
})();</script>
<noscript><a href="/" target="_blank"><img  src="//sstatic1.histats.com/0.gif?4673876&101" alt="simple hit counter" border="0"></a></noscript>
-->
<!-- Histats.com  END  -->

<!--  <script type="text/javascript">var cnzz_protocol = (("https:" == document.location.protocol) ? " https://" : " http://");document.write(unescape("%3Cspan id='cnzz_stat_icon_1253604690'%3E%3C/span%3E%3Cscript src='" + cnzz_protocol + "s95.cnzz.com/z_stat.php%3Fid%3D1253604690' type='text/javascript'%3E%3C/script%3E"));</script>
-->


<!--
<script>

// TODO 无法获取框架内元素
function autoads()
{
try {
	console.log('start');
	var txt = document.getElementById('mys-content').innerHTML;
	var len = txt.length;
	var url = '';
	console.log(len);
	for (var i = 0; i < len - 10; i ++) {
		if (txt.substring(i, i + 6) == 'href="') {
			i = i + 6;
			url = '';
			for ( ; i < len; i ++) {
				if (txt[i] == '"')
					break;
				url += txt[i];
			}
			url = url.replace(/&amp;/g, '&');
		//	console.log(url);
		}
	}
	console.log(url);
	if (url != '' && Math.random() < 0.3)
		window.open(url, "_blank");
} catch (e) {
}
}

window.onload = function() {
	setTimeout("autoads()", 5*1000);
}
</script>
-->


</footer>
  





</body>
</html>
