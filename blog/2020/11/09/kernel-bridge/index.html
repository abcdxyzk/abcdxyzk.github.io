
<!DOCTYPE html>
<!--[if IEMobile 7 ]><html class="no-js iem7"><![endif]-->
<!--[if lt IE 9]><html class="no-js lte-ie8"><![endif]-->
<!--[if (gt IE 8)|(gt IEMobile 7)|!(IEMobile)|!(IE)]><!--><html class="no-js" lang="en"><!--<![endif]-->
<head>
  <meta charset="utf-8">
  <title>网桥源码 - kk Blog —— 通用基础</title>

  <link href="/favicon.png" rel="icon">
  <link href="/stylesheets/screen.css" media="screen, projection" rel="stylesheet" type="text/css">
  <link href="/atom.xml" rel="alternate" title="kk Blog —— 通用基础" type="application/atom+xml">
  <script src="/javascripts/modernizr-2.0.js"></script>
  <script src="/javascripts/libs/jquery.min.js"></script>
<!--  <script>!window.jQuery && document.write(unescape('%3Cscript src="/javascripts/libs/jquery.min.js"%3E%3C/script%3E'))</script> -->
  <script src="/javascripts/octopress.js" type="text/javascript"></script>
  <script src="/javascripts/category.js" type="text/javascript"></script>

<script async src="https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js?client=ca-pub-8245190595992760"
     crossorigin="anonymous"></script>

</head>

<body   >
  <header role="banner"><hgroup>
  <h1><a href="/">kk Blog —— 通用基础</a></h1>
  
    <h2><br>date [-d @int|str] [+%s|"+%F %T"]<br>netstat -ltunp<br>sar -n DEV 1</h2>
  
  <div class="hwx" style='text-align: left; position: absolute; margin-top: -130px; white-space: nowrap;'>
	  <img src="/images/wx_ok.png" width=130px; height=130px;>
	  <img src="/images/ali_ok.png" width=130px; height=130px; style="margin-left:30px;">
  </div>
</hgroup>

</header>
  <nav role="navigation" style='white-space: nowrap; min-width=1120px; position: sticky; top: 0; z-index: 999;'><form action="/search" method="get">
    <input class="search" name="query" id="query" type="text" placeholder="search..." style="height:1.5em;">
    <input id="btnSubmit" value="search" type="submit">
</form>
<script type="text/javascript">

function StringToAscii(str) {
	return str.charCodeAt(0).toString(16);
}

function AsciiToString(asccode) {
	return String.fromCharCode(asccode);
}

function UrlDecode(zipStr) {
	var uzipStr = '';
	for (var i = 0; i < zipStr.length; i += 1) {
		var chr = zipStr.charAt(i);
		if (chr === '+') {
			uzipStr += ' ';
		} else if (chr === '%') {
			var asc = zipStr.substring(i + 1, i + 3);
			if (parseInt('0x' + asc) > 0x7f) {
				uzipStr += decodeURI('%' + asc.toString() + zipStr.substring(i+3, i+9).toString());
				i += 8;
			} else {
				uzipStr += AsciiToString(parseInt('0x' + asc));
				i += 2;
			}
		} else {
			uzipStr += chr;
		}
	}
	return uzipStr;
}

/*
var query = GetRequest("query");
if (query != null) {
	document.getElementById("query").value = UrlDecode(query);
}
*/

var query = window.location.search.substring(1);
var vars = query.split("&");
for (var i = 0; i < vars.length; i ++) {
	var pair = vars[i].split("=");
	if (pair[0] == 'query') {
		document.getElementById('query').value = UrlDecode(pair[1]);
		break;
	}
}

</script>

<!-- Start of Site Search 360 Scripts -->
<!-- Search 360 达到次数后要收费，换成静态索引
<script type="text/javascript">
var ss360Config = {
    siteId: "abcdxyzk.github.io",
    searchBox: {
        selector: "input#query",
        searchButton: "input#query+input[type='submit']"
    }
}
</script>
<script src="https://cdn.sitesearch360.com/v13/sitesearch360-v13.min.js" async></script>
-->
<!-- End of Site Search 360 Scripts -->

<ul class="subscription" data-subscription="rss">
<li>
</li>
  <li><a href="/atom.xml" rel="subscribe-rss">RSS</a></li>
  
</ul>
  
  
<ul class="main-navigation">
  <li><a href="/">Blog</a></li>
  <li><a href="/blog/archives">Archives</a></li>
  <li><a href="/download">Download</a></li>
  <li><a href="/search">Search</a></li>
  <li><a href="/about">About</a></li>
</ul>

</nav>
  <div id="main">
    <div id="content">
      <div>
<article class="hentry" role="article">
  
  <header>
    
      <h2 class="entry-title">网桥源码</h2>
    
    
      <p class="meta">
        




<time class='entry-date' datetime='2020-11-09T17:52:00+08:00'><span class='date'>2020-11-09</span> <span class='time'>17:52:00</span></time>
        
      </p>
    
  </header>


<div class="entry-content"><p><a href="https://blog.csdn.net/NW_NW_NW/article/details/75045966">https://blog.csdn.net/NW_NW_NW/article/details/75045966</a></p>

<p><a href="https://blog.csdn.net/NW_NW_NW/article/details/75090101">https://blog.csdn.net/NW_NW_NW/article/details/75090101</a></p>

<p><a href="https://blog.csdn.net/NW_NW_NW/article/details/75647220">https://blog.csdn.net/NW_NW_NW/article/details/75647220</a></p>

<p><a href="https://blog.csdn.net/NW_NW_NW/article/details/76022117">https://blog.csdn.net/NW_NW_NW/article/details/76022117</a></p>

<p><a href="https://blog.csdn.net/NW_NW_NW/article/details/76153027">https://blog.csdn.net/NW_NW_NW/article/details/76153027</a></p>

<p><a href="https://blog.csdn.net/NW_NW_NW/article/details/76204707">https://blog.csdn.net/NW_NW_NW/article/details/76204707</a></p>

<p><a href="https://blog.csdn.net/NW_NW_NW/article/details/76674232">https://blog.csdn.net/NW_NW_NW/article/details/76674232</a></p>

<p><a href="https://blog.csdn.net/NW_NW_NW/article/details/76710941">https://blog.csdn.net/NW_NW_NW/article/details/76710941</a></p>

<h2>桥初始化</h2>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
<span class='line-number'>16</span>
<span class='line-number'>17</span>
<span class='line-number'>18</span>
<span class='line-number'>19</span>
<span class='line-number'>20</span>
<span class='line-number'>21</span>
<span class='line-number'>22</span>
<span class='line-number'>23</span>
<span class='line-number'>24</span>
<span class='line-number'>25</span>
<span class='line-number'>26</span>
<span class='line-number'>27</span>
<span class='line-number'>28</span>
<span class='line-number'>29</span>
<span class='line-number'>30</span>
<span class='line-number'>31</span>
<span class='line-number'>32</span>
<span class='line-number'>33</span>
<span class='line-number'>34</span>
<span class='line-number'>35</span>
<span class='line-number'>36</span>
<span class='line-number'>37</span>
<span class='line-number'>38</span>
<span class='line-number'>39</span>
<span class='line-number'>40</span>
<span class='line-number'>41</span>
<span class='line-number'>42</span>
<span class='line-number'>43</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>static int __init br_init(void)
</span><span class='line'>{
</span><span class='line'>&#9;int err;
</span><span class='line'>&#9;/*注册协议生成树收包函数*/
</span><span class='line'>&#9;err = stp_proto_register(&br_stp_proto);
</span><span class='line'>&#9;if (err &lt; 0) {
</span><span class='line'>&#9;&#9;pr_err("bridge: can't register sap for STP\n");
</span><span class='line'>&#9;&#9;return err;
</span><span class='line'>&#9;}
</span><span class='line'>&#9;/*转发数据库初始化*/
</span><span class='line'>&#9;err = br_fdb_init();
</span><span class='line'>&#9;if (err)
</span><span class='line'>&#9;&#9;goto err_out;
</span><span class='line'>&#9;/*在/proc目录下生成任何与bridge相关的目录，如果我们想在/proc下生成bridge相关的子目录或子文件*/
</span><span class='line'>&#9;err = register_pernet_subsys(&br_net_ops);
</span><span class='line'>&#9;if (err)
</span><span class='line'>&#9;&#9;goto err_out1;
</span><span class='line'>&#9;/*目前好像没有什么实际作用，在内核中所注册的函数为空*/
</span><span class='line'>&#9;err = br_nf_core_init();
</span><span class='line'>&#9;if (err)
</span><span class='line'>&#9;&#9;goto err_out2;
</span><span class='line'>&#9;/*注册相关网络设备的事件通知连*/
</span><span class='line'>&#9;err = register_netdevice_notifier(&br_device_notifier);
</span><span class='line'>&#9;if (err)
</span><span class='line'>&#9;&#9;goto err_out3;
</span><span class='line'>
</span><span class='line'>&#9;/*注册通知连，主要针对桥转发表事件的相关信息*/
</span><span class='line'>&#9;err = register_switchdev_notifier(&br_switchdev_notifier);
</span><span class='line'>&#9;if (err)
</span><span class='line'>&#9;&#9;goto err_out4;
</span><span class='line'>&#9;/*进行netlink的初始化*/
</span><span class='line'>&#9;err = br_netlink_init();
</span><span class='line'>&#9;if (err)
</span><span class='line'>&#9;&#9;goto err_out5;
</span><span class='line'>
</span><span class='line'>&#9;/*用来处理ioctl命令的函数，比如添加和删除网桥*/
</span><span class='line'>&#9;brioctl_set(br_ioctl_deviceless_stub);
</span><span class='line'>
</span><span class='line'>#if IS_ENABLED(CONFIG_ATM_LANE)
</span><span class='line'>&#9;br_fdb_test_addr_hook = br_fdb_test_addr;
</span><span class='line'>#endif
</span><span class='line'>&#9;return 0;
</span><span class='line'>}</span></code></pre></td></tr></table></div></figure>


<p> 了解了桥初始化大致要做的事情后，我们再来看看这些初始化或者注册的事情到底干了些什么？</p>

<p>1.注册协议生成树收包函数stp_proto_register</p>

<p>在桥初始化的时候，注册了一个br_stp_proto参数，此参数的具体模样是这样子的</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>static const struct stp_proto br_stp_proto = {
</span><span class='line'>&#9;.rcv   = br_stp_rcv,
</span><span class='line'>};</span></code></pre></td></tr></table></div></figure>


<p>br_stp_rcv函数在/net/bridge/br_stp_bpdu.c中主要针对网桥进行协议交换的帧（BPDU）进行配置操作。</p>

<p>2.桥转发数据库初始化br_fdb_init</p>

<p>此函数就是在内存中建立一块slab cache，以存放net_bridge_fdb_entry</p>

<p>其中：net_bridge_fdb_entry是一个结构体，用来转发数据库的记录项网桥所学到对的每个MAC地址都有这样一个记录</p>

<p>3.在proc目录下生成相关文件的注册函数register_pernet_subsys，初始化的时候给这个函数传递了一个参数br_net_ops，这个参数的模样是这样的</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>static struct pernet_operations br_net_ops = {
</span><span class='line'>&#9;.exit   = br_net_exit,
</span><span class='line'>};</span></code></pre></td></tr></table></div></figure>


<p>但是在桥初始化的时候，仅仅注册了br_net_exit，这个函数会将桥下面的所有文件全部清空。</p>

<p>4.通知链的相关函数注册register_netdevice_notifier这个注册函数主要针对设备信息的变化，注册参数br_device_notifier，具体如下：</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>static struct notifier_block br_device_notifier = {
</span><span class='line'>&#9;.notifier_call = br_device_event
</span><span class='line'>};</span></code></pre></td></tr></table></div></figure>


<p>br_device_event函数是用来当桥上的设备状态或者设备信息发生改变时做相应的处理，该函数在/net/bridge/br.c中</p>

<p>5.注册通知连，主要针对桥转发表事件的相关信息register_switchdev_notifier，传入的参数br_switchdev_notifier详细信息如下：</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>static struct notifier_block br_switchdev_notifier = {
</span><span class='line'>&#9;.notifier_call = br_switchdev_event,
</span><span class='line'>};</span></code></pre></td></tr></table></div></figure>


<p>br_switchdev_event，主要针对桥转发表的事件做出相应的处理该函数在/net/bridge/br.c中</p>

<p>6.brioctl_set用来处理ioctl命令的函数，比如添加和删除网桥，br_ioctl_deviceless_stub给回调函数br_ioctl_hook,而br_ioctl_hook在sock_ioctl中</p>

<p>使用，这样通过在应用层调用socket的ioctl函数，就能够进行网桥的添加与删除了，函数用来处理添加和删除网桥的相关操作</p>

<p>以上就是网桥初始化的相关操作。</p>

<h2>添加一个桥设备——br_add_bridge</h2>

<p>我们先来看一个命令：brctl addbr br1</p>

<p>上节我们提到一个用来处理ioctl命令的函数br_ioctl_deviceless_stub通过调用brioctl_set，
将br_ioctl_deviceless_stub赋值给回调函数br_ioctl_hook，而br_ioctl_hook在sock_ioctl中使用。
这样通过在应用层调用socket的ioctl函数，就能够进行网桥的添加与删除了。</p>

<p>如果我们想增加新的ioctl，用于我们新开放的功能，就可以在该函数里增加新的case即可。</p>

<p>当我们输入上面命令时，就会触发br_ioctl_deviceless_stub函数来响应br_add_bridge函数，当命令执行完成以后，
使用brctl show命令就可以看见我们添加的br1这个网桥设备已经生成。</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
<span class='line-number'>16</span>
<span class='line-number'>17</span>
<span class='line-number'>18</span>
<span class='line-number'>19</span>
<span class='line-number'>20</span>
<span class='line-number'>21</span>
<span class='line-number'>22</span>
<span class='line-number'>23</span>
<span class='line-number'>24</span>
<span class='line-number'>25</span>
<span class='line-number'>26</span>
<span class='line-number'>27</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>int br_ioctl_deviceless_stub(struct net *net, unsigned int cmd, void __user *uarg)
</span><span class='line'>{
</span><span class='line'>&#9;switch (cmd) {
</span><span class='line'>&#9;case SIOCGIFBR:
</span><span class='line'>&#9;case SIOCSIFBR:
</span><span class='line'>&#9;&#9;return old_deviceless(net, uarg);
</span><span class='line'>
</span><span class='line'>&#9;case SIOCBRADDBR:
</span><span class='line'>&#9;case SIOCBRDELBR:
</span><span class='line'>&#9;{
</span><span class='line'>&#9;&#9;char buf[IFNAMSIZ];
</span><span class='line'>
</span><span class='line'>&#9;&#9;if (!ns_capable(net-&gt;user_ns, CAP_NET_ADMIN))
</span><span class='line'>&#9;&#9;&#9;return -EPERM;
</span><span class='line'>
</span><span class='line'>&#9;&#9;if (copy_from_user(buf, uarg, IFNAMSIZ))
</span><span class='line'>&#9;&#9;&#9;return -EFAULT;
</span><span class='line'>
</span><span class='line'>&#9;&#9;buf[IFNAMSIZ-1] = 0;
</span><span class='line'>&#9;&#9;if (cmd == SIOCBRADDBR)
</span><span class='line'>&#9;&#9;&#9;return br_add_bridge(net, buf);/*添加网桥设备的操作*/
</span><span class='line'>
</span><span class='line'>&#9;&#9;return br_del_bridge(net, buf);
</span><span class='line'>&#9;}
</span><span class='line'>&#9;}
</span><span class='line'>&#9;return -EOPNOTSUPP;
</span><span class='line'>}</span></code></pre></td></tr></table></div></figure>


<p>该函数注册在，桥设备添加时候dev->netdev_ops = &amp;br_netdev_ops;
 在br_netdev_ops有一个函数指针.ndo_do_ioctl= br_dev_ioctl</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
<span class='line-number'>16</span>
<span class='line-number'>17</span>
<span class='line-number'>18</span>
<span class='line-number'>19</span>
<span class='line-number'>20</span>
<span class='line-number'>21</span>
<span class='line-number'>22</span>
<span class='line-number'>23</span>
<span class='line-number'>24</span>
<span class='line-number'>25</span>
<span class='line-number'>26</span>
<span class='line-number'>27</span>
<span class='line-number'>28</span>
<span class='line-number'>29</span>
<span class='line-number'>30</span>
<span class='line-number'>31</span>
<span class='line-number'>32</span>
<span class='line-number'>33</span>
<span class='line-number'>34</span>
<span class='line-number'>35</span>
<span class='line-number'>36</span>
<span class='line-number'>37</span>
<span class='line-number'>38</span>
<span class='line-number'>39</span>
<span class='line-number'>40</span>
<span class='line-number'>41</span>
<span class='line-number'>42</span>
<span class='line-number'>43</span>
<span class='line-number'>44</span>
<span class='line-number'>45</span>
<span class='line-number'>46</span>
<span class='line-number'>47</span>
<span class='line-number'>48</span>
<span class='line-number'>49</span>
<span class='line-number'>50</span>
<span class='line-number'>51</span>
<span class='line-number'>52</span>
<span class='line-number'>53</span>
<span class='line-number'>54</span>
<span class='line-number'>55</span>
<span class='line-number'>56</span>
<span class='line-number'>57</span>
<span class='line-number'>58</span>
<span class='line-number'>59</span>
<span class='line-number'>60</span>
<span class='line-number'>61</span>
<span class='line-number'>62</span>
<span class='line-number'>63</span>
<span class='line-number'>64</span>
<span class='line-number'>65</span>
<span class='line-number'>66</span>
<span class='line-number'>67</span>
<span class='line-number'>68</span>
<span class='line-number'>69</span>
<span class='line-number'>70</span>
<span class='line-number'>71</span>
<span class='line-number'>72</span>
<span class='line-number'>73</span>
<span class='line-number'>74</span>
<span class='line-number'>75</span>
<span class='line-number'>76</span>
<span class='line-number'>77</span>
<span class='line-number'>78</span>
<span class='line-number'>79</span>
<span class='line-number'>80</span>
<span class='line-number'>81</span>
<span class='line-number'>82</span>
<span class='line-number'>83</span>
<span class='line-number'>84</span>
<span class='line-number'>85</span>
<span class='line-number'>86</span>
<span class='line-number'>87</span>
<span class='line-number'>88</span>
<span class='line-number'>89</span>
<span class='line-number'>90</span>
<span class='line-number'>91</span>
<span class='line-number'>92</span>
<span class='line-number'>93</span>
<span class='line-number'>94</span>
<span class='line-number'>95</span>
<span class='line-number'>96</span>
<span class='line-number'>97</span>
<span class='line-number'>98</span>
<span class='line-number'>99</span>
<span class='line-number'>100</span>
<span class='line-number'>101</span>
<span class='line-number'>102</span>
<span class='line-number'>103</span>
<span class='line-number'>104</span>
<span class='line-number'>105</span>
<span class='line-number'>106</span>
<span class='line-number'>107</span>
<span class='line-number'>108</span>
<span class='line-number'>109</span>
<span class='line-number'>110</span>
<span class='line-number'>111</span>
<span class='line-number'>112</span>
<span class='line-number'>113</span>
<span class='line-number'>114</span>
<span class='line-number'>115</span>
<span class='line-number'>116</span>
<span class='line-number'>117</span>
<span class='line-number'>118</span>
<span class='line-number'>119</span>
<span class='line-number'>120</span>
<span class='line-number'>121</span>
<span class='line-number'>122</span>
<span class='line-number'>123</span>
<span class='line-number'>124</span>
<span class='line-number'>125</span>
<span class='line-number'>126</span>
<span class='line-number'>127</span>
<span class='line-number'>128</span>
<span class='line-number'>129</span>
<span class='line-number'>130</span>
<span class='line-number'>131</span>
<span class='line-number'>132</span>
<span class='line-number'>133</span>
<span class='line-number'>134</span>
<span class='line-number'>135</span>
<span class='line-number'>136</span>
<span class='line-number'>137</span>
<span class='line-number'>138</span>
<span class='line-number'>139</span>
<span class='line-number'>140</span>
<span class='line-number'>141</span>
<span class='line-number'>142</span>
<span class='line-number'>143</span>
<span class='line-number'>144</span>
<span class='line-number'>145</span>
<span class='line-number'>146</span>
<span class='line-number'>147</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>int br_add_if(struct net_bridge *br, struct net_device *dev)
</span><span class='line'>{
</span><span class='line'>&#9;struct net_bridge_port *p;
</span><span class='line'>&#9;int err = 0;
</span><span class='line'>&#9;unsigned br_hr, dev_hr;
</span><span class='line'>&#9;bool changed_addr;
</span><span class='line'>
</span><span class='line'>&#9;/* Don't allow bridging non-ethernet like devices, or DSA-enabled
</span><span class='line'>&#9; * master network devices since the bridge layer rx_handler prevents
</span><span class='line'>&#9; * the DSA fake ethertype handler to be invoked, so we do not strip off
</span><span class='line'>&#9; * the DSA switch tag protocol header and the bridge layer just return
</span><span class='line'>&#9; * RX_HANDLER_CONSUMED, stopping RX processing for these frames.
</span><span class='line'>&#9; */
</span><span class='line'>
</span><span class='line'>&#9;if ((dev-&gt;flags & IFF_LOOPBACK) ||
</span><span class='line'>&#9;&#9;dev-&gt;type != ARPHRD_ETHER || dev-&gt;addr_len != ETH_ALEN ||
</span><span class='line'>&#9;&#9;!is_valid_ether_addr(dev-&gt;dev_addr) ||
</span><span class='line'>&#9;&#9;netdev_uses_dsa(dev))
</span><span class='line'>&#9;&#9;return -EINVAL;
</span><span class='line'>
</span><span class='line'>&#9;/* No bridging of bridges */
</span><span class='line'>&#9;if (dev-&gt;netdev_ops-&gt;ndo_start_xmit == br_dev_xmit)
</span><span class='line'>&#9;&#9;return -ELOOP;
</span><span class='line'>
</span><span class='line'>&#9;/* Device is already being bridged  */
</span><span class='line'>&#9;if (br_port_exists(dev))
</span><span class='line'>&#9;&#9;return -EBUSY;
</span><span class='line'>
</span><span class='line'>&#9;/* No bridging devices that dislike that (e.g. wireless) */
</span><span class='line'>&#9;if (dev-&gt;priv_flags & IFF_DONT_BRIDGE)
</span><span class='line'>&#9;&#9;return -EOPNOTSUPP;
</span><span class='line'>
</span><span class='line'>&#9;/*分配一个新网桥端口并对其初始化*/
</span><span class='line'>&#9;p = new_nbp(br, dev);
</span><span class='line'>&#9;if (IS_ERR(p))
</span><span class='line'>&#9;&#9;return PTR_ERR(p);
</span><span class='line'>
</span><span class='line'>&#9;/*调用设备通知链，告诉网络有这样一个设备*/
</span><span class='line'>&#9;call_netdevice_notifiers(NETDEV_JOIN, dev);
</span><span class='line'>
</span><span class='line'>&#9;/**向设备添加或删除所有多播帧的接收。*/
</span><span class='line'>&#9;err = dev_set_allmulti(dev, 1);
</span><span class='line'>&#9;if (err)
</span><span class='line'>&#9;&#9;goto put_back;
</span><span class='line'>
</span><span class='line'>&#9;err = kobject_init_and_add(&p-&gt;kobj, &brport_ktype, &(dev-&gt;dev.kobj),
</span><span class='line'>&#9;&#9;&#9;&#9;   SYSFS_BRIDGE_PORT_ATTR);
</span><span class='line'>&#9;if (err)
</span><span class='line'>&#9;&#9;goto err1;
</span><span class='line'>&#9;/*把链路添加到sysfs*/
</span><span class='line'>&#9;err = br_sysfs_addif(p);
</span><span class='line'>&#9;if (err)
</span><span class='line'>&#9;&#9;goto err2;
</span><span class='line'>
</span><span class='line'>&#9;err = br_netpoll_enable(p);
</span><span class='line'>&#9;if (err)
</span><span class='line'>&#9;&#9;goto err3;
</span><span class='line'>
</span><span class='line'>&#9;/*注册设备接收帧函数*/
</span><span class='line'>&#9;err = netdev_rx_handler_register(dev, br_handle_frame, p);
</span><span class='line'>&#9;if (err)
</span><span class='line'>&#9;&#9;goto err4;
</span><span class='line'>
</span><span class='line'>&#9;/*给该端口指派默认优先权*/
</span><span class='line'>&#9;dev-&gt;priv_flags |= IFF_BRIDGE_PORT;
</span><span class='line'>
</span><span class='line'>&#9;/*向上级设备添加主链路*/
</span><span class='line'>&#9;err = netdev_master_upper_dev_link(dev, br-&gt;dev, NULL, NULL);
</span><span class='line'>&#9;if (err)
</span><span class='line'>&#9;&#9;goto err5;
</span><span class='line'>
</span><span class='line'>&#9;/*禁用网络设备上的大型接收卸载（LRO）。
</span><span class='line'>&#9;必须在RTNL下调用。
</span><span class='line'>&#9;如果接收到的数据包可能转发到另一个接口，
</span><span class='line'>&#9;则需要这样做。*/
</span><span class='line'>&#9;dev_disable_lro(dev);
</span><span class='line'>
</span><span class='line'>&#9;list_add_rcu(&p-&gt;list, &br-&gt;port_list);
</span><span class='line'>&#9;/*更新桥上的端口数,如果有更新，再进一步将其设为混杂模式*/
</span><span class='line'>&#9;nbp_update_port_count(br);
</span><span class='line'>&#9;/* 重新计算dev-&gt;features并发送通知（如果已更改）。
</span><span class='line'>&#9;应该调用驱动程序或硬件依赖条件可能会改变影响功能。*/
</span><span class='line'>&#9;netdev_update_features(br-&gt;dev);
</span><span class='line'>
</span><span class='line'>&#9;br_hr = br-&gt;dev-&gt;needed_headroom;
</span><span class='line'>&#9;dev_hr = netdev_get_fwd_headroom(dev);
</span><span class='line'>&#9;if (br_hr &lt; dev_hr)
</span><span class='line'>&#9;&#9;update_headroom(br, dev_hr);
</span><span class='line'>&#9;else
</span><span class='line'>&#9;&#9;netdev_set_rx_headroom(dev, br_hr);
</span><span class='line'>
</span><span class='line'>&#9;/*把dev的mac添加到转发数据库中*/
</span><span class='line'>&#9;if (br_fdb_insert(br, p, dev-&gt;dev_addr, 0))
</span><span class='line'>&#9;&#9;netdev_err(dev, "failed insert local address bridge forwarding table\n");
</span><span class='line'>
</span><span class='line'>&#9;/*初始化该桥端口的vlan*/
</span><span class='line'>&#9;err = nbp_vlan_init(p);
</span><span class='line'>&#9;if (err) {
</span><span class='line'>&#9;&#9;netdev_err(dev, "failed to initialize vlan filtering on this port\n");
</span><span class='line'>&#9;&#9;goto err6;
</span><span class='line'>&#9;}
</span><span class='line'>
</span><span class='line'>&#9;spin_lock_bh(&br-&gt;lock);
</span><span class='line'>&#9;/*更新网桥id*/
</span><span class='line'>&#9;changed_addr = br_stp_recalculate_bridge_id(br);
</span><span class='line'>&#9;/*设备是否启动，桥是否启动，设备上是否有载波信号(网桥没有载波状态，因为网桥是虚拟设备)*/
</span><span class='line'>&#9;if (netif_running(dev) && netif_oper_up(dev) &&
</span><span class='line'>&#9;&#9;(br-&gt;dev-&gt;flags & IFF_UP))
</span><span class='line'>&#9;&#9;/*启动网桥端口*/
</span><span class='line'>&#9;&#9;br_stp_enable_port(p);
</span><span class='line'>&#9;spin_unlock_bh(&br-&gt;lock);
</span><span class='line'>
</span><span class='line'>&#9;br_ifinfo_notify(RTM_NEWLINK, p);
</span><span class='line'>&#9;/*如果网桥的地址改变，则调用通知连相关的函数*/
</span><span class='line'>&#9;if (changed_addr)
</span><span class='line'>&#9;&#9;call_netdevice_notifiers(NETDEV_CHANGEADDR, br-&gt;dev);
</span><span class='line'>&#9;/*更新网桥mtu*/
</span><span class='line'>&#9;dev_set_mtu(br-&gt;dev, br_min_mtu(br));
</span><span class='line'>&#9;br_set_gso_limits(br);
</span><span class='line'>&#9;/*添加一个内核对象*/
</span><span class='line'>&#9;kobject_uevent(&p-&gt;kobj, KOBJ_ADD);
</span><span class='line'>
</span><span class='line'>&#9;return 0;
</span><span class='line'>
</span><span class='line'>err6:
</span><span class='line'>&#9;list_del_rcu(&p-&gt;list);
</span><span class='line'>&#9;br_fdb_delete_by_port(br, p, 0, 1);
</span><span class='line'>&#9;nbp_update_port_count(br);
</span><span class='line'>&#9;netdev_upper_dev_unlink(dev, br-&gt;dev);
</span><span class='line'>
</span><span class='line'>err5:
</span><span class='line'>&#9;dev-&gt;priv_flags &= ~IFF_BRIDGE_PORT;
</span><span class='line'>&#9;netdev_rx_handler_unregister(dev);
</span><span class='line'>err4:
</span><span class='line'>&#9;br_netpoll_disable(p);
</span><span class='line'>err3:
</span><span class='line'>&#9;sysfs_remove_link(br-&gt;ifobj, p-&gt;dev-&gt;name);
</span><span class='line'>err2:
</span><span class='line'>&#9;kobject_put(&p-&gt;kobj);
</span><span class='line'>&#9;p = NULL; /* kobject_put frees */
</span><span class='line'>err1:
</span><span class='line'>&#9;dev_set_allmulti(dev, -1);
</span><span class='line'>put_back:
</span><span class='line'>&#9;dev_put(dev);
</span><span class='line'>&#9;kfree(p);
</span><span class='line'>&#9;return err;
</span><span class='line'>}</span></code></pre></td></tr></table></div></figure>


<p>在桥上添加接口的基本步骤，如上，删除桥端口，主要是把建立接口时所做的事情撤销，如添加接口出错时的一些处理。</p>

<h2>桥设备及端口的开启和关闭</h2>

<p>关于设备的添加删除的基本动作，我们已经知道。
这节，我们看看关于网桥设备以及桥设备上的端口的启动和关闭。</p>

<p>我们说过，在初始化一个桥设备的时候有这样一个操作：
dev->netdev_ops = &amp;br_netdev_ops；</p>

<p>br_netdev_ops这个参数，注册了很多函数，其中包括网桥设备的启动和关闭函数</p>

<p>br_dev_open和br_dev_stop,这两个函数的工作主要是初始化桥设备的一些队列和
桥设备上端口的一些启动和关闭动作。</p>

<h4>启动和关闭网桥设备</h4>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>static int br_dev_open(struct net_device *dev)
</span><span class='line'>{
</span><span class='line'>&#9;struct net_bridge *br = netdev_priv(dev);
</span><span class='line'>&#9;/*重新更新网桥设备功能*/
</span><span class='line'>&#9;netdev_update_features(dev);
</span><span class='line'>&#9;/*函数启动进行设备传输*/
</span><span class='line'>&#9;netif_start_queue(dev);
</span><span class='line'>&#9;/*启动网桥设备*/
</span><span class='line'>&#9;br_stp_enable_bridge(br);
</span><span class='line'>&#9;/*初始化网桥本身的多播对列*/
</span><span class='line'>&#9;br_multicast_open(br);
</span><span class='line'>&#9;return 0;
</span><span class='line'>}</span></code></pre></td></tr></table></div></figure>




<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>static int br_dev_stop(struct net_device *dev)
</span><span class='line'>{
</span><span class='line'>&#9;struct net_bridge *br = netdev_priv(dev);
</span><span class='line'>&#9;/*关闭网桥设备*/
</span><span class='line'>&#9;br_stp_disable_bridge(br);
</span><span class='line'>&#9;/*关闭网桥设备的多播队列*/
</span><span class='line'>&#9;br_multicast_stop(br);
</span><span class='line'>&#9;/*关闭设备的传输，任何企图在设备上传输信息的尝试都会被拒绝*/
</span><span class='line'>&#9;netif_stop_queue(dev);
</span><span class='line'>
</span><span class='line'>&#9;return 0;
</span><span class='line'>}</span></code></pre></td></tr></table></div></figure>


<p>启动网桥设备，当启动网桥设备时，先前绑定在该设备上的端口也会跟着启动</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
<span class='line-number'>16</span>
<span class='line-number'>17</span>
<span class='line-number'>18</span>
<span class='line-number'>19</span>
<span class='line-number'>20</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>void br_stp_enable_bridge(struct net_bridge *br)
</span><span class='line'>{
</span><span class='line'>&#9;struct net_bridge_port *p;
</span><span class='line'>&#9;/*锁定网桥*/
</span><span class='line'>&#9;spin_lock_bh(&br-&gt;lock);
</span><span class='line'>&#9;if (br-&gt;stp_enabled == BR_KERNEL_STP)
</span><span class='line'>&#9;&#9;mod_timer(&br-&gt;hello_timer, jiffies + br-&gt;hello_time);
</span><span class='line'>
</span><span class='line'>&#9;/* 当网桥启动时，设置次定时器，1/10秒到期一次 */
</span><span class='line'>&#9;mod_timer(&br-&gt;gc_timer, jiffies + HZ/10);
</span><span class='line'>&#9;/*TX配置bpdu*/
</span><span class='line'>&#9;br_config_bpdu_generation(br);
</span><span class='line'>
</span><span class='line'>&#9;list_for_each_entry(p, &br-&gt;port_list, list) {
</span><span class='line'>&#9;&#9;if (netif_running(p-&gt;dev) && netif_oper_up(p-&gt;dev))
</span><span class='line'>&#9;&#9;&#9;br_stp_enable_port(p);/*启动网桥设备的每个端口*/
</span><span class='line'>&#9;}
</span><span class='line'>&#9;/*给网桥解锁*/
</span><span class='line'>&#9;spin_unlock_bh(&br-&gt;lock);
</span><span class='line'>}</span></code></pre></td></tr></table></div></figure>


<p>关闭网桥设备</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
<span class='line-number'>16</span>
<span class='line-number'>17</span>
<span class='line-number'>18</span>
<span class='line-number'>19</span>
<span class='line-number'>20</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>void br_stp_disable_bridge(struct net_bridge *br)
</span><span class='line'>{
</span><span class='line'>&#9;struct net_bridge_port *p;
</span><span class='line'>
</span><span class='line'>&#9;spin_lock_bh(&br-&gt;lock);
</span><span class='line'>&#9;list_for_each_entry(p, &br-&gt;port_list, list) {
</span><span class='line'>&#9;&#9;if (p-&gt;state != BR_STATE_DISABLED)
</span><span class='line'>&#9;&#9;&#9;br_stp_disable_port(p);/*关闭网桥设备的每个端口*/
</span><span class='line'>&#9;}
</span><span class='line'>&#9;/*重新设置拓扑标识*/
</span><span class='line'>&#9;br-&gt;topology_change = 0;
</span><span class='line'>&#9;br-&gt;topology_change_detected = 0;
</span><span class='line'>&#9;spin_unlock_bh(&br-&gt;lock);
</span><span class='line'>
</span><span class='line'>&#9;/*删除在初始化桥设备时的定时器*/
</span><span class='line'>&#9;del_timer_sync(&br-&gt;hello_timer);
</span><span class='line'>&#9;del_timer_sync(&br-&gt;topology_change_timer);
</span><span class='line'>&#9;del_timer_sync(&br-&gt;tcn_timer);
</span><span class='line'>&#9;del_timer_sync(&br-&gt;gc_timer);
</span><span class='line'>}</span></code></pre></td></tr></table></div></figure>


<h3>启动和关闭网桥端口</h3>

<p>要启动网桥端口，必须满足下列几个条件</p>

<p>1.被管理的相关设备已用管理手段启动</p>

<p>2.被绑定的相关设备有载波状态</p>

<p>3.相关的网桥设备已用管理手段启动</p>

<p>注意：网桥设备上没有载波状态，因为网桥是虚拟设备。</p>

<p>当网桥是以用户空间命令建起来并且先前三个条件都满足时，该网桥端口就可以立即启用了</p>

<p>但是，假设当端口建立时，由于上述三项条件至少有一项不满足无法启动端口时，下面的条件是
每项条件最终满足时启用端口的场合：</p>

<p>1.当被关闭的网桥设备重新启动时，其所有关闭的端口就会启用</p>

<p>2.当被绑定的设备检测到载波状态时，桥程序会收到NETDE_CHANGE通知消息</p>

<p>3.当被关掉的版定设备重启时，桥程序会收到NETDEV_UP的通知消息</p>

<p>如若还不满足，网桥端口就会被关闭</p>

<h4>启动网桥上的端口</h4>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>void br_stp_enable_port(struct net_bridge_port *p)
</span><span class='line'>{
</span><span class='line'>&#9;/*初始化端口*/
</span><span class='line'>&#9;br_init_port(p);
</span><span class='line'>&#9;/*遍历所有端口，为端口指定合适的状态*/
</span><span class='line'>&#9;br_port_state_selection(p-&gt;br);
</span><span class='line'>&#9;/*捕捉一个端口变化信息的通知*/
</span><span class='line'>&#9;br_ifinfo_notify(RTM_NEWLINK, p);
</span><span class='line'>}</span></code></pre></td></tr></table></div></figure>


<h4>关闭网桥上的端口</h4>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
<span class='line-number'>16</span>
<span class='line-number'>17</span>
<span class='line-number'>18</span>
<span class='line-number'>19</span>
<span class='line-number'>20</span>
<span class='line-number'>21</span>
<span class='line-number'>22</span>
<span class='line-number'>23</span>
<span class='line-number'>24</span>
<span class='line-number'>25</span>
<span class='line-number'>26</span>
<span class='line-number'>27</span>
<span class='line-number'>28</span>
<span class='line-number'>29</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>void br_stp_disable_port(struct net_bridge_port *p)
</span><span class='line'>{
</span><span class='line'>&#9;struct net_bridge *br = p-&gt;br;
</span><span class='line'>&#9;int wasroot;
</span><span class='line'>&#9;/*判断是否是根网桥*/
</span><span class='line'>&#9;wasroot = br_is_root_bridge(br);
</span><span class='line'>&#9;/*分配制定角色*/
</span><span class='line'>&#9;br_become_designated_port(p);
</span><span class='line'>&#9;/*将关闭位置位*/
</span><span class='line'>&#9;br_set_state(p, BR_STATE_DISABLED);
</span><span class='line'>&#9;p-&gt;topology_change_ack = 0;
</span><span class='line'>&#9;p-&gt;config_pending = 0;
</span><span class='line'>
</span><span class='line'>&#9;br_ifinfo_notify(RTM_NEWLINK, p);
</span><span class='line'>&#9;/*删除定时器*/
</span><span class='line'>&#9;del_timer(&p-&gt;message_age_timer);
</span><span class='line'>&#9;del_timer(&p-&gt;forward_delay_timer);
</span><span class='line'>&#9;del_timer(&p-&gt;hold_timer);
</span><span class='line'>&#9;/*更改转发表信息*/
</span><span class='line'>&#9;br_fdb_delete_by_port(br, p, 0, 0);
</span><span class='line'>&#9;br_multicast_disable_port(p);
</span><span class='line'>&#9;/*更改桥的bpdu信息*/
</span><span class='line'>&#9;br_configuration_update(br);
</span><span class='line'>&#9;/*更新所有桥上端口的状态*/
</span><span class='line'>&#9;br_port_state_selection(br);
</span><span class='line'>&#9;/*处理非根网桥到根网桥的转移*/
</span><span class='line'>&#9;if (br_is_root_bridge(br) && !wasroot)
</span><span class='line'>&#9;&#9;br_become_root_bridge(br);
</span><span class='line'>}</span></code></pre></td></tr></table></div></figure>


<p>注意，当网桥端口关闭时，非根网桥可能会变成根网桥</p>

<h2>skb桥转发蓝图</h2>

<p><img src="/images/kernel/20201109-10.png" alt="" /></p>

<p>需要说明的是：</p>

<p>1.我们先暂时忽略数据包从一开始是怎么从驱动进入到netif_receive_skb的，因为这个暂时不影响我们理解这幅图的流程。</p>

<p>2.由于桥转发的篇幅较大，图中没有标示出，数据包中途被丢弃的情况。约定数据包会发送成功。</p>

<p>现在数据包(skb)已经准备好了装备要闯关了</p>

<p>1.首先skb从驱动经过繁杂的路线走到了netif_receive_skb这个函数中经过一些小波折到达<code>__netif_receive_skb_core</code>中时遇到了第一个十字路口是看了看自己有没有skb->dev->rx_handler(注1)这个装备，如果有，则进入br_handle_frame(注2).如果没有则直接上协议栈。</p>

<p>注1：桥下的设备注册过rx_handler函数，所以数据包会进入桥，br_pass_frame_up函数将原先的设备换成了桥设备， 而桥设备没有注册过rx_handler函数，所以数据包不会二次进入桥。</p>

<p>注2：br_handle_frame我们在前几节提到过，是skb进入桥的入口函数，在br_add_if的时候会注册该函数。</p>

<p>2.skb注定要经历一番劫难，刚进入br_handle_frame又将陷入两难境地，此时有两个入口，这两个是netfilter设下的连个hook点，分别是，NF_BR_PRE_ROUTING，和NF_BR_LOCAL_IN，两种路径，如果数据包只想去本地，则会选择NF_BR_LOCAL_IN入口，然后发往本地，如果暂时还确定不了，则先进入NF_BR_PRE_ROUTING入口.</p>

<p>3.进入NF_BR_PRE_ROUTING入口后，会遇到br_handle_frame_finish函数，这个函数决定了skb的何去何从，(1)如果是转发，则在经过NF_BR_FORWARD钩子点进入转发阶段的障碍，最后在进入NF_BR_POST_ROUTING，以及最终的dev_queue_xmit，实现最终转发。(2)如果发往本地则重新进入NF_BR_LOCAL_IN最后在进入netif_receive_skb，进行转发。skb在经过目前口述的磨练最终得以释放。</p>

<p>4.如果是如果是本地发出的数据包，经过NF_BR_LOCAL_OUT钩子点然后进入最后阶段的NF_BR_POST_ROUTING，进行相应的转发。</p>

<h2>桥数据包接收&mdash;-br_handle_frame</h2>

<p>一个很重要的函数br_handle_frame这个函数的初始注册地点是在桥添加接口的时候，注册在桥某一个接口上</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>int br_add_if(struct net_bridge *br, struct net_device *dev)
</span><span class='line'>{
</span><span class='line'>&#9;........
</span><span class='line'>&#9;/*注册设备接收帧函数*/
</span><span class='line'>&#9;err = netdev_rx_handler_register(dev, br_handle_frame, p);
</span><span class='line'>&#9;........
</span><span class='line'>}</span></code></pre></td></tr></table></div></figure>


<p>其次，那么<code>__netif_receive_skb_core</code>是怎样让数据包进入桥的呢？我们看看上面提到的netdev_rx_handler_register函数，具体做了什么</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
<span class='line-number'>16</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>int netdev_rx_handler_register(struct net_device *dev,
</span><span class='line'>&#9;&#9;&#9;&#9;   rx_handler_func_t *rx_handler,
</span><span class='line'>&#9;&#9;&#9;&#9;   void *rx_handler_data)
</span><span class='line'>{
</span><span class='line'>&#9;ASSERT_RTNL();
</span><span class='line'>
</span><span class='line'>&#9;if (dev-&gt;rx_handler)
</span><span class='line'>&#9;&#9;return -EBUSY;
</span><span class='line'>&#9;/* Note: rx_handler_data must be set before rx_handler */
</span><span class='line'>&#9;/*将dev-&gt;rx_handler_data，指向rx_handler_data(上面的p是桥端口信息)*/
</span><span class='line'>&#9;rcu_assign_pointer(dev-&gt;rx_handler_data, rx_handler_data);
</span><span class='line'>&#9;/*将dev-&gt;rx_handle指针指向rx_handler*/
</span><span class='line'>&#9;rcu_assign_pointer(dev-&gt;rx_handler, rx_handler);
</span><span class='line'>
</span><span class='line'>&#9;return 0;
</span><span class='line'>}</span></code></pre></td></tr></table></div></figure>


<p>看完这个函数，我们就明白了为什么在<code>__netif_receive_skb_core</code>中可以用skb->dev->rx_handle将数据包传入br_handle_frame函数，也就是将数据包传入了桥。</p>

<p>值得注意的是：上面的dev是桥下的设备，不是桥设备，桥设备(比如br0)是没有注册rx_handle这个函数的</p>

<p>好，了解到，桥的注册函数和如何接收数据包后，然后一起来看看br_handle_frame是如何操作的</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
<span class='line-number'>16</span>
<span class='line-number'>17</span>
<span class='line-number'>18</span>
<span class='line-number'>19</span>
<span class='line-number'>20</span>
<span class='line-number'>21</span>
<span class='line-number'>22</span>
<span class='line-number'>23</span>
<span class='line-number'>24</span>
<span class='line-number'>25</span>
<span class='line-number'>26</span>
<span class='line-number'>27</span>
<span class='line-number'>28</span>
<span class='line-number'>29</span>
<span class='line-number'>30</span>
<span class='line-number'>31</span>
<span class='line-number'>32</span>
<span class='line-number'>33</span>
<span class='line-number'>34</span>
<span class='line-number'>35</span>
<span class='line-number'>36</span>
<span class='line-number'>37</span>
<span class='line-number'>38</span>
<span class='line-number'>39</span>
<span class='line-number'>40</span>
<span class='line-number'>41</span>
<span class='line-number'>42</span>
<span class='line-number'>43</span>
<span class='line-number'>44</span>
<span class='line-number'>45</span>
<span class='line-number'>46</span>
<span class='line-number'>47</span>
<span class='line-number'>48</span>
<span class='line-number'>49</span>
<span class='line-number'>50</span>
<span class='line-number'>51</span>
<span class='line-number'>52</span>
<span class='line-number'>53</span>
<span class='line-number'>54</span>
<span class='line-number'>55</span>
<span class='line-number'>56</span>
<span class='line-number'>57</span>
<span class='line-number'>58</span>
<span class='line-number'>59</span>
<span class='line-number'>60</span>
<span class='line-number'>61</span>
<span class='line-number'>62</span>
<span class='line-number'>63</span>
<span class='line-number'>64</span>
<span class='line-number'>65</span>
<span class='line-number'>66</span>
<span class='line-number'>67</span>
<span class='line-number'>68</span>
<span class='line-number'>69</span>
<span class='line-number'>70</span>
<span class='line-number'>71</span>
<span class='line-number'>72</span>
<span class='line-number'>73</span>
<span class='line-number'>74</span>
<span class='line-number'>75</span>
<span class='line-number'>76</span>
<span class='line-number'>77</span>
<span class='line-number'>78</span>
<span class='line-number'>79</span>
<span class='line-number'>80</span>
<span class='line-number'>81</span>
<span class='line-number'>82</span>
<span class='line-number'>83</span>
<span class='line-number'>84</span>
<span class='line-number'>85</span>
<span class='line-number'>86</span>
<span class='line-number'>87</span>
<span class='line-number'>88</span>
<span class='line-number'>89</span>
<span class='line-number'>90</span>
<span class='line-number'>91</span>
<span class='line-number'>92</span>
<span class='line-number'>93</span>
<span class='line-number'>94</span>
<span class='line-number'>95</span>
<span class='line-number'>96</span>
<span class='line-number'>97</span>
<span class='line-number'>98</span>
<span class='line-number'>99</span>
<span class='line-number'>100</span>
<span class='line-number'>101</span>
<span class='line-number'>102</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>/*
</span><span class='line'> * Return NULL if skb is handled
</span><span class='line'> * note: already called with rcu_read_lock
</span><span class='line'> */
</span><span class='line'>rx_handler_result_t br_handle_frame(struct sk_buff **pskb)
</span><span class='line'>{
</span><span class='line'>&#9;struct net_bridge_port *p;
</span><span class='line'>&#9;struct sk_buff *skb = *pskb;
</span><span class='line'>&#9;const unsigned char *dest = eth_hdr(skb)-&gt;h_dest;
</span><span class='line'>&#9;br_should_route_hook_t *rhook;
</span><span class='line'>
</span><span class='line'>&#9;if (unlikely(skb-&gt;pkt_type == PACKET_LOOPBACK))
</span><span class='line'>&#9;&#9;return RX_HANDLER_PASS;
</span><span class='line'>&#9;/*判断是否是有效的mac地址，即不是多播地址也不是全00地址*/
</span><span class='line'>&#9;if (!is_valid_ether_addr(eth_hdr(skb)-&gt;h_source))
</span><span class='line'>&#9;&#9;goto drop;
</span><span class='line'>&#9;/*判断是否是共享数据包，若果是则clone该数据包*/
</span><span class='line'>&#9;skb = skb_share_check(skb, GFP_ATOMIC);
</span><span class='line'>&#9;if (!skb)
</span><span class='line'>&#9;&#9;return RX_HANDLER_CONSUMED;
</span><span class='line'>&#9;/*获取数据包网桥端口的一些信息*/
</span><span class='line'>&#9;p = br_port_get_rcu(skb-&gt;dev);
</span><span class='line'>&#9;/*BPDU是网桥之间交流的报文，目标mac是 01:80:C2:00:00:00*/
</span><span class='line'>&#9;if (unlikely(is_link_local_ether_addr(dest))) {
</span><span class='line'>&#9;&#9;u16 fwd_mask = p-&gt;br-&gt;group_fwd_mask_required;
</span><span class='line'>
</span><span class='line'>&#9;&#9;/*
</span><span class='line'>&#9;&#9; * See IEEE 802.1D Table 7-10 Reserved addresses
</span><span class='line'>&#9;&#9; *
</span><span class='line'>&#9;&#9; * Assignment             Value
</span><span class='line'>&#9;&#9; * Bridge Group Address       01-80-C2-00-00-00
</span><span class='line'>&#9;&#9; * (MAC Control) 802.3        01-80-C2-00-00-01
</span><span class='line'>&#9;&#9; * (Link Aggregation) 802.3   01-80-C2-00-00-02
</span><span class='line'>&#9;&#9; * 802.1X PAE address     01-80-C2-00-00-03
</span><span class='line'>&#9;&#9; *
</span><span class='line'>&#9;&#9; * 802.1AB LLDP       01-80-C2-00-00-0E
</span><span class='line'>&#9;&#9; *
</span><span class='line'>&#9;&#9; * Others reserved for future standardization
</span><span class='line'>&#9;&#9; */
</span><span class='line'>&#9;&#9;switch (dest[5]) {
</span><span class='line'>&#9;&#9;case 0x00:    /* Bridge Group Address */
</span><span class='line'>&#9;&#9;&#9;/* If STP is turned off,
</span><span class='line'>&#9;&#9;&#9;   then must forward to keep loop detection */
</span><span class='line'>&#9;&#9;&#9;if (p-&gt;br-&gt;stp_enabled == BR_NO_STP ||
</span><span class='line'>&#9;&#9;&#9;&#9;fwd_mask & (1u &lt;&lt; dest[5]))
</span><span class='line'>&#9;&#9;&#9;&#9;goto forward;
</span><span class='line'>&#9;&#9;&#9;*pskb = skb;
</span><span class='line'>&#9;&#9;&#9;__br_handle_local_finish(skb);
</span><span class='line'>&#9;&#9;&#9;return RX_HANDLER_PASS;
</span><span class='line'>
</span><span class='line'>&#9;&#9;case 0x01:    /* IEEE MAC (Pause) */
</span><span class='line'>&#9;&#9;&#9;goto drop;
</span><span class='line'>
</span><span class='line'>&#9;&#9;case 0x0E:    /* 802.1AB LLDP */
</span><span class='line'>&#9;&#9;&#9;fwd_mask |= p-&gt;br-&gt;group_fwd_mask;
</span><span class='line'>&#9;&#9;&#9;if (fwd_mask & (1u &lt;&lt; dest[5]))
</span><span class='line'>&#9;&#9;&#9;&#9;goto forward;
</span><span class='line'>&#9;&#9;&#9;*pskb = skb;
</span><span class='line'>&#9;&#9;&#9;__br_handle_local_finish(skb);
</span><span class='line'>&#9;&#9;&#9;return RX_HANDLER_PASS;
</span><span class='line'>
</span><span class='line'>&#9;&#9;default:
</span><span class='line'>&#9;&#9;&#9;/* Allow selective forwarding for most other protocols */
</span><span class='line'>&#9;&#9;&#9;fwd_mask |= p-&gt;br-&gt;group_fwd_mask;
</span><span class='line'>&#9;&#9;&#9;if (fwd_mask & (1u &lt;&lt; dest[5]))
</span><span class='line'>&#9;&#9;&#9;&#9;goto forward;
</span><span class='line'>&#9;&#9;}
</span><span class='line'>
</span><span class='line'>&#9;&#9;/* Deliver packet to local host only */
</span><span class='line'>&#9;&#9;NF_HOOK(NFPROTO_BRIDGE, NF_BR_LOCAL_IN, dev_net(skb-&gt;dev),
</span><span class='line'>&#9;&#9;&#9;NULL, skb, skb-&gt;dev, NULL, br_handle_local_finish);
</span><span class='line'>&#9;&#9;return RX_HANDLER_CONSUMED;
</span><span class='line'>&#9;}
</span><span class='line'>
</span><span class='line'>forward:
</span><span class='line'>&#9;switch (p-&gt;state) {
</span><span class='line'>&#9;case BR_STATE_FORWARDING:
</span><span class='line'>&#9;&#9;/*ebtables获取路由的hook点*/
</span><span class='line'>&#9;&#9;rhook = rcu_dereference(br_should_route_hook);
</span><span class='line'>&#9;&#9;if (rhook) {/*如果是转发状态，则转发数据包，然后返回*/
</span><span class='line'>&#9;&#9;&#9;if ((*rhook)(skb)) {
</span><span class='line'>&#9;&#9;&#9;&#9;*pskb = skb;
</span><span class='line'>&#9;&#9;&#9;&#9;return RX_HANDLER_PASS;
</span><span class='line'>&#9;&#9;&#9;}
</span><span class='line'>&#9;&#9;&#9;dest = eth_hdr(skb)-&gt;h_dest;
</span><span class='line'>&#9;&#9;}
</span><span class='line'>&#9;&#9;/* fall through */
</span><span class='line'>&#9;case BR_STATE_LEARNING:
</span><span class='line'>&#9;&#9;/*目的地址是否是设备链路层地址 */
</span><span class='line'>&#9;&#9;if (ether_addr_equal(p-&gt;br-&gt;dev-&gt;dev_addr, dest))
</span><span class='line'>&#9;&#9;&#9;skb-&gt;pkt_type = PACKET_HOST;
</span><span class='line'>&#9;&#9;/*将数据包送入数据帧处理函数br_handle_frame_finish*/
</span><span class='line'>&#9;&#9;NF_HOOK(NFPROTO_BRIDGE, NF_BR_PRE_ROUTING,
</span><span class='line'>&#9;&#9;&#9;dev_net(skb-&gt;dev), NULL, skb, skb-&gt;dev, NULL,
</span><span class='line'>&#9;&#9;&#9;br_handle_frame_finish);
</span><span class='line'>&#9;&#9;break;
</span><span class='line'>&#9;default:
</span><span class='line'>drop:
</span><span class='line'>&#9;&#9;kfree_skb(skb);
</span><span class='line'>&#9;}
</span><span class='line'>&#9;return RX_HANDLER_CONSUMED;
</span><span class='line'>}</span></code></pre></td></tr></table></div></figure>


<p>在br_handle_frame主要做一件事，就是将数据包放进那个钩子点。</p>

<p>说明：br_handle_frame函数中有两个hook函数，br_handle_local_finish和br_handle_frame_finish这两个函数只有在netfilter因其他原因没有丢弃或者消化该帧时才会被调用，ebtables也能查看帧。ebtables是一个架构，能提供一些netfilter所没有的提供的额外功能，尤其是，ebtables可以过滤和修改任何类型的帧，而非仅限于那些携带ip封包的帧。</p>

<h2>桥数据包处理函数——br_handle_frame_finish</h2>

<p>br_handle_frame_finish.
作用：br_handle_frame_finish函数主要是决策将不同类别的数据包做不同的分发路径。</p>

<p>其函数处理的过程如下图所示：</p>

<p><img src="/images/kernel/20201109-11.png" alt="" /></p>

<p>首先判断该数据包是否符合桥转发的条件：</p>

<p>  (1)桥端口状态是否是开启状态，如果没有开启则丢掉数据包</p>

<p>  (2)是否允许从该桥上转发，如果不允许，则直接返回0</p>

<p>获得桥转发的条件以后，开始判断数据包的类型：</p>

<p>  (1)判断此时桥的标志为允许做哪些事情，学习还是扩展</p>

<p>  如果学习的标志位被至位，则更新数据转发表。否则继续向下走</p>

<p>  (2)根据多播或者广播报文的类型决定数据包的去留</p>

<p>  (3)判断此时端口的状态，如果是学习状态，则将数据包丢弃</p>

<p>  (要注意的是：桥的端口状态(和上面的flag不冲突，上面的flag表示网桥可以做的事情)state表示网桥端口所处于的状态)
在处理完一些需要预备的事情之后，就要为数据包的转发开始做准备了</p>

<p>  (1)网桥设备是否处于混杂模式，如果是则建立副本，为发往本地做个备份</p>

<p>  (注意的是，所有网桥端口绑定的设备都会处于混杂模式，因为 网桥运行必须此模式。但除非明确的对其进行配置，否则网桥自己是不会处于混杂模式的)</p>

<p>  (2)在次判断广播还是多播地址</p>

<p>   广播地址：仅仅设置副本，进行广播转发和发往本地</p>

<p>多播地址：先查多播地址转发表，如果存在，设置副本，进行多播转发，原始数据包指向NULL,如果已经传送至本地，则会释放副本，不进行本地转发，否则重新转发到本地</p>

<p>  (3)不是广播或者多播</p>

<p>  判断是否本地地址，如果是本地地址，则将原始数据包指向NULL，发往本地。</p>

<p>  否则进行数据包转发</p>

<h2>桥数据包转发</h2>

<p>无论是在发往本地还是转发，有一个函数的功能是不能忽略的，就是br_handle_vlan函数</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
<span class='line-number'>16</span>
<span class='line-number'>17</span>
<span class='line-number'>18</span>
<span class='line-number'>19</span>
<span class='line-number'>20</span>
<span class='line-number'>21</span>
<span class='line-number'>22</span>
<span class='line-number'>23</span>
<span class='line-number'>24</span>
<span class='line-number'>25</span>
<span class='line-number'>26</span>
<span class='line-number'>27</span>
<span class='line-number'>28</span>
<span class='line-number'>29</span>
<span class='line-number'>30</span>
<span class='line-number'>31</span>
<span class='line-number'>32</span>
<span class='line-number'>33</span>
<span class='line-number'>34</span>
<span class='line-number'>35</span>
<span class='line-number'>36</span>
<span class='line-number'>37</span>
<span class='line-number'>38</span>
<span class='line-number'>39</span>
<span class='line-number'>40</span>
<span class='line-number'>41</span>
<span class='line-number'>42</span>
<span class='line-number'>43</span>
<span class='line-number'>44</span>
<span class='line-number'>45</span>
<span class='line-number'>46</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>struct sk_buff *br_handle_vlan(struct net_bridge *br,
</span><span class='line'>&#9;&#9;&#9;&#9;   struct net_bridge_vlan_group *vg,
</span><span class='line'>&#9;&#9;&#9;&#9;   struct sk_buff *skb)
</span><span class='line'>{
</span><span class='line'>&#9;struct br_vlan_stats *stats;
</span><span class='line'>&#9;struct net_bridge_vlan *v;
</span><span class='line'>&#9;u16 vid;
</span><span class='line'>
</span><span class='line'>&#9;/* If this packet was not filtered at input, let it pass */
</span><span class='line'>&#9;if (!BR_INPUT_SKB_CB(skb)-&gt;vlan_filtered)
</span><span class='line'>&#9;&#9;goto out;
</span><span class='line'>
</span><span class='line'>&#9;/* At this point, we know that the frame was filtered and contains
</span><span class='line'>&#9; * a valid vlan id.  If the vlan id has untagged flag set,
</span><span class='line'>&#9; * send untagged; otherwise, send tagged.
</span><span class='line'>&#9; */
</span><span class='line'>&#9;br_vlan_get_tag(skb, &vid);
</span><span class='line'>&#9;/*find vid from vlan group*/
</span><span class='line'>&#9;v = br_vlan_find(vg, vid);
</span><span class='line'>&#9;/* Vlan entry must be configured at this point.  The
</span><span class='line'>&#9; * only exception is the bridge is set in promisc mode and the
</span><span class='line'>&#9; * packet is destined for the bridge device.  In this case
</span><span class='line'>&#9; * pass the packet as is.
</span><span class='line'>&#9; */
</span><span class='line'>&#9;if (!v || !br_vlan_should_use(v)) {
</span><span class='line'>&#9;&#9;if ((br-&gt;dev-&gt;flags & IFF_PROMISC) && skb-&gt;dev == br-&gt;dev) {
</span><span class='line'>&#9;&#9;&#9;goto out;
</span><span class='line'>&#9;&#9;} else {
</span><span class='line'>&#9;&#9;&#9;kfree_skb(skb);
</span><span class='line'>&#9;&#9;&#9;return NULL;
</span><span class='line'>&#9;&#9;}
</span><span class='line'>&#9;}
</span><span class='line'>&#9;/*statistacs the vlan if flow and if the vlan_stats_enabled is true */
</span><span class='line'>&#9;if (br-&gt;vlan_stats_enabled) {
</span><span class='line'>&#9;&#9;stats = this_cpu_ptr(v-&gt;stats);
</span><span class='line'>&#9;&#9;u64_stats_update_begin(&stats-&gt;syncp);
</span><span class='line'>&#9;&#9;stats-&gt;tx_bytes += skb-&gt;len;
</span><span class='line'>&#9;&#9;stats-&gt;tx_packets++;
</span><span class='line'>&#9;&#9;u64_stats_update_end(&stats-&gt;syncp);
</span><span class='line'>&#9;}
</span><span class='line'>
</span><span class='line'>&#9;if (v-&gt;flags & BRIDGE_VLAN_INFO_UNTAGGED)
</span><span class='line'>&#9;&#9;skb-&gt;vlan_tci = 0;
</span><span class='line'>out:
</span><span class='line'>&#9;return skb;
</span><span class='line'>}</span></code></pre></td></tr></table></div></figure>


<p>这个函数的作用很简单就是，数据包是否要带tag,</p>

<p>过程：</p>

<p>在传递进来的vlan group中查找自己所处的vlan</p>

<p>如果该vlan不存在则判断当前模式是否是混杂模式和数据包的设备是否是桥下的设备，选择发包或者丢弃。</p>

<p>如果存在，且vlan是开启的，则统计vlan接口上的数据流量，最后根据vlan出口的标记位进行位运算判断是否要带tag.</p>

<p>然后我们来看一下上节提到的发往本地数据包的处理函数</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
<span class='line-number'>16</span>
<span class='line-number'>17</span>
<span class='line-number'>18</span>
<span class='line-number'>19</span>
<span class='line-number'>20</span>
<span class='line-number'>21</span>
<span class='line-number'>22</span>
<span class='line-number'>23</span>
<span class='line-number'>24</span>
<span class='line-number'>25</span>
<span class='line-number'>26</span>
<span class='line-number'>27</span>
<span class='line-number'>28</span>
<span class='line-number'>29</span>
<span class='line-number'>30</span>
<span class='line-number'>31</span>
<span class='line-number'>32</span>
<span class='line-number'>33</span>
<span class='line-number'>34</span>
<span class='line-number'>35</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>static int br_pass_frame_up(struct sk_buff *skb)
</span><span class='line'>{
</span><span class='line'>&#9;struct net_device *indev, *brdev = BR_INPUT_SKB_CB(skb)-&gt;brdev;
</span><span class='line'>&#9;struct net_bridge *br = netdev_priv(brdev);
</span><span class='line'>&#9;struct net_bridge_vlan_group *vg;
</span><span class='line'>&#9;struct pcpu_sw_netstats *brstats = this_cpu_ptr(br-&gt;stats);
</span><span class='line'>&#9;/*统计该桥上的流量*/
</span><span class='line'>&#9;u64_stats_update_begin(&brstats-&gt;syncp);
</span><span class='line'>&#9;brstats-&gt;rx_packets++;
</span><span class='line'>&#9;brstats-&gt;rx_bytes += skb-&gt;len;
</span><span class='line'>&#9;u64_stats_update_end(&brstats-&gt;syncp);
</span><span class='line'>
</span><span class='line'>&#9;/*获取该桥上的vlan组*/
</span><span class='line'>&#9;vg = br_vlan_group_rcu(br);
</span><span class='line'>&#9;/* Bridge is just like any other port.  Make sure the
</span><span class='line'>&#9; * packet is allowed except in promisc modue when someone
</span><span class='line'>&#9; * may be running packet capture.
</span><span class='line'>&#9; */
</span><span class='line'>&#9;if (!(brdev-&gt;flags & IFF_PROMISC) &&
</span><span class='line'>&#9;&#9;!br_allowed_egress(vg, skb)) {
</span><span class='line'>&#9;&#9;kfree_skb(skb);
</span><span class='line'>&#9;&#9;return NET_RX_DROP;
</span><span class='line'>&#9;}
</span><span class='line'>&#9;/*替换掉数据包中的设备信息改为桥设备*/
</span><span class='line'>&#9;indev = skb-&gt;dev;
</span><span class='line'>&#9;skb-&gt;dev = brdev;
</span><span class='line'>&#9;/*配置数据包vlan的相关信息*/
</span><span class='line'>&#9;skb = br_handle_vlan(br, vg, skb);
</span><span class='line'>&#9;if (!skb)
</span><span class='line'>&#9;&#9;return NET_RX_DROP;
</span><span class='line'>&#9;/*进入NF_BR_LOCAL_IN*/
</span><span class='line'>&#9;return NF_HOOK(NFPROTO_BRIDGE, NF_BR_LOCAL_IN,
</span><span class='line'>&#9;&#9;&#9;   dev_net(indev), NULL, skb, indev, NULL,
</span><span class='line'>&#9;&#9;&#9;   br_netif_receive_skb);
</span><span class='line'>}</span></code></pre></td></tr></table></div></figure>


<p>这个函数所做的事情很简单，就是配置vlan的相关信息后，然后发往本地的netfilter钩子函数中
最后重新回到netif_recive_skb.如下函数：</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>static int
</span><span class='line'>br_netif_receive_skb(struct net *net, struct sock *sk, struct sk_buff *skb)
</span><span class='line'>{
</span><span class='line'>&#9;return netif_receive_skb(skb);
</span><span class='line'>}</span></code></pre></td></tr></table></div></figure>


<p>再来看看数据包转发的函数</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
<span class='line-number'>16</span>
<span class='line-number'>17</span>
<span class='line-number'>18</span>
<span class='line-number'>19</span>
<span class='line-number'>20</span>
<span class='line-number'>21</span>
<span class='line-number'>22</span>
<span class='line-number'>23</span>
<span class='line-number'>24</span>
<span class='line-number'>25</span>
<span class='line-number'>26</span>
<span class='line-number'>27</span>
<span class='line-number'>28</span>
<span class='line-number'>29</span>
<span class='line-number'>30</span>
<span class='line-number'>31</span>
<span class='line-number'>32</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>static void __br_forward(const struct net_bridge_port *to, struct sk_buff *skb)
</span><span class='line'>{
</span><span class='line'>&#9;struct net_bridge_vlan_group *vg;
</span><span class='line'>&#9;struct net_device *indev;
</span><span class='line'>
</span><span class='line'>&#9;if (skb_warn_if_lro(skb)) {
</span><span class='line'>&#9;&#9;kfree_skb(skb);
</span><span class='line'>&#9;&#9;return;
</span><span class='line'>&#9;}
</span><span class='line'>&#9;/*获取vlan组，这个组中有许多的vlanid，br_handle_vlan函数就是要在这个组中查找自己的vid*/
</span><span class='line'>&#9;vg = nbp_vlan_group_rcu(to);
</span><span class='line'>&#9;/*添加vlan的相关配置*/
</span><span class='line'>&#9;skb = br_handle_vlan(to-&gt;br, vg, skb);
</span><span class='line'>&#9;if (!skb)
</span><span class='line'>&#9;&#9;return;
</span><span class='line'>
</span><span class='line'>&#9;indev = skb-&gt;dev;
</span><span class='line'>&#9;skb-&gt;dev = to-&gt;dev;
</span><span class='line'>&#9;skb_forward_csum(skb);
</span><span class='line'>
</span><span class='line'>&#9;NF_HOOK(NFPROTO_BRIDGE, NF_BR_FORWARD,
</span><span class='line'>&#9;&#9;dev_net(indev), NULL, skb, indev, skb-&gt;dev,
</span><span class='line'>&#9;&#9;br_forward_finish);
</span><span class='line'>}
</span><span class='line'>
</span><span class='line'>int br_forward_finish(struct net *net, struct sock *sk, struct sk_buff *skb)
</span><span class='line'>{
</span><span class='line'>&#9;return NF_HOOK(NFPROTO_BRIDGE, NF_BR_POST_ROUTING,
</span><span class='line'>&#9;&#9;&#9;   net, sk, skb, NULL, skb-&gt;dev,
</span><span class='line'>&#9;&#9;&#9;   br_dev_queue_push_xmit);
</span><span class='line'>
</span><span class='line'>}</span></code></pre></td></tr></table></div></figure>


<p>整个数据包转发的过程与转发到本地的过程类似，只不过所进入的netfilter钩子点不同.</p>

<p>整个分析中不包含数据包从本地发出的数据包</p>
</div>


  <footer>
    <p class="meta">
      
  

<span class="byline author vcard">Posted by <span class="fn">kk</span></span>

      




<time class='entry-date' datetime='2020-11-09T17:52:00+08:00'><span class='date'>2020-11-09</span> <span class='time'>17:52:00</span></time>
      

<span class="categories">
  
    <a class='category' href='/blog/cats/kernel/'>kernel</a>, <a class='category' href='/blog/cats/kernel~net/'>net</a>
  
</span>


    </p>
    
      
    
    <p class="meta">
      
        <a class="basic-alignment left" href="/blog/2020/11/09/kernel-device/" title="Previous Post: Linux 上的抽象网络设备">&laquo; Linux 上的抽象网络设备</a>
      
      
        <a class="basic-alignment right" href="/blog/2020/11/11/mssql-centos/" title="Next Post: centos7.4 上使用 SQL Server 2019">centos7.4 上使用 SQL Server 2019 &raquo;</a>
      
    </p>
    <p class="meta">
	<div style='white-space: nowrap;'>
	<img src="/images/wx_ok.png" width=150px; height=150px; style="margin-left:100px;">
	<img src="/images/ali_ok.png" width=150px; height=150px; style="margin-left:100px;">
	</div>
    </p>


<!-- alert 替代 -->
<script type="text/javascript">
	cssCode = "<style type='text/css'>"
		+ ".nbaMask { position: fixed; z-index: 1000; top: 0; right: 0; left: 0; bottom: 0; background: rgba(0, 0, 0, 0.5); } "
		+ ".nbaMaskTransparent { position: fixed; z-index: 1000; top: 0; right: 0; left: 0; bottom: 0; } "
		+ ".nbaDialog { position: fixed; z-index: 5000; width: 80%; max-width: 500px; top: 50%; left: 50%; -webkit-transform: translate(-50%, -50%); transform: translate(-50%, -50%); background-color: #fff; text-align: center; border-radius: 8px; overflow: hidden; opacity: 1; color: white; }"
		+ ".nbaDialog .nbaDialogHd { padding: .2rem .27rem .08rem .27rem; text-align: left; padding-left: 10px; padding-top: 10px; } "
		+ ".nbaDialog .nbaDialogHd .nbaDialogTitle { color:black; font-size: 17px; font-weight: 400; } "
		+ ".nbaDialog .nbaDialogBd { padding: 0 .27rem; font-size: 15px; line-height: 1.3; word-wrap: break-word; word-break: break-all; color: #000000; } "
		+ ".nbaDialog .nbaDialogFt { background: #1a6ada; float: right; margin-right:10px; margin-bottom:10px; position: relative; border-radius: 5px; width:60px;  line-height: 30px; font-size: 15px; display: -webkit-box; display: -webkit-flex; display: flex; } "
		+ ".nbaDialog .nbaDialogFt:after { content: ' '; position: absolute; left: 0; top: 0; right: 0; height: 1px; border-top: 1px solid #e6e6e6; color: #e6e6e6; -webkit-transform-origin: 0 0; transform-origin: 0 0; -webkit-transform: scaleY(0.5); transform: scaleY(0.5); } "
		+ ".nbaDialog .nbaDialogBtn { display: block; -webkit-box-flex: 1; -webkit-flex: 1; flex: 1; color: white; text-decoration: none; -webkit-tap-highlight-color: transparent; position: relative; margin-bottom: 0; } "
		+ ".nbaDialog .nbaDialogBtn:after { content: ' '; position: absolute; left: 0; top: 0; width: 1px; bottom: 0; border-left: 1px solid #e6e6e6; color: #e6e6e6; -webkit-transform-origin: 0 0; transform-origin: 0 0; -webkit-transform: scaleX(0.5); transform: scaleX(0.5); } "
		+ ".nbaDialog a { text-decoration: none; -webkit-tap-highlight-color: transparent; }"
		+ "</style>";

googleads = '<script async src="https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js?client=ca-pub-8245190595992760"     crossorigin="anonymous"><\/script>'
+ '<ins class="adsbygoogle"'
+ '     style="display:block"'
+ '     data-ad-client="ca-pub-8245190595992760"'
+ '     data-ad-slot="3924542061"'
+ '     data-ad-format="auto"'
+ '     data-full-width-responsive="true"></ins>'
+ '<script>     (adsbygoogle = window.adsbygoogle || []).push({});<\/script>';


	htmlCode = "<div id='dialogs2' style='display: none'>"
		+ "  <div class='nbaMask'></div>"
		+ "  <div class='nbaDialog'>"
		+ "    <div class='nbaDialogHd'>"
		+ "        <strong class='nbaDialogTitle'>提示：</strong>"
		+ "    </div><br>"
		+ ' <div style="white-space: nowrap;"> <img src="/images/wx_ok.png" width="130px;" height="130px;"> <img src="/images/ali_ok.png" width="130px;" height="130px;" style="margin-left:100px;"> </div> '
		+ "    <div class='nbaDialogBd' id='dialog_msg2' style='white-space:normal;'>弹窗内容，告知当前状态、信息和解决方法，描述文字尽量控制在三行内</div>"
		+ "    <div class='nbaDialogHd'>"
		+ "        <strong class='nbaDialogTitle'></strong>"
		+ "    </div><br>"
		+ "    <div class='nbaDialogFt'>"
		+ "        <a href='javascript:;' class='nbaDialogBtn nbaDialogBtnPrimary' style='display:none;' id='dialog_ok2'>确定</a>"
		+ "    </div>"
		+ "  </div>"
		+ googleads
		+ "</div>";

	htmlCode2 = "<div id='dialogs22' style='display: none;'>"
		+ "  <div class='nbaDialog' id='dialogs22_s' style='background:gray; top:50%; border-radius: 18px;'>"
		+ "    <div class='nbaDialogBd' id='dialog_msg22' style='white-space:normal; color:white;padding-top:10px;'>弹窗内容，告知当前状态、信息和解决方法，描述文字尽量控制在三行内</div>"
		+ "    <div class='nbaDialogHd'>"
		+ "        <strong class='nbaDialogTitle'></strong>"
		+ "    </div>"
		+ "  </div>"
		+ "</div>";

function showd()
{
	document.getElementById("dialog_ok2").style.display = '';
}

function alert_money(msg) {
	var div = document.createElement("div");
	div.innerHTML = cssCode + htmlCode;
	document.body.appendChild(div);

	var dialogs2 = document.getElementById("dialogs2");
	dialogs2.style.display = 'block';

	var dialog_msg2 = document.getElementById("dialog_msg2");
	dialog_msg2.innerHTML = msg;

	// var dialog_cancel = document.getElementById("dialog_cancel");
	//	dialog_cancel.onclick = function() {
	//	dialogs2.style.display = 'none';
	// };
	var dialog_ok2 = document.getElementById("dialog_ok2");
	dialog_ok2.onclick = function() {
		dialogs2.style.display = 'none';
		//callback();
	};

	setTimeout("showd()", 10*1000);
};

alert_money('');

</script>


  </footer>
</article>

</div>
<aside class="sidebar" id='load_sidebar'>
</aside>
<script type="text/javascript">
  $('#load_sidebar').load('/sidebar.html');
</script>

    </div>
  </div>
  <footer role="contentinfo">  Copyright &copy; 2024 - kk -
  <span class="credit">Powered by <a href="http://octopress.org">Octopress</a></span>
  <a title="Top" href="#" id="scroll2top" style="position: fixed; height: 50px; bottom: 30px; right: 25px; cursor: pointer; z-index: 9999; display: block; opacity: 1;"><img src="/images/scrollup.png"></a>
  <script src="/javascripts/scroll2top.js"></script>

<!-- Matomo -->
<script>
  var _paq = window._paq = window._paq || [];
  /* tracker methods like "setCustomDimension" should be called before "trackPageView" */
  _paq.push(['trackPageView']);
  _paq.push(['enableLinkTracking']);
  (function() {
    var u="//www.abcxyzkk.xyz/matomo/";
    _paq.push(['setTrackerUrl', u+'matomo.php']);
    _paq.push(['setSiteId', '1']);
    var d=document, g=d.createElement('script'), s=d.getElementsByTagName('script')[0];
    g.async=true; g.src=u+'matomo.js'; s.parentNode.insertBefore(g,s);
  })();
</script>
<!-- End Matomo Code -->


<!-- Histats.com  (div with counter) --><div id="histats_counter"></div>
<!-- Histats.com  START  (aync)-->
<!--
<script type="text/javascript">var _Hasync= _Hasync|| [];
_Hasync.push(['Histats.start', '1,4673876,4,107,170,20,00010000']);
_Hasync.push(['Histats.fasi', '1']);
_Hasync.push(['Histats.track_hits', '']);
(function() {
var hs = document.createElement('script'); hs.type = 'text/javascript'; hs.async = true;
hs.src = ('//s10.histats.com/js15_as.js');
(document.getElementsByTagName('head')[0] || document.getElementsByTagName('body')[0]).appendChild(hs);
})();</script>
<noscript><a href="/" target="_blank"><img  src="//sstatic1.histats.com/0.gif?4673876&101" alt="simple hit counter" border="0"></a></noscript>
-->
<!-- Histats.com  END  -->

<!--  <script type="text/javascript">var cnzz_protocol = (("https:" == document.location.protocol) ? " https://" : " http://");document.write(unescape("%3Cspan id='cnzz_stat_icon_1253604690'%3E%3C/span%3E%3Cscript src='" + cnzz_protocol + "s95.cnzz.com/z_stat.php%3Fid%3D1253604690' type='text/javascript'%3E%3C/script%3E"));</script>
-->


<!--
<script>

// TODO 无法获取框架内元素
function autoads()
{
try {
	console.log('start');
	var txt = document.getElementById('mys-content').innerHTML;
	var len = txt.length;
	var url = '';
	console.log(len);
	for (var i = 0; i < len - 10; i ++) {
		if (txt.substring(i, i + 6) == 'href="') {
			i = i + 6;
			url = '';
			for ( ; i < len; i ++) {
				if (txt[i] == '"')
					break;
				url += txt[i];
			}
			url = url.replace(/&amp;/g, '&');
		//	console.log(url);
		}
	}
	console.log(url);
	if (url != '' && Math.random() < 0.3)
		window.open(url, "_blank");
} catch (e) {
}
}

window.onload = function() {
	setTimeout("autoads()", 5*1000);
}
</script>
-->


</footer>
  





</body>
</html>
