
<!DOCTYPE html>
<!--[if IEMobile 7 ]><html class="no-js iem7"><![endif]-->
<!--[if lt IE 9]><html class="no-js lte-ie8"><![endif]-->
<!--[if (gt IE 8)|(gt IEMobile 7)|!(IEMobile)|!(IE)]><!--><html class="no-js" lang="en"><!--<![endif]-->
<head>
  <meta charset="utf-8">
  <title>IPSEC介绍与实现 - kk Blog —— 通用基础</title>

  <link href="/favicon.png" rel="icon">
  <link href="/stylesheets/screen.css" media="screen, projection" rel="stylesheet" type="text/css">
  <link href="/atom.xml" rel="alternate" title="kk Blog —— 通用基础" type="application/atom+xml">
  <script src="/javascripts/modernizr-2.0.js"></script>
  <script src="/javascripts/libs/jquery.min.js"></script>
<!--  <script>!window.jQuery && document.write(unescape('%3Cscript src="/javascripts/libs/jquery.min.js"%3E%3C/script%3E'))</script> -->
  <script src="/javascripts/octopress.js" type="text/javascript"></script>
  <script src="/javascripts/category.js" type="text/javascript"></script>

<script async src="https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js?client=ca-pub-8245190595992760"
     crossorigin="anonymous"></script>

</head>

<body   >
  <header role="banner"><hgroup>
  <h1><a href="/">kk Blog —— 通用基础</a></h1>
  
    <h2><br>date [-d @int|str] [+%s|"+%F %T"]<br>netstat -ltunp<br>sar -n DEV 1</h2>
  
  <div class="hwx" style='text-align: left; position: absolute; margin-top: -130px; white-space: nowrap;'>
	  <img src="/images/wx_ok.png" width=130px; height=130px;>
	  <img src="/images/ali_ok.png" width=130px; height=130px; style="margin-left:30px;">
  </div>
</hgroup>

</header>
  <nav role="navigation" style='white-space: nowrap; min-width=1120px; position: sticky; top: 0; z-index: 999;'><form action="/search" method="get">
    <input class="search" name="query" id="query" type="text" placeholder="search..." style="height:1.5em;">
    <input id="btnSubmit" value="search" type="submit">
</form>
<script type="text/javascript">

function StringToAscii(str) {
	return str.charCodeAt(0).toString(16);
}

function AsciiToString(asccode) {
	return String.fromCharCode(asccode);
}

function UrlDecode(zipStr) {
	var uzipStr = '';
	for (var i = 0; i < zipStr.length; i += 1) {
		var chr = zipStr.charAt(i);
		if (chr === '+') {
			uzipStr += ' ';
		} else if (chr === '%') {
			var asc = zipStr.substring(i + 1, i + 3);
			if (parseInt('0x' + asc) > 0x7f) {
				uzipStr += decodeURI('%' + asc.toString() + zipStr.substring(i+3, i+9).toString());
				i += 8;
			} else {
				uzipStr += AsciiToString(parseInt('0x' + asc));
				i += 2;
			}
		} else {
			uzipStr += chr;
		}
	}
	return uzipStr;
}

/*
var query = GetRequest("query");
if (query != null) {
	document.getElementById("query").value = UrlDecode(query);
}
*/

var query = window.location.search.substring(1);
var vars = query.split("&");
for (var i = 0; i < vars.length; i ++) {
	var pair = vars[i].split("=");
	if (pair[0] == 'query') {
		document.getElementById('query').value = UrlDecode(pair[1]);
		break;
	}
}

</script>

<!-- Start of Site Search 360 Scripts -->
<!-- Search 360 达到次数后要收费，换成静态索引
<script type="text/javascript">
var ss360Config = {
    siteId: "abcdxyzk.github.io",
    searchBox: {
        selector: "input#query",
        searchButton: "input#query+input[type='submit']"
    }
}
</script>
<script src="https://cdn.sitesearch360.com/v13/sitesearch360-v13.min.js" async></script>
-->
<!-- End of Site Search 360 Scripts -->

<ul class="subscription" data-subscription="rss">
<li>
</li>
  <li><a href="/atom.xml" rel="subscribe-rss">RSS</a></li>
  
</ul>
  
  
<ul class="main-navigation">
  <li><a href="/">Blog</a></li>
  <li><a href="/blog/archives">Archives</a></li>
  <li><a href="/download">Download</a></li>
  <li><a href="/search">Search</a></li>
  <li><a href="/about">About</a></li>
</ul>

</nav>
  <div id="main">
    <div id="content">
      <div>
<article class="hentry" role="article">
  
  <header>
    
      <h2 class="entry-title">IPSEC介绍与实现</h2>
    
    
      <p class="meta">
        




<time class='entry-date' datetime='2021-06-15T21:23:00+08:00'><span class='date'>2021-06-15</span> <span class='time'>21:23:00</span></time>
        
      </p>
    
  </header>


<div class="entry-content"><p><a href="http://www.360doc.com/content/14/0210/13/706976_351324389.shtml">http://www.360doc.com/content/14/0210/13/706976_351324389.shtml</a></p>

<h2>一、介绍</h2>

<p>IPSec 协议不是一个单独的协议，它给出了应用于IP层上网络数据安全的一整套体系结构，包括网络认证协议 Authentication Header（AH）、封装安全载荷协议Encapsulating Security Payload（ESP）、密钥管理协议Internet Key Exchange （IKE）和用于网络认证及加密的一些算法等。IPSec 规定了如何在对等层之间选择安全协议、确定安全算法和密钥交换，向上提供了访问控制、数据源认证、数据加密等网络安全服务。</p>

<h3>1、安全特性</h3>

<h4>IPSec的安全特性主要有：</h4>

<p>·不可否认性 &ldquo;不可否认性"可以证实消息发送方是唯一可能的发送者，发送者不能否认发送过消息。"不可否认性"是采用公钥技术的一个特征，当使用公钥技术时，发送方用 私钥产生一个数字签名随消息一起发送，接收方用发送者的公钥来验证数字签名。由于在理论上只有发送者才唯一拥有私钥，也只有发送者才可能产生该数字签名， 所以只要数字签名通过验证，发送者就不能否认曾发送过该消息。但"不可否认性"不是基于认证的共享密钥技术的特征，因为在基于认证的共享密钥技术中，发送 方和接收方掌握相同的密钥。</p>

<p>·反重播性 &ldquo;反重播"确保每个IP包的唯一性，保证信息万一被截取复制后，不能再被重新利用、重新传输回目的地址。该特性可以防止攻击者截取破译信息后，再用相同的信息包冒取非法访问权（即使这种冒取行为发生在数月之后）。</p>

<p>·数据完整性 防止传输过程中数据被篡改，确保发出数据和接收数据的一致性。IPSec利用Hash函数为每个数据包产生一个加密检查和，接收方在打开包前先计算检查和，若包遭篡改导致检查和不相符，数据包即被丢弃。</p>

<p>·数据可靠性（加密） 在传输前，对数据进行加密，可以保证在传输过程中，即使数据包遭截取，信息也无法被读。该特性在IPSec中为可选项，与IPSec策略的具体设置相关。</p>

<p>·认证 数据源发送信任状，由接收方验证信任状的合法性，只有通过认证的系统才可以建立通信连接。</p>

<h3>2、基于电子证书的公钥认证</h3>

<p>一个架构良好的公钥体系，在信任状的传递中不造成任何信息外泄，能解决很多安全问题。 IPSec与特定的公钥体系相结合，可以提供基于电子证书的认证。公钥证书认证在Windows 2000中，适用于对非Windows 2000主机、独立主机，非信任域成员的客户机、或者不运行Kerberos v5认证协议的主机进行身份认证。</p>

<h3>3、预置共享密钥认证</h3>

<p>IPSec也可以使用预置共享密钥进行认证。预共享意味着通信双方必须在IPSec策略设置中 就共享的密钥达成一致。之后在安全协商过程中，信息在传输前使用共享密钥加密，接收端使用同样的密钥解密，如果接收方能够解密，即被认为可以通过认证。但 在Windows 2000 IPSec策略中，这种认证方式被认为不够安全而一般不推荐使用。</p>

<h3>4、公钥加密</h3>

<p>IPSec的公钥加密用于身份认证和密钥交换。公钥加密，也被称为"不对称加密法"，即加解密过程需要两把不同的密钥，一把用来产生数字签名和加密数据，另一把用来验证数字签名和对数据进行解密。</p>

<p>使用公钥加密法，每个用户拥有一个密钥对，其中私钥仅为其个人所知，公钥则可分发给任意需要与 之进行加密通信的人。例如：A想要发送加密信息给B，则A需要用B的公钥加密信息，之后只有B才能用他的私钥对该加密信息进行解密。虽然密钥对中两把钥匙 彼此相关，但要想从其中一把来推导出另一把，以目前计算机的运算能力来看，这种做法几乎完全不现实。因此，在这种加密法中，公钥可以广为分发，而私钥则需 要仔细地妥善保管。</p>

<h3>5、Hash函数和数据完整性</h3>

<p>Hash信息验证码HMAC（Hash message authentication codes）验证接收消息和发送消息的完全一致性（完整性）。这在数据交换中非常关键，尤其当传输媒介如公共网络中不提供安全保证时更显其重要性。</p>

<p>HMAC结合hash算法和共享密钥提供完整性。Hash散列通常也被当成是数字签名，但这种说法不够准确，两者的区别在于：Hash散列使用共享密钥，而数字签名基于公钥技术。hash算法也称为消息摘要或单向转换。称它为单向转换是因为：</p>

<p>1）双方必须在通信的两个端头处各自执行Hash函数计算；</p>

<p>2）使用Hash函数很容易从消息计算出消息摘要，但其逆向反演过程以目前计算机的运算能力几乎不可实现。</p>

<p>Hash散列本身就是所谓加密检查和或消息完整性编码MIC（Message Integrity Code），通信双方必须各自执行函数计算来验证消息。举例来说，发送方首先使用HMAC算法和共享密钥计算消息检查和，然后将计算结果A封装进数据包中 一起发送；接收方再对所接收的消息执行HMAC计算得出结果B，并将B与A进行比较。如果消息在传输中遭篡改致使B与A不一致，接收方丢弃该数据包。</p>

<h4>有两种最常用的hash函数：</h4>

<p>·HMAC-MD5 MD5（消息摘要5）基于RFC1321。MD5对MD4做了改进，计算速度比MD4稍慢，但安全性能得到了进一步改善。MD5在计算中使用了64个32位常数，最终生成一个128位的完整性检查和。</p>

<p>·HMAC-SHA 安全Hash算法定义在NIST FIPS 180-1，其算法以MD5为原型。 SHA在计算中使用了79个32位常数，最终产生一个160位完整性检查和。SHA检查和长度比MD5更长，因此安全性也更高。</p>

<h3>6、加密和数据可靠性</h3>

<p>IPSec使用的数据加密算法是DES&ndash;Data Encryption Standard（数据加密标准）。DES密钥长度为56位，在形式上是一个64位数。DES以64位（8字节）为分组对数据加密，每64位明文，经过 16轮置换生成64位密文，其中每字节有1位用于奇偶校验，所以实际有效密钥长度是56位。 IPSec还支持3DES算法，3DES可提供更高的安全性，但相应地，计算速度更慢。</p>

<h3>7、密钥管理</h3>

<h4>·动态密钥更新</h4>

<p>IPSec策略使用"动态密钥更新"法来决定在一次通信中，新密钥产生的频率。动态密钥指在通 信过程中，数据流被划分成一个个"数据块"，每一个"数据块"都使用不同的密钥加密，这可以保证万一攻击者中途截取了部分通信数据流和相应的密钥后，也不 会危及到所有其余的通信信息的安全。动态密钥更新服务由Internet密钥交换IKE（Internet Key Exchange）提供，详见IKE介绍部分。</p>

<p>IPSec策略允许专家级用户自定义密钥生命周期。如果该值没有设置，则按缺省时间间隔自动生成新密钥。</p>

<h4>·密钥长度</h4>

<p>密钥长度每增加一位，可能的密钥数就会增加一倍，相应地，破解密钥的难度也会随之成指数级加大。IPSec策略提供多种加密算法，可生成多种长度不等的密钥，用户可根据不同的安全需求加以选择。</p>

<h4>·Diffie-Hellman算法</h4>

<p>要启动安全通讯，通信两端必须首先得到相同的共享密钥（主密钥），但共享密钥不能通过网络相互发送，因为这种做法极易泄密。</p>

<p>Diffie-Hellman算法是用于密钥交换的最早最安全的算法之一。DH算法的基本工作 原理是：通信双方公开或半公开交换一些准备用来生成密钥的"材料数据"，在彼此交换过密钥生成"材料"后，两端可以各自生成出完全一样的共享密钥。在任何 时候，双方都绝不交换真正的密钥。</p>

<p>通信双方交换的密钥生成"材料"，长度不等，"材料"长度越长，所生成的密钥强度也就越高，密钥破译就越困难。 除进行密钥交换外，IPSec还使用DH算法生成所有其他加密密钥。</p>

<h2>二、IPSEC使用</h2>

<h3>1. 编译kernel 2.6</h3>

<p>必须选择下面的选择</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>CONFIG_INET_AH
</span><span class='line'>CONFIG_INET_ESP
</span><span class='line'>CONFIG_XFRM_USER</span></code></pre></td></tr></table></div></figure>


<p>可能还要安装 module－init－tool</p>

<p>如何生成kernel看另外的文档</p>

<h3>2. ipsec－tools</h3>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>./configure --prefix=/
</span><span class='line'> make
</span><span class='line'>make install</span></code></pre></td></tr></table></div></figure>


<h3>3. 两台机器的通讯</h3>

<p> linux(192.168.0.254) host-A&mdash;&mdash;&mdash;&mdash;&ndash;linux box(192.168.0.141)host-B</p>

<h4>在一台linux中</h4>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>#加入pf_sock
</span><span class='line'>modprobe af_key
</span><span class='line'>
</span><span class='line'>#加密
</span><span class='line'>modprobe md5
</span><span class='line'>modprobe des
</span><span class='line'>
</span><span class='line'>#AH
</span><span class='line'>modprobe ah4
</span><span class='line'>
</span><span class='line'>#esp
</span><span class='line'>modprobe esp4</span></code></pre></td></tr></table></div></figure>




<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
<span class='line-number'>16</span>
<span class='line-number'>17</span>
<span class='line-number'>18</span>
<span class='line-number'>19</span>
<span class='line-number'>20</span>
<span class='line-number'>21</span>
<span class='line-number'>22</span>
<span class='line-number'>23</span>
<span class='line-number'>24</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>cat &gt;setkey.sh &lt;&lt;EOF
</span><span class='line'>
</span><span class='line'>#!/sbin/setkey -f
</span><span class='line'>
</span><span class='line'>flush;
</span><span class='line'>
</span><span class='line'>spdflush;
</span><span class='line'>
</span><span class='line'># AH
</span><span class='line'>add 192.168.0.141 192.168.0.254 ah 15700 -A hmac-md5 "1234567890123456";
</span><span class='line'>add 192.168.0.254 192.168.0.141 ah 24500 -A hmac-md5 "1234567890123456";
</span><span class='line'>
</span><span class='line'># ESP
</span><span class='line'>add 192.168.0.141 192.168.0.254 esp 15701 -E 3des-cbc "123456789012123456789012";
</span><span class='line'>add 192.168.0.254 192.168.0.141 esp 24501 -E 3des-cbc "123456789012123456789012";
</span><span class='line'>
</span><span class='line'>spdadd 192.168.0.141 192.168.0.254 any -P out ipsec
</span><span class='line'>           esp/transport//require
</span><span class='line'>           ah/transport//require;
</span><span class='line'>
</span><span class='line'>spdadd 192.168.0.254 192.168.0.141 any -P in ipsec
</span><span class='line'>           esp/transport//require
</span><span class='line'>           ah/transport//require;
</span><span class='line'>EOF </span></code></pre></td></tr></table></div></figure>


<p>执行setkey后，就可以通讯了</p>

<h4>速度测试：</h4>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>       没有ipsec      有ipsec
</span><span class='line'>A-&gt;B   10.21M/s       2.43M/s
</span><span class='line'>B-&gt;A   10.94M/s       2.27M/s</span></code></pre></td></tr></table></div></figure>


<p>上面的用的是手工密钥，可以还可以用Preshared Keys，X.509 Certificates。</p>

<p>其中/usr/share/ssl/misc/CA可以用来生成X.509 Certificates</p>

<p>生成证书：</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
<span class='line-number'>16</span>
<span class='line-number'>17</span>
<span class='line-number'>18</span>
<span class='line-number'>19</span>
<span class='line-number'>20</span>
<span class='line-number'>21</span>
<span class='line-number'>22</span>
<span class='line-number'>23</span>
<span class='line-number'>24</span>
<span class='line-number'>25</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>mkdir certs
</span><span class='line'>cd certs
</span><span class='line'>/usr/share/ssl/misc/CA -newca
</span><span class='line'># 254 passwd :ca254
</span><span class='line'># 141 passwd :ca141
</span><span class='line'>
</span><span class='line'>/usr/share/ssl/misc/CA -newreq
</span><span class='line'># 254 passwd :cert254
</span><span class='line'># 141 passwd :cert141
</span><span class='line'>
</span><span class='line'>#sign it using the certificate authority??
</span><span class='line'>
</span><span class='line'>/usr/share/ssl/misc/CA -sign
</span><span class='line'>mv newcert.pem vpngateway_cert.pem
</span><span class='line'>mv newreq.pem vpngateway_key.pem
</span><span class='line'>
</span><span class='line'>mkdir /etc/certs
</span><span class='line'>cp ~/certs/*.pem /etc/certs/
</span><span class='line'>
</span><span class='line'>#因为racoon不认这个key的格式，转一下
</span><span class='line'>cd /etc/
</span><span class='line'>
</span><span class='line'>openssl rsa -in 254_key.pem -out 254_key.pem
</span><span class='line'>
</span><span class='line'>#input cert254</span></code></pre></td></tr></table></div></figure>


<h3>4.网关之间的通讯</h3>

<p> C(192.168.0.119)&mdash;(192.168.0.114)linux(10.0.0.12)&mdash;(10.0.0.13)linux(192.168.0.115)&mdash;-C(192.168.0.253)</p>

<p> 和上面差不多</p>

<h2>IPSEC实现</h2>

<h3>Linux2.6内核中自带了IPSEC的实现</h3>

<h4>该实现包括以下几个部分:</h4>

<p>PF_KEY类型套接口, 用来提供和用户层空间进行PF_KEY通信，代码在net/key目录下.</p>

<p>安全联盟SA和安全策略SP管理，是使用xfrm库来实现的，代码在net/xfrm/目录下定义.</p>

<p>ESP，AH等协议实现，在net/ipv4(6)下定义.</p>

<p>加密认证算法库，在crypto目录下定义，这些算法都是标准代码了.</p>

<h4>本文主要描述XFRM库的实现以及在IPV4下相关协议的处理部分, IPV6的忽略.</h4>

<p>xfrm是内核中变化比较大的部分,每个版本中都有不小的差异, 同时也说明了该模块的不成熟性。</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
<span class='line-number'>16</span>
<span class='line-number'>17</span>
<span class='line-number'>18</span>
<span class='line-number'>19</span>
<span class='line-number'>20</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>在net/xfrm目录下的各文件大致功能说明如下:
</span><span class='line'>xfrm_state.c: xfrm状态管理
</span><span class='line'>xfrm_policy.c: xfrm策略管理
</span><span class='line'>xfrm_algo.c: 算法管理
</span><span class='line'>xfrm_hash.c: HASH计算函数
</span><span class='line'>xfrm_input.c: 安全路径(sec_path)处理,用于进入的ipsec包
</span><span class='line'>xfrm_user.c:  netlink接口的SA和SP管理
</span><span class='line'>
</span><span class='line'>在net/ipv4目录下的和ipsec相关各文件大致功能说明如下:
</span><span class='line'>ah4.c: IPV4的AH协议处理
</span><span class='line'>esp4.c: IPV4的ESP协议处理
</span><span class='line'>ipcomp.c: IP压缩协议处理
</span><span class='line'>xfrm4_input: 接收的IPV4的IPSEC包处理
</span><span class='line'>xfrm4_output: 发出的IPV4的IPSEC包处理
</span><span class='line'>xfrm4_state: IPV4的SA处理
</span><span class='line'>xfrm4_policy: IPV4的策略处理
</span><span class='line'>xfrm4_tunnel: IPV4的通道处理
</span><span class='line'>xfrm4_mode_transport: 传输模式
</span><span class='line'>xfrm4_mode_tunnel: 通道模式
</span><span class='line'>xfrm4_mode_beet: BEET模式</span></code></pre></td></tr></table></div></figure>


<h4>本文Linux内核代码版本为2.6.24</h4>

<p>[数据结构]</p>

<p>内核SA的定义用xfrm_state结构定义，SP用xfrm_policy结构定义，在include/net/xfrm.h中定义.</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
<span class='line-number'>16</span>
<span class='line-number'>17</span>
<span class='line-number'>18</span>
<span class='line-number'>19</span>
<span class='line-number'>20</span>
<span class='line-number'>21</span>
<span class='line-number'>22</span>
<span class='line-number'>23</span>
<span class='line-number'>24</span>
<span class='line-number'>25</span>
<span class='line-number'>26</span>
<span class='line-number'>27</span>
<span class='line-number'>28</span>
<span class='line-number'>29</span>
<span class='line-number'>30</span>
<span class='line-number'>31</span>
<span class='line-number'>32</span>
<span class='line-number'>33</span>
<span class='line-number'>34</span>
<span class='line-number'>35</span>
<span class='line-number'>36</span>
<span class='line-number'>37</span>
<span class='line-number'>38</span>
<span class='line-number'>39</span>
<span class='line-number'>40</span>
<span class='line-number'>41</span>
<span class='line-number'>42</span>
<span class='line-number'>43</span>
<span class='line-number'>44</span>
<span class='line-number'>45</span>
<span class='line-number'>46</span>
<span class='line-number'>47</span>
<span class='line-number'>48</span>
<span class='line-number'>49</span>
<span class='line-number'>50</span>
<span class='line-number'>51</span>
<span class='line-number'>52</span>
<span class='line-number'>53</span>
<span class='line-number'>54</span>
<span class='line-number'>55</span>
<span class='line-number'>56</span>
<span class='line-number'>57</span>
<span class='line-number'>58</span>
<span class='line-number'>59</span>
<span class='line-number'>60</span>
<span class='line-number'>61</span>
<span class='line-number'>62</span>
<span class='line-number'>63</span>
<span class='line-number'>64</span>
<span class='line-number'>65</span>
<span class='line-number'>66</span>
<span class='line-number'>67</span>
<span class='line-number'>68</span>
<span class='line-number'>69</span>
<span class='line-number'>70</span>
<span class='line-number'>71</span>
<span class='line-number'>72</span>
<span class='line-number'>73</span>
<span class='line-number'>74</span>
<span class='line-number'>75</span>
<span class='line-number'>76</span>
<span class='line-number'>77</span>
<span class='line-number'>78</span>
<span class='line-number'>79</span>
<span class='line-number'>80</span>
<span class='line-number'>81</span>
<span class='line-number'>82</span>
<span class='line-number'>83</span>
<span class='line-number'>84</span>
<span class='line-number'>85</span>
<span class='line-number'>86</span>
<span class='line-number'>87</span>
<span class='line-number'>88</span>
<span class='line-number'>89</span>
<span class='line-number'>90</span>
<span class='line-number'>91</span>
<span class='line-number'>92</span>
<span class='line-number'>93</span>
<span class='line-number'>94</span>
<span class='line-number'>95</span>
<span class='line-number'>96</span>
<span class='line-number'>97</span>
<span class='line-number'>98</span>
<span class='line-number'>99</span>
<span class='line-number'>100</span>
<span class='line-number'>101</span>
<span class='line-number'>102</span>
<span class='line-number'>103</span>
<span class='line-number'>104</span>
<span class='line-number'>105</span>
<span class='line-number'>106</span>
<span class='line-number'>107</span>
<span class='line-number'>108</span>
<span class='line-number'>109</span>
<span class='line-number'>110</span>
<span class='line-number'>111</span>
<span class='line-number'>112</span>
<span class='line-number'>113</span>
<span class='line-number'>114</span>
<span class='line-number'>115</span>
<span class='line-number'>116</span>
<span class='line-number'>117</span>
<span class='line-number'>118</span>
<span class='line-number'>119</span>
<span class='line-number'>120</span>
<span class='line-number'>121</span>
<span class='line-number'>122</span>
<span class='line-number'>123</span>
<span class='line-number'>124</span>
<span class='line-number'>125</span>
<span class='line-number'>126</span>
<span class='line-number'>127</span>
<span class='line-number'>128</span>
<span class='line-number'>129</span>
<span class='line-number'>130</span>
<span class='line-number'>131</span>
<span class='line-number'>132</span>
<span class='line-number'>133</span>
<span class='line-number'>134</span>
<span class='line-number'>135</span>
<span class='line-number'>136</span>
<span class='line-number'>137</span>
<span class='line-number'>138</span>
<span class='line-number'>139</span>
<span class='line-number'>140</span>
<span class='line-number'>141</span>
<span class='line-number'>142</span>
<span class='line-number'>143</span>
<span class='line-number'>144</span>
<span class='line-number'>145</span>
<span class='line-number'>146</span>
<span class='line-number'>147</span>
<span class='line-number'>148</span>
<span class='line-number'>149</span>
<span class='line-number'>150</span>
<span class='line-number'>151</span>
<span class='line-number'>152</span>
<span class='line-number'>153</span>
<span class='line-number'>154</span>
<span class='line-number'>155</span>
<span class='line-number'>156</span>
<span class='line-number'>157</span>
<span class='line-number'>158</span>
<span class='line-number'>159</span>
<span class='line-number'>160</span>
<span class='line-number'>161</span>
<span class='line-number'>162</span>
<span class='line-number'>163</span>
<span class='line-number'>164</span>
<span class='line-number'>165</span>
<span class='line-number'>166</span>
<span class='line-number'>167</span>
<span class='line-number'>168</span>
<span class='line-number'>169</span>
<span class='line-number'>170</span>
<span class='line-number'>171</span>
<span class='line-number'>172</span>
<span class='line-number'>173</span>
<span class='line-number'>174</span>
<span class='line-number'>175</span>
<span class='line-number'>176</span>
<span class='line-number'>177</span>
<span class='line-number'>178</span>
<span class='line-number'>179</span>
<span class='line-number'>180</span>
<span class='line-number'>181</span>
<span class='line-number'>182</span>
<span class='line-number'>183</span>
<span class='line-number'>184</span>
<span class='line-number'>185</span>
<span class='line-number'>186</span>
<span class='line-number'>187</span>
<span class='line-number'>188</span>
<span class='line-number'>189</span>
<span class='line-number'>190</span>
<span class='line-number'>191</span>
<span class='line-number'>192</span>
<span class='line-number'>193</span>
<span class='line-number'>194</span>
<span class='line-number'>195</span>
<span class='line-number'>196</span>
<span class='line-number'>197</span>
<span class='line-number'>198</span>
<span class='line-number'>199</span>
<span class='line-number'>200</span>
<span class='line-number'>201</span>
<span class='line-number'>202</span>
<span class='line-number'>203</span>
<span class='line-number'>204</span>
<span class='line-number'>205</span>
<span class='line-number'>206</span>
<span class='line-number'>207</span>
<span class='line-number'>208</span>
<span class='line-number'>209</span>
<span class='line-number'>210</span>
<span class='line-number'>211</span>
<span class='line-number'>212</span>
<span class='line-number'>213</span>
<span class='line-number'>214</span>
<span class='line-number'>215</span>
<span class='line-number'>216</span>
<span class='line-number'>217</span>
<span class='line-number'>218</span>
<span class='line-number'>219</span>
<span class='line-number'>220</span>
<span class='line-number'>221</span>
<span class='line-number'>222</span>
<span class='line-number'>223</span>
<span class='line-number'>224</span>
<span class='line-number'>225</span>
<span class='line-number'>226</span>
<span class='line-number'>227</span>
<span class='line-number'>228</span>
<span class='line-number'>229</span>
<span class='line-number'>230</span>
<span class='line-number'>231</span>
<span class='line-number'>232</span>
<span class='line-number'>233</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>struct xfrm_state
</span><span class='line'>{
</span><span class='line'>&#9;struct hlist_node       bydst; // 按目的地址HASH
</span><span class='line'>&#9;struct hlist_node       bysrc; // 按源地址HASH
</span><span class='line'>&#9;struct hlist_node       byspi; // 按SPI值HASH
</span><span class='line'>
</span><span class='line'>&#9;atomic_t               refcnt;// 所有使用计数
</span><span class='line'>&#9;spinlock_t              lock;  // 状态锁
</span><span class='line'>
</span><span class='line'>&#9;struct xfrm_id          id;    // ID结构， 即目的地址，SPI，协议三元组
</span><span class='line'>&#9;struct xfrm_selector   sel;   // 状态选择器
</span><span class='line'>
</span><span class='line'>&#9;u32                  genid;  // 状态的标志值, 防止发生碰撞
</span><span class='line'>&#9;struct { // KEY回调管理处理结构参数
</span><span class='line'>&#9;&#9;u8              state;
</span><span class='line'>&#9;&#9;u8              dying;
</span><span class='line'>&#9;&#9;u32             seq;
</span><span class='line'>&#9;} km;
</span><span class='line'>&#9;/* Parameters of this state. */
</span><span class='line'>&#9;struct { // SA相关参数结构
</span><span class='line'>&#9;&#9;u32             reqid;                // 请求ID
</span><span class='line'>&#9;&#9;u8              mode;               // 模式: 传输/通道
</span><span class='line'>&#9;&#9;u8              replay_window;      // 回放窗口
</span><span class='line'>&#9;&#9;u8              aalgo, ealgo, calgo; // 认证,加密,压缩算法ID值
</span><span class='line'>&#9;&#9;u8              flags;               // 一些标志
</span><span class='line'>&#9;&#9;u16             family;              // 协议族
</span><span class='line'>&#9;&#9;xfrm_address_t  saddr;              // 源地址
</span><span class='line'>&#9;&#9;int             header_len;          // 添加的协议头长度
</span><span class='line'>&#9;&#9;int             trailer_len;           //踪迹长度
</span><span class='line'>&#9;} props;
</span><span class='line'>
</span><span class='line'>&#9;struct xfrm_lifetime_cfg lft;               // 生存时间配置
</span><span class='line'>
</span><span class='line'>&#9;/* Data for transformer */
</span><span class='line'>&#9;struct xfrm_algo        *aalg;           // 认证算法
</span><span class='line'>&#9;struct xfrm_algo        *ealg;           // 加密算法
</span><span class='line'>&#9;struct xfrm_algo        *calg;           // 压缩算法
</span><span class='line'>
</span><span class='line'>&#9;/* Data for encapsulator */
</span><span class='line'>&#9;struct xfrm_encap_tmpl  *encap;       // NAT-T封装信息
</span><span class='line'>
</span><span class='line'>&#9;/* Data for care-of address */
</span><span class='line'>&#9;xfrm_address_t  *coaddr;
</span><span class='line'>
</span><span class='line'>&#9;/* IPComp needs an IPIP tunnel for handling uncompressed packets */
</span><span class='line'>&#9;struct xfrm_state       *tunnel;       // 通道, 实际是另一个SA
</span><span class='line'>
</span><span class='line'>&#9;/* If a tunnel, number of users + 1 */
</span><span class='line'>&#9;atomic_t                tunnel_users; // 通道的使用数
</span><span class='line'>
</span><span class='line'>&#9;/* State for replay detection */
</span><span class='line'>&#9;struct xfrm_replay_state replay;     // 回放检测结构,包含各种序列号掩码等信息
</span><span class='line'>
</span><span class='line'>&#9;/* Replay detection state at the time we sent the last notification */
</span><span class='line'>&#9;struct xfrm_replay_state preplay;   // 上次的回放记录值
</span><span class='line'>
</span><span class='line'>&#9;/* internal flag that only holds state for delayed aevent at the moment */
</span><span class='line'>&#9;u32                     xflags;     // 标志
</span><span class='line'>
</span><span class='line'>&#9;/* Replay detection notification settings */
</span><span class='line'>&#9;u32                     replay_maxage; // 回放最大时间间隔
</span><span class='line'>&#9;u32                     replay_maxdiff; // 回放最大差值
</span><span class='line'>
</span><span class='line'>&#9;/* Replay detection notification timer */
</span><span class='line'>&#9;struct timer_list       rtimer;            // 回放检测定时器
</span><span class='line'>
</span><span class='line'>&#9;/* Statistics */
</span><span class='line'>&#9;struct xfrm_stats       stats;          // 统计值
</span><span class='line'>
</span><span class='line'>&#9;struct xfrm_lifetime_cur curlft;         // 当前时间计数器
</span><span class='line'>&#9;struct timer_list       timer;           // SA定时器
</span><span class='line'>
</span><span class='line'>&#9;/* Last used time */
</span><span class='line'>&#9;u64                     lastused;     // 上次使用时间
</span><span class='line'>
</span><span class='line'>&#9;/* Reference to data common to all the instances of this transformer. */
</span><span class='line'>&#9;struct xfrm_type        *type;         // 协议, ESP/AH/IPCOMP
</span><span class='line'>&#9;struct xfrm_mode        *inner_mode; // 进入或输出的模式, 通道或传输
</span><span class='line'>&#9;struct xfrm_mode        *outer_mode;
</span><span class='line'>
</span><span class='line'>&#9;/* Security context */
</span><span class='line'>&#9;struct xfrm_sec_ctx     *security;     // 安全上下文, 加密时使用
</span><span class='line'>
</span><span class='line'>&#9;/* Private data of this transformer, format is opaque,                                     
</span><span class='line'>&#9; * interpreted by xfrm_type methods. */
</span><span class='line'>&#9;void                    *data;        // 内部数据
</span><span class='line'>};
</span><span class='line'>struct xfrm_policy
</span><span class='line'>{
</span><span class='line'>&#9;struct xfrm_policy      *next;    // 下一个策略
</span><span class='line'>&#9;struct hlist_node       bydst;    // 按目的地址HASH的链表
</span><span class='line'>&#9;struct hlist_node       byidx;    // 按索引号HASH的链表
</span><span class='line'>
</span><span class='line'>&#9;/* This lock only affects elements except for entry. */
</span><span class='line'>&#9;rwlock_t                lock;    // 策略结构锁
</span><span class='line'>&#9;atomic_t                refcnt;  // 引用次数
</span><span class='line'>&#9;struct timer_list         timer;   // 策略定时器
</span><span class='line'>
</span><span class='line'>&#9;u32                     priority; // 策略优先级
</span><span class='line'>&#9;u32                     index;   // 策略索引号
</span><span class='line'>&#9;struct xfrm_selector    selector;// 选择器
</span><span class='line'>&#9;struct xfrm_lifetime_cfg lft;     // 策略生命期
</span><span class='line'>&#9;struct xfrm_lifetime_cur curlft;  // 当前的生命期数据
</span><span class='line'>&#9;struct dst_entry       *bundles;// 路由链表
</span><span class='line'>&#9;u16                     family; // 协议族
</span><span class='line'>&#9;u8                      type;   // 类型
</span><span class='line'>&#9;u8                      action; // 策略动作, 接受/加密/阻塞等
</span><span class='line'>&#9;u8                      flags;  // 标志
</span><span class='line'>&#9;u8                      dead;  // 策略死亡标志
</span><span class='line'>&#9;u8                      xfrm_nr;// 使用的xfrm_vec的数量
</span><span class='line'>
</span><span class='line'>&#9;/* XXX 1 byte hole, try to pack */
</span><span class='line'>&#9;struct xfrm_sec_ctx     *security;// 安全上下文
</span><span class='line'>&#9;struct xfrm_tmpl        xfrm_vec[XFRM_MAX_DEPTH];// 状态模板
</span><span class='line'>};
</span><span class='line'>xfrm模板结构, 用于状态和策略的查询
</span><span class='line'>struct xfrm_tmpl
</span><span class='line'>{
</span><span class='line'>&#9;/* id in template is interpreted as:                                                               
</span><span class='line'>&#9; * daddr - destination of tunnel, may be zero for transport mode.                                  
</span><span class='line'>&#9; * spi   - zero to acquire spi. Not zero if spi is static, then                                    
</span><span class='line'>&#9; *         daddr must be fixed too.                                                                
</span><span class='line'>&#9; * proto - AH/ESP/IPCOMP                                                                           
</span><span class='line'>&#9; */
</span><span class='line'>&#9;struct xfrm_id          id;    // SA三元组, 目的地址, 协议, SPI
</span><span class='line'>&#9;xfrm_address_t          saddr;// 源地址
</span><span class='line'>&#9;unsigned short          encap_family;
</span><span class='line'>&#9;__u32                   reqid;// 请求ID
</span><span class='line'>
</span><span class='line'>&#9;/* Mode: transport, tunnel etc. */
</span><span class='line'>&#9;__u8                    mode;
</span><span class='line'>
</span><span class='line'>&#9;/* Sharing mode: unique, this session only, this user only etc. */
</span><span class='line'>&#9;__u8                    share;
</span><span class='line'>
</span><span class='line'>&#9;/* May skip this transfomration if no SA is found */
</span><span class='line'>&#9;__u8                    optional;
</span><span class='line'>
</span><span class='line'>&#9;/* Bit mask of algos allowed for acquisition */
</span><span class='line'>&#9;__u32                   aalgos;
</span><span class='line'>&#9;__u32                   ealgos;
</span><span class='line'>&#9;__u32                   calgos;
</span><span class='line'>};
</span><span class='line'>对ESP, AH, IPCOMP等协议的描述是通过xfrm_type结构来描述的, 多个协议的封装就是靠多个协议结构形成的链表来实现
</span><span class='line'>struct xfrm_type
</span><span class='line'>{
</span><span class='line'>&#9;char                    *description;  // 描述字符串
</span><span class='line'>&#9;struct module           *owner;     // 协议模块
</span><span class='line'>&#9;__u8                    proto;       // 协议值
</span><span class='line'>&#9;__u8                    flags;       // 标志
</span><span class='line'>#define XFRM_TYPE_NON_FRAGMENT  1
</span><span class='line'>#define XFRM_TYPE_REPLAY_PROT   2
</span><span class='line'>&#9;int                     (*init_state)(struct xfrm_state *x);   // 初始化状态
</span><span class='line'>&#9;void                    (*destructor)(struct xfrm_state *);  // 析构函数
</span><span class='line'>&#9;int                     (*input)(struct xfrm_state *, struct sk_buff *skb); // 数据输入函数
</span><span class='line'>&#9;int                     (*output)(struct xfrm_state *, struct sk_buff *pskb); // 数据输出函数
</span><span class='line'>&#9;int                     (*reject)(struct xfrm_state *, struct sk_buff *, struct flowi *); // 拒绝函数
</span><span class='line'>&#9;int                     (*hdr_offset)(struct xfrm_state *, struct sk_buff *, u8 **); // 头部偏移
</span><span class='line'>&#9;xfrm_address_t          *(*local_addr)(struct xfrm_state *, xfrm_address_t *); // 本地地址
</span><span class='line'>&#9;xfrm_address_t          *(*remote_addr)(struct xfrm_state *, xfrm_address_t *);// 远程地址
</span><span class='line'>&#9;/* Estimate maximal size of result of transformation of a dgram */
</span><span class='line'>&#9;u32                     (*get_mtu)(struct xfrm_state *, int size); // 最大数据报长度
</span><span class='line'>
</span><span class='line'>};
</span><span class='line'>
</span><span class='line'>模式结构用于描述IPSEC连接描述, 可为通道模式或传输模式两种.
</span><span class='line'>struct xfrm_mode {
</span><span class='line'>&#9;int (*input)(struct xfrm_state *x, struct sk_buff *skb);  // 数据输入函数
</span><span class='line'>&#9;int (*output)(struct xfrm_state *x,struct sk_buff *skb); // 数据输出函数
</span><span class='line'>
</span><span class='line'>&#9;struct xfrm_state_afinfo *afinfo; //策略的相关协议处理结构
</span><span class='line'>&#9;struct module *owner;
</span><span class='line'>&#9;unsigned int encap;  // 封装
</span><span class='line'>&#9;int flags;            //标志
</span><span class='line'>};
</span><span class='line'>
</span><span class='line'>以下结构用于描述具体协议族下的的策略处理.
</span><span class='line'>struct xfrm_policy_afinfo {
</span><span class='line'>&#9;unsigned short          family;  // 协议族
</span><span class='line'>&#9;struct dst_ops          *dst_ops;// 目的操作结构
</span><span class='line'>&#9;void                    (*garbage_collect)(void);// 垃圾搜集
</span><span class='line'>&#9;int                     (*dst_lookup)(struct xfrm_dst **dst, struct flowi *fl);// 路由选择
</span><span class='line'>&#9;int                     (*get_saddr)(xfrm_address_t *saddr, xfrm_address_t *daddr);// 获取源地址
</span><span class='line'>&#9;struct dst_entry        *(*find_bundle)(struct flowi *fl, struct xfrm_policy *policy);// 查找路由项
</span><span class='line'>&#9;int                     (*bundle_create)(struct xfrm_policy *policy, struct xfrm_state **xfrm,
</span><span class='line'>&#9;&#9;&#9;int nx, struct flowi *fl, struct dst_entry **dst_p);// 创建新路由项
</span><span class='line'>&#9;void                    (*decode_session)(struct sk_buff *skb, struct flowi *fl);// 解码会话
</span><span class='line'>};
</span><span class='line'>
</span><span class='line'>状态的相关协议处理结构
</span><span class='line'>struct xfrm_state_afinfo {
</span><span class='line'>&#9;unsigned int             family;// 协议族
</span><span class='line'>&#9;struct module            *owner;
</span><span class='line'>&#9;struct xfrm_type        *type_map[IPPROTO_MAX];
</span><span class='line'>&#9;struct xfrm_mode        *mode_map[XFRM_MODE_MAX];
</span><span class='line'>&#9;int                      (*init_flags)(struct xfrm_state *x);// 初始化标志
</span><span class='line'>&#9;void                    (*init_tempsel)(struct xfrm_state *x, struct flowi *fl, struct xfrm_tmpl *tmpl,
</span><span class='line'>&#9;&#9;&#9;xfrm_address_t *daddr, xfrm_address_t *saddr);// 初始化模板选择
</span><span class='line'>&#9;int                     (*tmpl_sort)(struct xfrm_tmpl **dst, struct xfrm_tmpl **src, int n);// 模板排序
</span><span class='line'>&#9;int                     (*state_sort)(struct xfrm_state **dst, struct xfrm_state **src, int n);// 状态排序
</span><span class='line'>&#9;int                     (*output)(struct sk_buff *skb);
</span><span class='line'>};
</span><span class='line'>IPV4的状态相关协议处理结构
</span><span class='line'>static struct xfrm_state_afinfo xfrm4_state_afinfo = { //net/ipv4/xfrm4_state.c
</span><span class='line'>&#9;.family                  = AF_INET,
</span><span class='line'>&#9;.owner                  = THIS_MODULE,
</span><span class='line'>&#9;.init_flags               = xfrm4_init_flags,
</span><span class='line'>&#9;.init_tempsel            = __xfrm4_init_tempsel,
</span><span class='line'>&#9;.output                 = xfrm4_output,
</span><span class='line'>};
</span><span class='line'>回调通知信息结构
</span><span class='line'>struct xfrm_mgr
</span><span class='line'>{
</span><span class='line'>&#9;struct list_head        list;
</span><span class='line'>&#9;char                    *id;
</span><span class='line'>&#9;int                     (*notify)(struct xfrm_state *x, struct km_event *c);// 状态通知
</span><span class='line'>&#9;int                     (*acquire)(struct xfrm_state *x, struct xfrm_tmpl *, struct xfrm_policy *xp, int dir);// 获取, 如获取SA
</span><span class='line'>&#9;struct xfrm_policy      *(*compile_policy)(struct sock *sk, int opt, u8 *data, int len, int *dir);// 编译策略
</span><span class='line'>&#9;int                     (*new_mapping)(struct xfrm_state *x, xfrm_address_t *ipaddr, __be16 sport);// 映射
</span><span class='line'>&#9;int                     (*notify_policy)(struct xfrm_policy *x, int dir, struct km_event *c);// 策略通知
</span><span class='line'>&#9;int                     (*report)(u8 proto, struct xfrm_selector *sel, xfrm_address_t *addr);// 报告
</span><span class='line'>&#9;int                     (*migrate)(struct xfrm_selector *sel, u8 dir, u8 type, struct xfrm_migrate *m, int num_bundles);//迁移
</span><span class='line'>};
</span><span class='line'>static struct xfrm_mgr pfkeyv2_mgr = // net/key/pf_key.c
</span><span class='line'>{
</span><span class='line'>&#9;.id             = "pfkeyv2",
</span><span class='line'>&#9;.notify         = pfkey_send_notify,
</span><span class='line'>&#9;.acquire        = pfkey_send_acquire,
</span><span class='line'>&#9;.compile_policy = pfkey_compile_policy,
</span><span class='line'>&#9;.new_mapping  = pfkey_send_new_mapping,
</span><span class='line'>&#9;.notify_policy  = pfkey_send_policy_notify,
</span><span class='line'>&#9;.migrate        = pfkey_send_migrate,
</span><span class='line'>};</span></code></pre></td></tr></table></div></figure>


<p>[初始化]</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
<span class='line-number'>16</span>
<span class='line-number'>17</span>
<span class='line-number'>18</span>
<span class='line-number'>19</span>
<span class='line-number'>20</span>
<span class='line-number'>21</span>
<span class='line-number'>22</span>
<span class='line-number'>23</span>
<span class='line-number'>24</span>
<span class='line-number'>25</span>
<span class='line-number'>26</span>
<span class='line-number'>27</span>
<span class='line-number'>28</span>
<span class='line-number'>29</span>
<span class='line-number'>30</span>
<span class='line-number'>31</span>
<span class='line-number'>32</span>
<span class='line-number'>33</span>
<span class='line-number'>34</span>
<span class='line-number'>35</span>
<span class='line-number'>36</span>
<span class='line-number'>37</span>
<span class='line-number'>38</span>
<span class='line-number'>39</span>
<span class='line-number'>40</span>
<span class='line-number'>41</span>
<span class='line-number'>42</span>
<span class='line-number'>43</span>
<span class='line-number'>44</span>
<span class='line-number'>45</span>
<span class='line-number'>46</span>
<span class='line-number'>47</span>
<span class='line-number'>48</span>
<span class='line-number'>49</span>
<span class='line-number'>50</span>
<span class='line-number'>51</span>
<span class='line-number'>52</span>
<span class='line-number'>53</span>
<span class='line-number'>54</span>
<span class='line-number'>55</span>
<span class='line-number'>56</span>
<span class='line-number'>57</span>
<span class='line-number'>58</span>
<span class='line-number'>59</span>
<span class='line-number'>60</span>
<span class='line-number'>61</span>
<span class='line-number'>62</span>
<span class='line-number'>63</span>
<span class='line-number'>64</span>
<span class='line-number'>65</span>
<span class='line-number'>66</span>
<span class='line-number'>67</span>
<span class='line-number'>68</span>
<span class='line-number'>69</span>
<span class='line-number'>70</span>
<span class='line-number'>71</span>
<span class='line-number'>72</span>
<span class='line-number'>73</span>
<span class='line-number'>74</span>
<span class='line-number'>75</span>
<span class='line-number'>76</span>
<span class='line-number'>77</span>
<span class='line-number'>78</span>
<span class='line-number'>79</span>
<span class='line-number'>80</span>
<span class='line-number'>81</span>
<span class='line-number'>82</span>
<span class='line-number'>83</span>
<span class='line-number'>84</span>
<span class='line-number'>85</span>
<span class='line-number'>86</span>
<span class='line-number'>87</span>
<span class='line-number'>88</span>
<span class='line-number'>89</span>
<span class='line-number'>90</span>
<span class='line-number'>91</span>
<span class='line-number'>92</span>
<span class='line-number'>93</span>
<span class='line-number'>94</span>
<span class='line-number'>95</span>
<span class='line-number'>96</span>
<span class='line-number'>97</span>
<span class='line-number'>98</span>
<span class='line-number'>99</span>
<span class='line-number'>100</span>
<span class='line-number'>101</span>
<span class='line-number'>102</span>
<span class='line-number'>103</span>
<span class='line-number'>104</span>
<span class='line-number'>105</span>
<span class='line-number'>106</span>
<span class='line-number'>107</span>
<span class='line-number'>108</span>
<span class='line-number'>109</span>
<span class='line-number'>110</span>
<span class='line-number'>111</span>
<span class='line-number'>112</span>
<span class='line-number'>113</span>
<span class='line-number'>114</span>
<span class='line-number'>115</span>
<span class='line-number'>116</span>
<span class='line-number'>117</span>
<span class='line-number'>118</span>
<span class='line-number'>119</span>
<span class='line-number'>120</span>
<span class='line-number'>121</span>
<span class='line-number'>122</span>
<span class='line-number'>123</span>
<span class='line-number'>124</span>
<span class='line-number'>125</span>
<span class='line-number'>126</span>
<span class='line-number'>127</span>
<span class='line-number'>128</span>
<span class='line-number'>129</span>
<span class='line-number'>130</span>
<span class='line-number'>131</span>
<span class='line-number'>132</span>
<span class='line-number'>133</span>
<span class='line-number'>134</span>
<span class='line-number'>135</span>
<span class='line-number'>136</span>
<span class='line-number'>137</span>
<span class='line-number'>138</span>
<span class='line-number'>139</span>
<span class='line-number'>140</span>
<span class='line-number'>141</span>
<span class='line-number'>142</span>
<span class='line-number'>143</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>int __init ip_rt_init(void) //ip路由初始化函数
</span><span class='line'>{
</span><span class='line'>&#9;......
</span><span class='line'>#ifdef CONFIG_XFRM
</span><span class='line'>&#9;xfrm_init();
</span><span class='line'>&#9;xfrm4_init();
</span><span class='line'>#endif
</span><span class='line'>&#9;......
</span><span class='line'>}
</span><span class='line'>net/xfrm/xfrm_policy.c
</span><span class='line'>xfrm初始化函数包括状态, 策略和输入处理的初始化函数
</span><span class='line'>&#9;xfrm是不支持模块方式的
</span><span class='line'>void __init xfrm_init(void)
</span><span class='line'>{
</span><span class='line'>&#9;xfrm_state_init();
</span><span class='line'>&#9;xfrm_policy_init();
</span><span class='line'>&#9;xfrm_input_init();
</span><span class='line'>}
</span><span class='line'>&#9;状态初始化
</span><span class='line'>void __init xfrm_state_init(void)
</span><span class='line'>{
</span><span class='line'>&#9;unsigned int sz;
</span><span class='line'>&#9;//初始HASH表不大, 每个HASH中初始化为8个链表, 但随着状态数量的增加会动态增加HASH表数量
</span><span class='line'>&#9;sz = sizeof(struct hlist_head) * 8;
</span><span class='line'>&#9;//建立3组HASH, 分别按SA的源地址, 目的地址和SPI值
</span><span class='line'>&#9;xfrm_state_bydst = xfrm_hash_alloc(sz);
</span><span class='line'>&#9;xfrm_state_bysrc = xfrm_hash_alloc(sz);
</span><span class='line'>&#9;xfrm_state_byspi = xfrm_hash_alloc(sz);
</span><span class='line'>
</span><span class='line'>&#9;if (!xfrm_state_bydst || !xfrm_state_bysrc || !xfrm_state_byspi)
</span><span class='line'>&#9;&#9;panic("XFRM: Cannot allocate bydst/bysrc/byspi hashes.");
</span><span class='line'>&#9;//xfrm_state_hmask初始值为=7
</span><span class='line'>&#9;xfrm_state_hmask = ((sz / sizeof(struct hlist_head)) - 1);
</span><span class='line'>&#9;//初始化工作队列work_queue, 完成对状态垃圾的搜集和释放
</span><span class='line'>&#9;INIT_WORK(&xfrm_state_gc_work, xfrm_state_gc_task);
</span><span class='line'>}
</span><span class='line'>策略初始化
</span><span class='line'>static void __init xfrm_policy_init(void)
</span><span class='line'>{
</span><span class='line'>&#9;unsigned int hmask, sz;
</span><span class='line'>&#9;int dir;
</span><span class='line'>&#9;//建立一个内核cache, 用于分配xfrm_dst结构
</span><span class='line'>&#9;xfrm_dst_cache = kmem_cache_create("xfrm_dst_cache", sizeof(struct xfrm_dst),
</span><span class='line'>&#9;&#9;&#9;0, SLAB_HWCACHE_ALIGN|SLAB_PANIC, NULL);
</span><span class='line'>
</span><span class='line'>&#9;//分配状态HASH表, 初始是8个HASH链表,以后随着策略数量的增加会动态增加HASH表的数量
</span><span class='line'>&#9;hmask = 8 - 1;
</span><span class='line'>&#9;sz = (hmask+1) * sizeof(struct hlist_head);
</span><span class='line'>&#9;//该HASH表是按策略的index参数进行索引的
</span><span class='line'>&#9;xfrm_policy_byidx = xfrm_hash_alloc(sz);
</span><span class='line'>&#9;xfrm_idx_hmask = hmask;
</span><span class='line'>&#9;if (!xfrm_policy_byidx)
</span><span class='line'>&#9;&#9;panic("XFRM: failed to allocate byidx hash\n");
</span><span class='line'>&#9;//输入, 输出, 转发三个处理点, 双向
</span><span class='line'>&#9;for (dir = 0; dir &lt; XFRM_POLICY_MAX * 2; dir++) {
</span><span class='line'>&#9;&#9;struct xfrm_policy_hash *htab;
</span><span class='line'>&#9;&#9;//初始化inexact链表头, inexact处理选择子相关长度不是标准值的一些特别策略
</span><span class='line'>&#9;&#9;INIT_HLIST_HEAD(&xfrm_policy_inexact[dir]);
</span><span class='line'>&#9;&#9;//分配按地址HASH的HASH表
</span><span class='line'>&#9;&#9;htab = &xfrm_policy_bydst[dir];
</span><span class='line'>&#9;&#9;htab-&gt;table = xfrm_hash_alloc(sz);
</span><span class='line'>&#9;&#9;htab-&gt;hmask = hmask;
</span><span class='line'>&#9;&#9;if (!htab-&gt;table)
</span><span class='line'>&#9;&#9;&#9;panic("XFRM: failed to allocate bydst hash\n");
</span><span class='line'>&#9;}
</span><span class='line'>&#9;//初始化策略垃圾搜集的工作队列, 完成对策略垃圾的搜集和释放
</span><span class='line'>&#9;INIT_WORK(&xfrm_policy_gc_work, xfrm_policy_gc_task);
</span><span class='line'>&#9;//登记网卡通知，参看下面网卡通知回调实现
</span><span class='line'>&#9;register_netdevice_notifier(&xfrm_dev_notifier);
</span><span class='line'>}
</span><span class='line'>输入初始化
</span><span class='line'>struct sec_path结构是对输入的加密包进行层层解包的处理, 在sk_buff中有该结构的指针sp, 如果sp非空表示这是个IPSEC解密后的包.
</span><span class='line'>void __init xfrm_input_init(void)
</span><span class='line'>{
</span><span class='line'>&#9;//建立一个内核cache, 用于分配sec_path结构(安全路径)
</span><span class='line'>&#9;secpath_cachep = kmem_cache_create("secpath_cache", sizeof(struct sec_path),
</span><span class='line'>&#9;&#9;&#9;0, SLAB_HWCACHE_ALIGN|SLAB_PANIC, NULL);
</span><span class='line'>}
</span><span class='line'>//协议相关的状态策略初始化，注册两个具体的相关协议的处理结构
</span><span class='line'>void __init xfrm4_init(void)
</span><span class='line'>{
</span><span class='line'>&#9;xfrm4_state_init();//xfrm_state_register_afinfo(&xfrm4_state_afinfo);
</span><span class='line'>&#9;xfrm4_policy_init();//xfrm_policy_register_afinfo(&xfrm4_policy_afinfo);
</span><span class='line'>}
</span><span class='line'>协议初始化
</span><span class='line'>在net/ipv4/xfrm4_tunnel.c中定义ipip协议的接收处理函数
</span><span class='line'>static struct xfrm_tunnel xfrm_tunnel_handler = {
</span><span class='line'>&#9;.handler        =       xfrm_tunnel_rcv,
</span><span class='line'>&#9;.err_handler    =       xfrm_tunnel_err,
</span><span class='line'>&#9;.priority       =       2,
</span><span class='line'>};
</span><span class='line'>static int __init ipip_init(void)
</span><span class='line'>{
</span><span class='line'>&#9;if (xfrm_register_type(&ipip_type, AF_INET) &lt; 0) { //参考上面数据结构部分
</span><span class='line'>&#9;&#9;printk(KERN_INFO "ipip init: can't add xfrm type\n");
</span><span class='line'>&#9;&#9;return -EAGAIN;
</span><span class='line'>&#9;}
</span><span class='line'>&#9;if (xfrm4_tunnel_register(&xfrm_tunnel_handler, AF_INET)) { //参考ip隧道基础研究文章
</span><span class='line'>&#9;&#9;printk(KERN_INFO "ipip init: can't add xfrm handler for AF_INET\n");
</span><span class='line'>&#9;&#9;xfrm_unregister_type(&ipip_type, AF_INET);
</span><span class='line'>&#9;&#9;return -EAGAIN;
</span><span class='line'>&#9;}
</span><span class='line'>&#9;......
</span><span class='line'>&#9;return 0;
</span><span class='line'>}
</span><span class='line'>在net/ipv4/esp4.c中定义了esp协议的接收处理函数.
</span><span class='line'>static struct net_protocol esp4_protocol = {
</span><span class='line'>&#9;.handler        =       xfrm4_rcv,
</span><span class='line'>&#9;.err_handler    =       esp4_err,
</span><span class='line'>&#9;.no_policy      =       1,
</span><span class='line'>};
</span><span class='line'>static int __init esp4_init(void)
</span><span class='line'>{
</span><span class='line'>&#9;if (xfrm_register_type(&esp_type, AF_INET) &lt; 0) { //参考上面数据结构部分
</span><span class='line'>&#9;&#9;printk(KERN_INFO "ip esp init: can't add xfrm type\n");
</span><span class='line'>&#9;&#9;return -EAGAIN;
</span><span class='line'>&#9;}
</span><span class='line'>&#9;if (inet_add_protocol(&esp4_protocol, IPPROTO_ESP) &lt; 0) { //参考ip隧道基础研究文章
</span><span class='line'>&#9;&#9;printk(KERN_INFO "ip esp init: can't add protocol\n");
</span><span class='line'>&#9;&#9;xfrm_unregister_type(&esp_type, AF_INET);
</span><span class='line'>&#9;&#9;return -EAGAIN;
</span><span class='line'>&#9;}
</span><span class='line'>&#9;return 0;
</span><span class='line'>}
</span><span class='line'>在net/ipv4/ah4.c中定义了ah协议的接收处理函数，与esp基本一样
</span><span class='line'>static struct net_protocol ah4_protocol = {
</span><span class='line'>&#9;.handler        =       xfrm4_rcv,
</span><span class='line'>&#9;.err_handler    =       ah4_err,
</span><span class='line'>&#9;.no_policy      =       1,
</span><span class='line'>};
</span><span class='line'>static int __init ah4_init(void)
</span><span class='line'>{
</span><span class='line'>&#9;if (xfrm_register_type(&ah_type, AF_INET) &lt; 0) {
</span><span class='line'>&#9;&#9;printk(KERN_INFO "ip ah init: can't add xfrm type\n");
</span><span class='line'>&#9;&#9;return -EAGAIN;
</span><span class='line'>&#9;}
</span><span class='line'>&#9;if (inet_add_protocol(&ah4_protocol, IPPROTO_AH) &lt; 0) {
</span><span class='line'>&#9;&#9;printk(KERN_INFO "ip ah init: can't add protocol\n");
</span><span class='line'>&#9;&#9;xfrm_unregister_type(&ah_type, AF_INET);
</span><span class='line'>&#9;&#9;return -EAGAIN;
</span><span class='line'>&#9;}
</span><span class='line'>&#9;return 0;
</span><span class='line'>}</span></code></pre></td></tr></table></div></figure>


<p>[数据接收]</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
<span class='line-number'>16</span>
<span class='line-number'>17</span>
<span class='line-number'>18</span>
<span class='line-number'>19</span>
<span class='line-number'>20</span>
<span class='line-number'>21</span>
<span class='line-number'>22</span>
<span class='line-number'>23</span>
<span class='line-number'>24</span>
<span class='line-number'>25</span>
<span class='line-number'>26</span>
<span class='line-number'>27</span>
<span class='line-number'>28</span>
<span class='line-number'>29</span>
<span class='line-number'>30</span>
<span class='line-number'>31</span>
<span class='line-number'>32</span>
<span class='line-number'>33</span>
<span class='line-number'>34</span>
<span class='line-number'>35</span>
<span class='line-number'>36</span>
<span class='line-number'>37</span>
<span class='line-number'>38</span>
<span class='line-number'>39</span>
<span class='line-number'>40</span>
<span class='line-number'>41</span>
<span class='line-number'>42</span>
<span class='line-number'>43</span>
<span class='line-number'>44</span>
<span class='line-number'>45</span>
<span class='line-number'>46</span>
<span class='line-number'>47</span>
<span class='line-number'>48</span>
<span class='line-number'>49</span>
<span class='line-number'>50</span>
<span class='line-number'>51</span>
<span class='line-number'>52</span>
<span class='line-number'>53</span>
<span class='line-number'>54</span>
<span class='line-number'>55</span>
<span class='line-number'>56</span>
<span class='line-number'>57</span>
<span class='line-number'>58</span>
<span class='line-number'>59</span>
<span class='line-number'>60</span>
<span class='line-number'>61</span>
<span class='line-number'>62</span>
<span class='line-number'>63</span>
<span class='line-number'>64</span>
<span class='line-number'>65</span>
<span class='line-number'>66</span>
<span class='line-number'>67</span>
<span class='line-number'>68</span>
<span class='line-number'>69</span>
<span class='line-number'>70</span>
<span class='line-number'>71</span>
<span class='line-number'>72</span>
<span class='line-number'>73</span>
<span class='line-number'>74</span>
<span class='line-number'>75</span>
<span class='line-number'>76</span>
<span class='line-number'>77</span>
<span class='line-number'>78</span>
<span class='line-number'>79</span>
<span class='line-number'>80</span>
<span class='line-number'>81</span>
<span class='line-number'>82</span>
<span class='line-number'>83</span>
<span class='line-number'>84</span>
<span class='line-number'>85</span>
<span class='line-number'>86</span>
<span class='line-number'>87</span>
<span class='line-number'>88</span>
<span class='line-number'>89</span>
<span class='line-number'>90</span>
<span class='line-number'>91</span>
<span class='line-number'>92</span>
<span class='line-number'>93</span>
<span class='line-number'>94</span>
<span class='line-number'>95</span>
<span class='line-number'>96</span>
<span class='line-number'>97</span>
<span class='line-number'>98</span>
<span class='line-number'>99</span>
<span class='line-number'>100</span>
<span class='line-number'>101</span>
<span class='line-number'>102</span>
<span class='line-number'>103</span>
<span class='line-number'>104</span>
<span class='line-number'>105</span>
<span class='line-number'>106</span>
<span class='line-number'>107</span>
<span class='line-number'>108</span>
<span class='line-number'>109</span>
<span class='line-number'>110</span>
<span class='line-number'>111</span>
<span class='line-number'>112</span>
<span class='line-number'>113</span>
<span class='line-number'>114</span>
<span class='line-number'>115</span>
<span class='line-number'>116</span>
<span class='line-number'>117</span>
<span class='line-number'>118</span>
<span class='line-number'>119</span>
<span class='line-number'>120</span>
<span class='line-number'>121</span>
<span class='line-number'>122</span>
<span class='line-number'>123</span>
<span class='line-number'>124</span>
<span class='line-number'>125</span>
<span class='line-number'>126</span>
<span class='line-number'>127</span>
<span class='line-number'>128</span>
<span class='line-number'>129</span>
<span class='line-number'>130</span>
<span class='line-number'>131</span>
<span class='line-number'>132</span>
<span class='line-number'>133</span>
<span class='line-number'>134</span>
<span class='line-number'>135</span>
<span class='line-number'>136</span>
<span class='line-number'>137</span>
<span class='line-number'>138</span>
<span class='line-number'>139</span>
<span class='line-number'>140</span>
<span class='line-number'>141</span>
<span class='line-number'>142</span>
<span class='line-number'>143</span>
<span class='line-number'>144</span>
<span class='line-number'>145</span>
<span class='line-number'>146</span>
<span class='line-number'>147</span>
<span class='line-number'>148</span>
<span class='line-number'>149</span>
<span class='line-number'>150</span>
<span class='line-number'>151</span>
<span class='line-number'>152</span>
<span class='line-number'>153</span>
<span class='line-number'>154</span>
<span class='line-number'>155</span>
<span class='line-number'>156</span>
<span class='line-number'>157</span>
<span class='line-number'>158</span>
<span class='line-number'>159</span>
<span class='line-number'>160</span>
<span class='line-number'>161</span>
<span class='line-number'>162</span>
<span class='line-number'>163</span>
<span class='line-number'>164</span>
<span class='line-number'>165</span>
<span class='line-number'>166</span>
<span class='line-number'>167</span>
<span class='line-number'>168</span>
<span class='line-number'>169</span>
<span class='line-number'>170</span>
<span class='line-number'>171</span>
<span class='line-number'>172</span>
<span class='line-number'>173</span>
<span class='line-number'>174</span>
<span class='line-number'>175</span>
<span class='line-number'>176</span>
<span class='line-number'>177</span>
<span class='line-number'>178</span>
<span class='line-number'>179</span>
<span class='line-number'>180</span>
<span class='line-number'>181</span>
<span class='line-number'>182</span>
<span class='line-number'>183</span>
<span class='line-number'>184</span>
<span class='line-number'>185</span>
<span class='line-number'>186</span>
<span class='line-number'>187</span>
<span class='line-number'>188</span>
<span class='line-number'>189</span>
<span class='line-number'>190</span>
<span class='line-number'>191</span>
<span class='line-number'>192</span>
<span class='line-number'>193</span>
<span class='line-number'>194</span>
<span class='line-number'>195</span>
<span class='line-number'>196</span>
<span class='line-number'>197</span>
<span class='line-number'>198</span>
<span class='line-number'>199</span>
<span class='line-number'>200</span>
<span class='line-number'>201</span>
<span class='line-number'>202</span>
<span class='line-number'>203</span>
<span class='line-number'>204</span>
<span class='line-number'>205</span>
<span class='line-number'>206</span>
<span class='line-number'>207</span>
<span class='line-number'>208</span>
<span class='line-number'>209</span>
<span class='line-number'>210</span>
<span class='line-number'>211</span>
<span class='line-number'>212</span>
<span class='line-number'>213</span>
<span class='line-number'>214</span>
<span class='line-number'>215</span>
<span class='line-number'>216</span>
<span class='line-number'>217</span>
<span class='line-number'>218</span>
<span class='line-number'>219</span>
<span class='line-number'>220</span>
<span class='line-number'>221</span>
<span class='line-number'>222</span>
<span class='line-number'>223</span>
<span class='line-number'>224</span>
<span class='line-number'>225</span>
<span class='line-number'>226</span>
<span class='line-number'>227</span>
<span class='line-number'>228</span>
<span class='line-number'>229</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>下面我们先看ipip协议的接收处理函数.
</span><span class='line'>static int xfrm_tunnel_rcv(struct sk_buff *skb)
</span><span class='line'>{
</span><span class='line'>&#9;return xfrm4_rcv_spi(skb, IPPROTO_IPIP, ip_hdr(skb)-&gt;saddr);
</span><span class='line'>}
</span><span class='line'>esp和ah协议的接收处理函数
</span><span class='line'>int xfrm4_rcv(struct sk_buff *skb)
</span><span class='line'>{
</span><span class='line'>&#9;return xfrm4_rcv_spi(skb, ip_hdr(skb)-&gt;protocol, 0);
</span><span class='line'>}
</span><span class='line'>都调用到同样的函数
</span><span class='line'>static inline int xfrm4_rcv_spi(struct sk_buff *skb, int nexthdr, __be32 spi)
</span><span class='line'>{
</span><span class='line'>&#9;return xfrm4_rcv_encap(skb, nexthdr, spi, 0);
</span><span class='line'>}
</span><span class='line'>实际就是
</span><span class='line'>int xfrm4_rcv_encap(struct sk_buff *skb, int nexthdr, __be32 spi, int encap_type)
</span><span class='line'>{
</span><span class='line'>&#9;int err;
</span><span class='line'>&#9;__be32 seq;
</span><span class='line'>&#9;struct xfrm_state *xfrm_vec[XFRM_MAX_DEPTH];
</span><span class='line'>&#9;struct xfrm_state *x;
</span><span class='line'>&#9;int xfrm_nr = 0;
</span><span class='line'>&#9;int decaps = 0;
</span><span class='line'>&#9;unsigned int nhoff = offsetof(struct iphdr, protocol); //协议字段在ip头中的偏移位置
</span><span class='line'>&#9;seq = 0;
</span><span class='line'>
</span><span class='line'>&#9;//获取skb中的spi和序列号信息，ipip时spi不为0
</span><span class='line'>&#9;if (!spi && (err = xfrm_parse_spi(skb, nexthdr, &spi, &seq)) != 0)
</span><span class='line'>&#9;&#9;goto drop;
</span><span class='line'>&#9;//进入循环进行解包操作
</span><span class='line'>&#9;do {
</span><span class='line'>&#9;&#9;const struct iphdr *iph = ip_hdr(skb);
</span><span class='line'>&#9;&#9;if (xfrm_nr == XFRM_MAX_DEPTH)//循环解包次数太深的话放弃，目前定义是 6
</span><span class='line'>&#9;&#9;&#9;goto drop;
</span><span class='line'>
</span><span class='line'>&#9;&#9;//根据地址, SPI和协议查找SA
</span><span class='line'>&#9;&#9;//主要调用__xfrm_state_lookup(daddr, spi, proto, family);上下有锁保护
</span><span class='line'>&#9;&#9;x = xfrm_state_lookup((xfrm_address_t *)&iph-&gt;daddr, spi, nexthdr, AF_INET);
</span><span class='line'>&#9;&#9;if (x == NULL)
</span><span class='line'>&#9;&#9;&#9;goto drop;
</span><span class='line'>
</span><span class='line'>&#9;&#9;// 以下根据SA定义的操作对数据解码
</span><span class='line'>&#9;&#9;spin_lock(&x-&gt;lock);
</span><span class='line'>&#9;&#9;if (unlikely(x-&gt;km.state != XFRM_STATE_VALID))
</span><span class='line'>&#9;&#9;&#9;goto drop_unlock;
</span><span class='line'>
</span><span class='line'>&#9;&#9;//检查由SA指定的封装类型是否和函数指定的封装类型相同
</span><span class='line'>&#9;&#9;if ((x-&gt;encap ? x-&gt;encap-&gt;encap_type : 0) != encap_type)
</span><span class='line'>&#9;&#9;&#9;goto drop_unlock;
</span><span class='line'>
</span><span class='line'>&#9;&#9;//SA重放窗口检查
</span><span class='line'>&#9;&#9;if (x-&gt;props.replay_window && xfrm_replay_check(x, seq))
</span><span class='line'>&#9;&#9;&#9;goto drop_unlock;
</span><span class='line'>
</span><span class='line'>&#9;&#9;//SA生存期检查
</span><span class='line'>&#9;&#9;if (xfrm_state_check_expire(x))
</span><span class='line'>&#9;&#9;&#9;goto drop_unlock;
</span><span class='line'>
</span><span class='line'>&#9;&#9;//type可为esp,ah,ipcomp, ipip等, 调用具体协议的输入函数对输入数据解密，参看下面具体协议实现
</span><span class='line'>&#9;&#9;nexthdr = x-&gt;type-&gt;input(x, skb);
</span><span class='line'>&#9;&#9;if (nexthdr &lt;= 0)
</span><span class='line'>&#9;&#9;&#9;goto drop_unlock;
</span><span class='line'>
</span><span class='line'>&#9;&#9;skb_network_header(skb)[nhoff] = nexthdr; //修改为解密后的协议
</span><span class='line'>&#9;&#9;/* only the first xfrm gets the encap type */
</span><span class='line'>&#9;&#9;encap_type = 0;
</span><span class='line'>
</span><span class='line'>&#9;&#9;//更新重放窗口
</span><span class='line'>&#9;&#9;if (x-&gt;props.replay_window)
</span><span class='line'>&#9;&#9;&#9;xfrm_replay_advance(x, seq);
</span><span class='line'>
</span><span class='line'>&#9;&#9;//包数,字节数统计
</span><span class='line'>&#9;&#9;x-&gt;curlft.bytes += skb-&gt;len;
</span><span class='line'>&#9;&#9;x-&gt;curlft.packets++;
</span><span class='line'>
</span><span class='line'>&#9;&#9;spin_unlock(&x-&gt;lock);
</span><span class='line'>&#9;&#9;//保存数据解封用的SA, 增加SA数量计数
</span><span class='line'>&#9;&#9;xfrm_vec[xfrm_nr++] = x;
</span><span class='line'>
</span><span class='line'>&#9;&#9;//mode可为通道,传输等模式, 调用具体模式输入函数对数据解封装，参看下面模式函数实现
</span><span class='line'>&#9;&#9;if (x-&gt;outer_mode-&gt;input(x, skb))
</span><span class='line'>&#9;&#9;&#9;goto drop;
</span><span class='line'>
</span><span class='line'>
</span><span class='line'>&#9;&#9;//如果是IPSEC通道模式，将decaps参数置1，否则表示是传输模式
</span><span class='line'>&#9;&#9;if (x-&gt;outer_mode-&gt;flags & XFRM_MODE_FLAG_TUNNEL) {
</span><span class='line'>&#9;&#9;&#9;decaps = 1;
</span><span class='line'>&#9;&#9;&#9;break;
</span><span class='line'>&#9;&#9;}
</span><span class='line'>&#9;&#9;//看内层协议是否还要继续解包, 不需要解时返回1, 需要解时返回0, 错误返回负数
</span><span class='line'>&#9;&#9;//协议类型可以多层封装的,比如用AH封装ESP, 就得先解完AH再解ESP
</span><span class='line'>&#9;&#9;err = xfrm_parse_spi(skb, nexthdr, &spi, &seq);
</span><span class='line'>&#9;&#9;if (err &lt; 0)
</span><span class='line'>&#9;&#9;&#9;goto drop;
</span><span class='line'>&#9;} while (!err);
</span><span class='line'>
</span><span class='line'>&#9;/* Allocate new secpath or COW existing one. */
</span><span class='line'>&#9;// 为skb包建立新的安全路径(struct sec_path)
</span><span class='line'>&#9;if (!skb-&gt;sp || atomic_read(&skb-&gt;sp-&gt;refcnt) != 1) {
</span><span class='line'>&#9;&#9;struct sec_path *sp;
</span><span class='line'>&#9;&#9;sp = secpath_dup(skb-&gt;sp);
</span><span class='line'>&#9;&#9;if (!sp)
</span><span class='line'>&#9;&#9;&#9;goto drop;
</span><span class='line'>
</span><span class='line'>&#9;&#9;if (skb-&gt;sp)
</span><span class='line'>&#9;&#9;&#9;secpath_put(skb-&gt;sp);
</span><span class='line'>
</span><span class='line'>&#9;&#9;skb-&gt;sp = sp;
</span><span class='line'>&#9;}
</span><span class='line'>&#9;if (xfrm_nr + skb-&gt;sp-&gt;len &gt; XFRM_MAX_DEPTH)
</span><span class='line'>&#9;&#9;goto drop;
</span><span class='line'>
</span><span class='line'>&#9;//将刚才循环解包用到的SA拷贝到安全路径
</span><span class='line'>&#9;//因此检查一个数据包是否是普通明文包还是解密后的明文包就看skb-&gt;sp参数是否为空
</span><span class='line'>&#9;memcpy(skb-&gt;sp-&gt;xvec + skb-&gt;sp-&gt;len, xfrm_vec, xfrm_nr * sizeof(xfrm_vec[0]));
</span><span class='line'>&#9;skb-&gt;sp-&gt;len += xfrm_nr;
</span><span class='line'>
</span><span class='line'>&#9;nf_reset(skb); //去掉ip_conntrack和bridge
</span><span class='line'>&#9;if (decaps) {//通道模式，IPIP协议
</span><span class='line'>&#9;&#9;dst_release(skb-&gt;dst); //去掉路由缓存
</span><span class='line'>&#9;&#9;skb-&gt;dst = NULL;
</span><span class='line'>&#9;&#9;netif_rx(skb); //重新进入网卡接收函数
</span><span class='line'>&#9;&#9;return 0;
</span><span class='line'>&#9;} else { //传输模式
</span><span class='line'>#ifdef CONFIG_NETFILTER
</span><span class='line'>&#9;&#9;//如果定义NETFILTER, 进入PRE_ROUTING链处理,然后进入路由选择处理，其实现在已经处于INPUT点,
</span><span class='line'>&#9;&#9;//但解码后需要将该包作为一个新包看待。可能需要进行目的NAT操作, 这时候可能目的地址就会改变不是到自身的了,
</span><span class='line'>&#9;&#9;//因此需要将其相当于是放回PRE_PROUTING点去操作, 重新找路由.
</span><span class='line'>&#9;&#9;//这也说明可以制定针对解码后明文包的NAT规则,在还是加密包的时候不匹配但解码后能匹配上
</span><span class='line'>&#9;&#9;__skb_push(skb, skb-&gt;data - skb_network_header(skb));
</span><span class='line'>&#9;&#9;ip_hdr(skb)-&gt;tot_len = htons(skb-&gt;len);
</span><span class='line'>&#9;&#9;ip_send_check(ip_hdr(skb));
</span><span class='line'>
</span><span class='line'>&#9;&#9;NF_HOOK(PF_INET, NF_IP_PRE_ROUTING, skb, skb-&gt;dev, NULL, xfrm4_rcv_encap_finish);
</span><span class='line'>&#9;&#9;return 0;
</span><span class='line'>#else
</span><span class='line'>&#9;&#9;//内核不支持NETFILTER, 该包肯定就是到自身的了。返回IP协议的负值, 表示重新进行IP层协议的处理
</span><span class='line'>&#9;&#9;//用解码后的内层协议来处理数据，具体看ip_local_deliver_finish函数实现
</span><span class='line'>&#9;&#9;return -ip_hdr(skb)-&gt;protocol;
</span><span class='line'>#endif
</span><span class='line'>&#9;}
</span><span class='line'>drop_unlock:
</span><span class='line'>&#9;spin_unlock(&x-&gt;lock);
</span><span class='line'>&#9;xfrm_state_put(x);
</span><span class='line'>drop:
</span><span class='line'>&#9;while (--xfrm_nr &gt;= 0)
</span><span class='line'>&#9;&#9;xfrm_state_put(xfrm_vec[xfrm_nr]);
</span><span class='line'>
</span><span class='line'>&#9;kfree_skb(skb);
</span><span class='line'>&#9;return 0;
</span><span class='line'>}
</span><span class='line'>解析AH,ESP数据包中的SPI和序号，返回值是网络序的
</span><span class='line'>int xfrm_parse_spi(struct sk_buff *skb, u8 nexthdr, __be32 *spi, __be32 *seq)
</span><span class='line'>{
</span><span class='line'>&#9;int offset, offset_seq;
</span><span class='line'>&#9;int hlen;
</span><span class='line'>&#9;//通过nexthdr参数来判断协议类型, nexthdr是IPV6里的说法, 在IPV4中就是IP头里的协议字段
</span><span class='line'>&#9;//根据不同协议确定数据中SPI和序列号相对数据起始点的偏移
</span><span class='line'>&#9;switch (nexthdr) {
</span><span class='line'>&#9;&#9;case IPPROTO_AH:
</span><span class='line'>&#9;&#9;&#9;hlen = sizeof(struct ip_auth_hdr);
</span><span class='line'>&#9;&#9;&#9;offset = offsetof(struct ip_auth_hdr, spi);
</span><span class='line'>&#9;&#9;&#9;offset_seq = offsetof(struct ip_auth_hdr, seq_no);
</span><span class='line'>&#9;&#9;&#9;break;
</span><span class='line'>&#9;&#9;case IPPROTO_ESP:
</span><span class='line'>&#9;&#9;&#9;hlen = sizeof(struct ip_esp_hdr);
</span><span class='line'>&#9;&#9;&#9;offset = offsetof(struct ip_esp_hdr, spi);
</span><span class='line'>&#9;&#9;&#9;offset_seq = offsetof(struct ip_esp_hdr, seq_no);
</span><span class='line'>&#9;&#9;&#9;break;
</span><span class='line'>&#9;&#9;case IPPROTO_COMP:
</span><span class='line'>&#9;&#9;&#9;if (!pskb_may_pull(skb, sizeof(struct ip_comp_hdr)))
</span><span class='line'>&#9;&#9;&#9;&#9;return -EINVAL;
</span><span class='line'>
</span><span class='line'>&#9;&#9;&#9;//SPI值取第3,4字节的数据, 序号为0
</span><span class='line'>&#9;&#9;&#9;*spi = htonl(ntohs(*(__be16*)(skb_transport_header(skb) + 2)));
</span><span class='line'>&#9;&#9;&#9;*seq = 0;
</span><span class='line'>&#9;&#9;&#9;return 0;
</span><span class='line'>&#9;&#9;default:
</span><span class='line'>&#9;&#9;&#9;return 1;
</span><span class='line'>&#9;}
</span><span class='line'>&#9;if (!pskb_may_pull(skb, hlen))
</span><span class='line'>&#9;&#9;return -EINVAL;
</span><span class='line'>&#9;//根据偏移获取SPI和序号, 注意是网络序的值
</span><span class='line'>&#9;*spi = *(__be32*)(skb_transport_header(skb) + offset);
</span><span class='line'>&#9;*seq = *(__be32*)(skb_transport_header(skb) + offset_seq);
</span><span class='line'>&#9;return 0;
</span><span class='line'>}
</span><span class='line'>&#9;根据SPI进行HASH后查找
</span><span class='line'>static struct xfrm_state *__xfrm_state_lookup(xfrm_address_t *daddr, __be32 spi, u8 proto, unsigned short family)
</span><span class='line'>{
</span><span class='line'>&#9;unsigned int h = xfrm_spi_hash(daddr, spi, proto, family);//根据SPI进行HASH
</span><span class='line'>&#9;struct xfrm_state *x;
</span><span class='line'>&#9;struct hlist_node *entry;
</span><span class='line'>
</span><span class='line'>&#9;//循环相应的SPI链表
</span><span class='line'>&#9;hlist_for_each_entry(x, entry, xfrm_state_byspi+h, byspi) {
</span><span class='line'>&#9;&#9;//比较协议族, SPI, 和协议是否相同
</span><span class='line'>&#9;&#9;if (x-&gt;props.family != family || x-&gt;id.spi != spi || x-&gt;id.proto != proto)
</span><span class='line'>&#9;&#9;&#9;continue;
</span><span class='line'>
</span><span class='line'>&#9;&#9;switch (family) { //比较目的地址是否相同
</span><span class='line'>&#9;&#9;&#9;case AF_INET:
</span><span class='line'>&#9;&#9;&#9;&#9;if (x-&gt;id.daddr.a4 != daddr-&gt;a4)
</span><span class='line'>&#9;&#9;&#9;&#9;&#9;continue;
</span><span class='line'>&#9;&#9;&#9;&#9;break;
</span><span class='line'>&#9;&#9;&#9;case AF_INET6:
</span><span class='line'>&#9;&#9;&#9;&#9;if (!ipv6_addr_equal((struct in6_addr *)daddr, (struct in6_addr *)x-&gt;id.daddr.a6))
</span><span class='line'>&#9;&#9;&#9;&#9;&#9;continue;
</span><span class='line'>&#9;&#9;&#9;&#9;break;
</span><span class='line'>&#9;&#9;}
</span><span class='line'>&#9;&#9;xfrm_state_hold(x);
</span><span class='line'>&#9;&#9;return x;
</span><span class='line'>&#9;}
</span><span class='line'>}
</span><span class='line'>static inline int xfrm4_rcv_encap_finish(struct sk_buff *skb)
</span><span class='line'>{
</span><span class='line'>&#9;//如果没有路由, 重新查找路由
</span><span class='line'>&#9;if (skb-&gt;dst == NULL) {
</span><span class='line'>&#9;&#9;const struct iphdr *iph = ip_hdr(skb);
</span><span class='line'>&#9;&#9;if (ip_route_input(skb, iph-&gt;daddr, iph-&gt;saddr, iph-&gt;tos, skb-&gt;dev))
</span><span class='line'>&#9;&#9;&#9;goto drop;
</span><span class='line'>&#9;}
</span><span class='line'>&#9;//调用相关的路由输入函数
</span><span class='line'>&#9;return dst_input(skb);
</span><span class='line'>drop:
</span><span class='line'>&#9;kfree_skb(skb);
</span><span class='line'>&#9;return NET_RX_DROP;
</span><span class='line'>}</span></code></pre></td></tr></table></div></figure>


<p>[数据发送]</p>

<p>IPV4的IPSEC数据发送处理在net/ipv4/xfrm4_output.c中定义,作为安全路由的输出函数.</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
<span class='line-number'>16</span>
<span class='line-number'>17</span>
<span class='line-number'>18</span>
<span class='line-number'>19</span>
<span class='line-number'>20</span>
<span class='line-number'>21</span>
<span class='line-number'>22</span>
<span class='line-number'>23</span>
<span class='line-number'>24</span>
<span class='line-number'>25</span>
<span class='line-number'>26</span>
<span class='line-number'>27</span>
<span class='line-number'>28</span>
<span class='line-number'>29</span>
<span class='line-number'>30</span>
<span class='line-number'>31</span>
<span class='line-number'>32</span>
<span class='line-number'>33</span>
<span class='line-number'>34</span>
<span class='line-number'>35</span>
<span class='line-number'>36</span>
<span class='line-number'>37</span>
<span class='line-number'>38</span>
<span class='line-number'>39</span>
<span class='line-number'>40</span>
<span class='line-number'>41</span>
<span class='line-number'>42</span>
<span class='line-number'>43</span>
<span class='line-number'>44</span>
<span class='line-number'>45</span>
<span class='line-number'>46</span>
<span class='line-number'>47</span>
<span class='line-number'>48</span>
<span class='line-number'>49</span>
<span class='line-number'>50</span>
<span class='line-number'>51</span>
<span class='line-number'>52</span>
<span class='line-number'>53</span>
<span class='line-number'>54</span>
<span class='line-number'>55</span>
<span class='line-number'>56</span>
<span class='line-number'>57</span>
<span class='line-number'>58</span>
<span class='line-number'>59</span>
<span class='line-number'>60</span>
<span class='line-number'>61</span>
<span class='line-number'>62</span>
<span class='line-number'>63</span>
<span class='line-number'>64</span>
<span class='line-number'>65</span>
<span class='line-number'>66</span>
<span class='line-number'>67</span>
<span class='line-number'>68</span>
<span class='line-number'>69</span>
<span class='line-number'>70</span>
<span class='line-number'>71</span>
<span class='line-number'>72</span>
<span class='line-number'>73</span>
<span class='line-number'>74</span>
<span class='line-number'>75</span>
<span class='line-number'>76</span>
<span class='line-number'>77</span>
<span class='line-number'>78</span>
<span class='line-number'>79</span>
<span class='line-number'>80</span>
<span class='line-number'>81</span>
<span class='line-number'>82</span>
<span class='line-number'>83</span>
<span class='line-number'>84</span>
<span class='line-number'>85</span>
<span class='line-number'>86</span>
<span class='line-number'>87</span>
<span class='line-number'>88</span>
<span class='line-number'>89</span>
<span class='line-number'>90</span>
<span class='line-number'>91</span>
<span class='line-number'>92</span>
<span class='line-number'>93</span>
<span class='line-number'>94</span>
<span class='line-number'>95</span>
<span class='line-number'>96</span>
<span class='line-number'>97</span>
<span class='line-number'>98</span>
<span class='line-number'>99</span>
<span class='line-number'>100</span>
<span class='line-number'>101</span>
<span class='line-number'>102</span>
<span class='line-number'>103</span>
<span class='line-number'>104</span>
<span class='line-number'>105</span>
<span class='line-number'>106</span>
<span class='line-number'>107</span>
<span class='line-number'>108</span>
<span class='line-number'>109</span>
<span class='line-number'>110</span>
<span class='line-number'>111</span>
<span class='line-number'>112</span>
<span class='line-number'>113</span>
<span class='line-number'>114</span>
<span class='line-number'>115</span>
<span class='line-number'>116</span>
<span class='line-number'>117</span>
<span class='line-number'>118</span>
<span class='line-number'>119</span>
<span class='line-number'>120</span>
<span class='line-number'>121</span>
<span class='line-number'>122</span>
<span class='line-number'>123</span>
<span class='line-number'>124</span>
<span class='line-number'>125</span>
<span class='line-number'>126</span>
<span class='line-number'>127</span>
<span class='line-number'>128</span>
<span class='line-number'>129</span>
<span class='line-number'>130</span>
<span class='line-number'>131</span>
<span class='line-number'>132</span>
<span class='line-number'>133</span>
<span class='line-number'>134</span>
<span class='line-number'>135</span>
<span class='line-number'>136</span>
<span class='line-number'>137</span>
<span class='line-number'>138</span>
<span class='line-number'>139</span>
<span class='line-number'>140</span>
<span class='line-number'>141</span>
<span class='line-number'>142</span>
<span class='line-number'>143</span>
<span class='line-number'>144</span>
<span class='line-number'>145</span>
<span class='line-number'>146</span>
<span class='line-number'>147</span>
<span class='line-number'>148</span>
<span class='line-number'>149</span>
<span class='line-number'>150</span>
<span class='line-number'>151</span>
<span class='line-number'>152</span>
<span class='line-number'>153</span>
<span class='line-number'>154</span>
<span class='line-number'>155</span>
<span class='line-number'>156</span>
<span class='line-number'>157</span>
<span class='line-number'>158</span>
<span class='line-number'>159</span>
<span class='line-number'>160</span>
<span class='line-number'>161</span>
<span class='line-number'>162</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>dst_output -&gt; xfrm_dst-&gt;route-&gt;output == xfrm4_output
</span><span class='line'>int xfrm4_output(struct sk_buff *skb)
</span><span class='line'>{
</span><span class='line'>&#9;//就是一个条件HOOK, 当skb包不带IPSKB_REROUTED标志时进入POSTROUTING点的NAT操作
</span><span class='line'>&#9;//这是数据在xfrm策略中多个bundle时会多次调用, 也就是数据在封装完成前可以进行源NAT操作
</span><span class='line'>&#9;//HOOK出口函数为xfrm4_output_finish
</span><span class='line'>&#9;return NF_HOOK_COND(PF_INET, NF_IP_POST_ROUTING, skb, NULL, skb-&gt;dst-&gt;dev,
</span><span class='line'>&#9;&#9;&#9;xfrm4_output_finish, !(IPCB(skb)-&gt;flags & IPSKB_REROUTED));
</span><span class='line'>}
</span><span class='line'>&#9;发送结束处理
</span><span class='line'>static int xfrm4_output_finish(struct sk_buff *skb)
</span><span class='line'>{
</span><span class='line'>&#9;struct sk_buff *segs;
</span><span class='line'>#ifdef CONFIG_NETFILTER
</span><span class='line'>&#9;//如果内核定义了NETFILTER, 当到达最后一个路由(普通路由)时, 设置IPSKB_REROUTED标志,
</span><span class='line'>&#9;//进行普通路由发出函数(ip_output), 设置该标志后不进行源NAT操作
</span><span class='line'>&#9;if (!skb-&gt;dst-&gt;xfrm) {
</span><span class='line'>&#9;&#9;IPCB(skb)-&gt;flags |= IPSKB_REROUTED;
</span><span class='line'>&#9;&#9;return dst_output(skb);
</span><span class='line'>&#9;}
</span><span class='line'>#endif
</span><span class='line'>&#9;//如果skb包不是是gso, 转xfrm4_output_finish2
</span><span class='line'>&#9;if (!skb_is_gso(skb))
</span><span class='line'>&#9;&#9;return xfrm4_output_finish2(skb);
</span><span class='line'>&#9;//处理gso数据包, 最终也是使用xfrm4_output_finish2处理数据包
</span><span class='line'>&#9;skb-&gt;protocol = htons(ETH_P_IP);
</span><span class='line'>&#9;segs = skb_gso_segment(skb, 0);
</span><span class='line'>&#9;kfree_skb(skb);
</span><span class='line'>&#9;if (unlikely(IS_ERR(segs)))
</span><span class='line'>&#9;&#9;return PTR_ERR(segs);
</span><span class='line'>&#9;do { //循环发送
</span><span class='line'>&#9;&#9;struct sk_buff *nskb = segs-&gt;next;
</span><span class='line'>&#9;&#9;int err;
</span><span class='line'>&#9;&#9;segs-&gt;next = NULL;
</span><span class='line'>&#9;&#9;err = xfrm4_output_finish2(segs);
</span><span class='line'>
</span><span class='line'>&#9;&#9;if (unlikely(err)) {
</span><span class='line'>&#9;&#9;&#9;while ((segs = nskb)) {
</span><span class='line'>&#9;&#9;&#9;&#9;nskb = segs-&gt;next;
</span><span class='line'>&#9;&#9;&#9;&#9;segs-&gt;next = NULL;
</span><span class='line'>&#9;&#9;&#9;&#9;kfree_skb(segs);
</span><span class='line'>&#9;&#9;&#9;}
</span><span class='line'>&#9;&#9;&#9;return err;
</span><span class='line'>&#9;&#9;}
</span><span class='line'>&#9;&#9;segs = nskb;
</span><span class='line'>&#9;} while (segs);
</span><span class='line'>&#9;return 0;
</span><span class='line'>}
</span><span class='line'>&#9;第2级发送结束处理
</span><span class='line'>static int xfrm4_output_finish2(struct sk_buff *skb)
</span><span class='line'>{
</span><span class='line'>&#9;int err;
</span><span class='line'>&#9;//根据安全路由包装要发送的数据
</span><span class='line'>&#9;while (likely((err = xfrm4_output_one(skb)) == 0)) {
</span><span class='line'>&#9;&#9;//处理成功，释放skb中的netfilter信息
</span><span class='line'>&#9;&#9;nf_reset(skb);
</span><span class='line'>&#9;&#9;//重新将该包作为初始发送包, 进入OUTPUT点处理, 注意这是个函数而不是宏
</span><span class='line'>&#9;&#9;//如果内核没定义NETFILTER, 该函数只是个空函数
</span><span class='line'>&#9;&#9;//返回1表示NF_ACCEPT
</span><span class='line'>&#9;&#9;err = nf_hook(PF_INET, NF_IP_LOCAL_OUT, skb, NULL, skb-&gt;dst-&gt;dev, dst_output);
</span><span class='line'>&#9;&#9;if (unlikely(err != 1))
</span><span class='line'>&#9;&#9;&#9;break;
</span><span class='line'>
</span><span class='line'>&#9;&#9;//如果已经没有SA, 就只是个普通包了, 路由发送(ip_output)返回, 退出循环
</span><span class='line'>&#9;&#9;if (!skb-&gt;dst-&gt;xfrm)
</span><span class='line'>&#9;&#9;&#9;return dst_output(skb);
</span><span class='line'>
</span><span class='line'>&#9;&#9;//如果还有SA, 目前还只是中间状态, 还可以进行SNAT操作, 进入POSTROUTING点处理
</span><span class='line'>&#9;&#9;err = nf_hook(PF_INET, NF_IP_POST_ROUTING, skb, NULL,  skb-&gt;dst-&gt;dev, xfrm4_output_finish2);
</span><span class='line'>&#9;&#9;if (unlikely(err != 1))
</span><span class='line'>&#9;&#9;&#9;break;
</span><span class='line'>&#9;}
</span><span class='line'>&#9;return err;
</span><span class='line'>}
</span><span class='line'>按安全路由链表的安全路由处理数据, 该链表反映了多个SA对数据包进行处理
</span><span class='line'>&#9;链表是在__xfrm4_bundle_create函数中建立的.
</span><span class='line'>static inline int xfrm4_output_one(struct sk_buff *skb)
</span><span class='line'>{
</span><span class='line'>&#9;struct dst_entry *dst = skb-&gt;dst; //安全路由
</span><span class='line'>&#9;struct xfrm_state *x = dst-&gt;xfrm;//相关SA
</span><span class='line'>&#9;struct iphdr *iph;
</span><span class='line'>&#9;int err;
</span><span class='line'>
</span><span class='line'>&#9;//如果是通道模式, 检查skb数据长度, 并进行相关处理,
</span><span class='line'>&#9;//通道模式下封装后的数据包长度可能会超过1500字节的
</span><span class='line'>&#9;if (x-&gt;outer_mode-&gt;flags & XFRM_MODE_FLAG_TUNNEL) {
</span><span class='line'>&#9;&#9;err = xfrm4_tunnel_check_size(skb);
</span><span class='line'>&#9;&#9;if (err)
</span><span class='line'>&#9;&#9;&#9;goto error_nolock;
</span><span class='line'>&#9;}
</span><span class='line'>&#9;err = xfrm_output(skb); //具体封装
</span><span class='line'>&#9;if (err)
</span><span class='line'>&#9;&#9;goto error_nolock;
</span><span class='line'>
</span><span class='line'>&#9;iph = ip_hdr(skb);
</span><span class='line'>&#9;iph-&gt;tot_len = htons(skb-&gt;len); //最新的长度
</span><span class='line'>&#9;ip_send_check(iph); //重新计算效验和
</span><span class='line'>
</span><span class='line'>&#9;//skb中设置IPSKB_XFRM_TRANSFORMED标志
</span><span class='line'>&#9;//有该标志的数据包NAT操作后将不进行一些特殊检查
</span><span class='line'>&#9;IPCB(skb)-&gt;flags |= IPSKB_XFRM_TRANSFORMED;
</span><span class='line'>&#9;err = 0;
</span><span class='line'>out_exit:
</span><span class='line'>&#9;return err;
</span><span class='line'>error_nolock:
</span><span class='line'>&#9;kfree_skb(skb);
</span><span class='line'>&#9;goto out_exit;
</span><span class='line'>}
</span><span class='line'>int xfrm_output(struct sk_buff *skb)
</span><span class='line'>{
</span><span class='line'>&#9;struct dst_entry *dst = skb-&gt;dst;
</span><span class='line'>&#9;struct xfrm_state *x = dst-&gt;xfrm;
</span><span class='line'>&#9;int err;
</span><span class='line'>&#9;//skb包校验和计算
</span><span class='line'>&#9;if (skb-&gt;ip_summed == CHECKSUM_PARTIAL) {
</span><span class='line'>&#9;&#9;err = skb_checksum_help(skb);
</span><span class='line'>&#9;&#9;if (err)
</span><span class='line'>&#9;&#9;&#9;goto error_nolock;
</span><span class='line'>&#9;}
</span><span class='line'>&#9;do {
</span><span class='line'>&#9;&#9;spin_lock_bh(&x-&gt;lock);
</span><span class='line'>&#9;&#9;err = xfrm_state_check(x, skb);//SA合法性检查
</span><span class='line'>&#9;&#9;if (err)
</span><span class='line'>&#9;&#9;&#9;goto error;
</span><span class='line'>
</span><span class='line'>&#9;&#9;if (x-&gt;type-&gt;flags & XFRM_TYPE_REPLAY_PROT) {
</span><span class='line'>&#9;&#9;&#9;XFRM_SKB_CB(skb)-&gt;seq = ++x-&gt;replay.oseq;
</span><span class='line'>&#9;&#9;&#9;if (xfrm_aevent_is_on())
</span><span class='line'>&#9;&#9;&#9;&#9;xfrm_replay_notify(x, XFRM_REPLAY_UPDATE);
</span><span class='line'>
</span><span class='line'>&#9;&#9;}
</span><span class='line'>&#9;&#9;err = x-&gt;outer_mode-&gt;output(x, skb);//调用模式输出函数, 如通道封装时外部IP头协议为IPIP，参考下面模式函数实现
</span><span class='line'>&#9;&#9;if (err)
</span><span class='line'>&#9;&#9;&#9;goto error;
</span><span class='line'>
</span><span class='line'>&#9;&#9;//更新SA中的当前生命期结构中的包和字节计数
</span><span class='line'>&#9;&#9;x-&gt;curlft.bytes += skb-&gt;len;
</span><span class='line'>&#9;&#9;x-&gt;curlft.packets++;
</span><span class='line'>&#9;&#9;spin_unlock_bh(&x-&gt;lock);
</span><span class='line'>
</span><span class='line'>&#9;&#9;//调用协议输出, 如对应ESP协议来说是esp4_output, 此时外部IP头协议会改为ESP，参考下面具体协议实现
</span><span class='line'>&#9;&#9;err = x-&gt;type-&gt;output(x, skb);
</span><span class='line'>&#9;&#9;if (err)
</span><span class='line'>&#9;&#9;&#9;goto error_nolock;
</span><span class='line'>
</span><span class='line'>&#9;&#9;//转移到下一个子路由
</span><span class='line'>&#9;&#9;if (!(skb-&gt;dst = dst_pop(dst))) {
</span><span class='line'>&#9;&#9;&#9;err = -EHOSTUNREACH;
</span><span class='line'>&#9;&#9;&#9;goto error_nolock;
</span><span class='line'>&#9;&#9;}
</span><span class='line'>&#9;&#9;//dst和x参数更新为子路由中的安全路由和SA
</span><span class='line'>&#9;&#9;dst = skb-&gt;dst;
</span><span class='line'>&#9;&#9;x = dst-&gt;xfrm;
</span><span class='line'>&#9;} while (x && !(x-&gt;outer_mode-&gt;flags & XFRM_MODE_FLAG_TUNNEL));//循环条件是SA非空, 而且SA模式不是通道模式
</span><span class='line'>
</span><span class='line'>&#9;err = 0;
</span><span class='line'>error_nolock:
</span><span class='line'>&#9;return err;
</span><span class='line'>error:
</span><span class='line'>&#9;spin_unlock_bh(&x-&gt;lock);
</span><span class='line'>&#9;goto error_nolock;
</span><span class='line'>}</span></code></pre></td></tr></table></div></figure>


<p>[具体协议实现]</p>

<p>与IPSEC相关的安全协议是AH(51)和ESP(50), IPSEC使用这两个协议对普通数据包进行封装, AH只认证不加密, ESP既加密又认证,
当ESP和AH同时使用时, 一般都是先进行ESP封装, 再进行AH封装, 因为AH是对整个IP包进行验证的, 而ESP只验证负载部分.</p>

<p>具体的协议结构定义如下, 通常只定义初始化,析构,输入和输出四个成员函数.</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
<span class='line-number'>16</span>
<span class='line-number'>17</span>
<span class='line-number'>18</span>
<span class='line-number'>19</span>
<span class='line-number'>20</span>
<span class='line-number'>21</span>
<span class='line-number'>22</span>
<span class='line-number'>23</span>
<span class='line-number'>24</span>
<span class='line-number'>25</span>
<span class='line-number'>26</span>
<span class='line-number'>27</span>
<span class='line-number'>28</span>
<span class='line-number'>29</span>
<span class='line-number'>30</span>
<span class='line-number'>31</span>
<span class='line-number'>32</span>
<span class='line-number'>33</span>
<span class='line-number'>34</span>
<span class='line-number'>35</span>
<span class='line-number'>36</span>
<span class='line-number'>37</span>
<span class='line-number'>38</span>
<span class='line-number'>39</span>
<span class='line-number'>40</span>
<span class='line-number'>41</span>
<span class='line-number'>42</span>
<span class='line-number'>43</span>
<span class='line-number'>44</span>
<span class='line-number'>45</span>
<span class='line-number'>46</span>
<span class='line-number'>47</span>
<span class='line-number'>48</span>
<span class='line-number'>49</span>
<span class='line-number'>50</span>
<span class='line-number'>51</span>
<span class='line-number'>52</span>
<span class='line-number'>53</span>
<span class='line-number'>54</span>
<span class='line-number'>55</span>
<span class='line-number'>56</span>
<span class='line-number'>57</span>
<span class='line-number'>58</span>
<span class='line-number'>59</span>
<span class='line-number'>60</span>
<span class='line-number'>61</span>
<span class='line-number'>62</span>
<span class='line-number'>63</span>
<span class='line-number'>64</span>
<span class='line-number'>65</span>
<span class='line-number'>66</span>
<span class='line-number'>67</span>
<span class='line-number'>68</span>
<span class='line-number'>69</span>
<span class='line-number'>70</span>
<span class='line-number'>71</span>
<span class='line-number'>72</span>
<span class='line-number'>73</span>
<span class='line-number'>74</span>
<span class='line-number'>75</span>
<span class='line-number'>76</span>
<span class='line-number'>77</span>
<span class='line-number'>78</span>
<span class='line-number'>79</span>
<span class='line-number'>80</span>
<span class='line-number'>81</span>
<span class='line-number'>82</span>
<span class='line-number'>83</span>
<span class='line-number'>84</span>
<span class='line-number'>85</span>
<span class='line-number'>86</span>
<span class='line-number'>87</span>
<span class='line-number'>88</span>
<span class='line-number'>89</span>
<span class='line-number'>90</span>
<span class='line-number'>91</span>
<span class='line-number'>92</span>
<span class='line-number'>93</span>
<span class='line-number'>94</span>
<span class='line-number'>95</span>
<span class='line-number'>96</span>
<span class='line-number'>97</span>
<span class='line-number'>98</span>
<span class='line-number'>99</span>
<span class='line-number'>100</span>
<span class='line-number'>101</span>
<span class='line-number'>102</span>
<span class='line-number'>103</span>
<span class='line-number'>104</span>
<span class='line-number'>105</span>
<span class='line-number'>106</span>
<span class='line-number'>107</span>
<span class='line-number'>108</span>
<span class='line-number'>109</span>
<span class='line-number'>110</span>
<span class='line-number'>111</span>
<span class='line-number'>112</span>
<span class='line-number'>113</span>
<span class='line-number'>114</span>
<span class='line-number'>115</span>
<span class='line-number'>116</span>
<span class='line-number'>117</span>
<span class='line-number'>118</span>
<span class='line-number'>119</span>
<span class='line-number'>120</span>
<span class='line-number'>121</span>
<span class='line-number'>122</span>
<span class='line-number'>123</span>
<span class='line-number'>124</span>
<span class='line-number'>125</span>
<span class='line-number'>126</span>
<span class='line-number'>127</span>
<span class='line-number'>128</span>
<span class='line-number'>129</span>
<span class='line-number'>130</span>
<span class='line-number'>131</span>
<span class='line-number'>132</span>
<span class='line-number'>133</span>
<span class='line-number'>134</span>
<span class='line-number'>135</span>
<span class='line-number'>136</span>
<span class='line-number'>137</span>
<span class='line-number'>138</span>
<span class='line-number'>139</span>
<span class='line-number'>140</span>
<span class='line-number'>141</span>
<span class='line-number'>142</span>
<span class='line-number'>143</span>
<span class='line-number'>144</span>
<span class='line-number'>145</span>
<span class='line-number'>146</span>
<span class='line-number'>147</span>
<span class='line-number'>148</span>
<span class='line-number'>149</span>
<span class='line-number'>150</span>
<span class='line-number'>151</span>
<span class='line-number'>152</span>
<span class='line-number'>153</span>
<span class='line-number'>154</span>
<span class='line-number'>155</span>
<span class='line-number'>156</span>
<span class='line-number'>157</span>
<span class='line-number'>158</span>
<span class='line-number'>159</span>
<span class='line-number'>160</span>
<span class='line-number'>161</span>
<span class='line-number'>162</span>
<span class='line-number'>163</span>
<span class='line-number'>164</span>
<span class='line-number'>165</span>
<span class='line-number'>166</span>
<span class='line-number'>167</span>
<span class='line-number'>168</span>
<span class='line-number'>169</span>
<span class='line-number'>170</span>
<span class='line-number'>171</span>
<span class='line-number'>172</span>
<span class='line-number'>173</span>
<span class='line-number'>174</span>
<span class='line-number'>175</span>
<span class='line-number'>176</span>
<span class='line-number'>177</span>
<span class='line-number'>178</span>
<span class='line-number'>179</span>
<span class='line-number'>180</span>
<span class='line-number'>181</span>
<span class='line-number'>182</span>
<span class='line-number'>183</span>
<span class='line-number'>184</span>
<span class='line-number'>185</span>
<span class='line-number'>186</span>
<span class='line-number'>187</span>
<span class='line-number'>188</span>
<span class='line-number'>189</span>
<span class='line-number'>190</span>
<span class='line-number'>191</span>
<span class='line-number'>192</span>
<span class='line-number'>193</span>
<span class='line-number'>194</span>
<span class='line-number'>195</span>
<span class='line-number'>196</span>
<span class='line-number'>197</span>
<span class='line-number'>198</span>
<span class='line-number'>199</span>
<span class='line-number'>200</span>
<span class='line-number'>201</span>
<span class='line-number'>202</span>
<span class='line-number'>203</span>
<span class='line-number'>204</span>
<span class='line-number'>205</span>
<span class='line-number'>206</span>
<span class='line-number'>207</span>
<span class='line-number'>208</span>
<span class='line-number'>209</span>
<span class='line-number'>210</span>
<span class='line-number'>211</span>
<span class='line-number'>212</span>
<span class='line-number'>213</span>
<span class='line-number'>214</span>
<span class='line-number'>215</span>
<span class='line-number'>216</span>
<span class='line-number'>217</span>
<span class='line-number'>218</span>
<span class='line-number'>219</span>
<span class='line-number'>220</span>
<span class='line-number'>221</span>
<span class='line-number'>222</span>
<span class='line-number'>223</span>
<span class='line-number'>224</span>
<span class='line-number'>225</span>
<span class='line-number'>226</span>
<span class='line-number'>227</span>
<span class='line-number'>228</span>
<span class='line-number'>229</span>
<span class='line-number'>230</span>
<span class='line-number'>231</span>
<span class='line-number'>232</span>
<span class='line-number'>233</span>
<span class='line-number'>234</span>
<span class='line-number'>235</span>
<span class='line-number'>236</span>
<span class='line-number'>237</span>
<span class='line-number'>238</span>
<span class='line-number'>239</span>
<span class='line-number'>240</span>
<span class='line-number'>241</span>
<span class='line-number'>242</span>
<span class='line-number'>243</span>
<span class='line-number'>244</span>
<span class='line-number'>245</span>
<span class='line-number'>246</span>
<span class='line-number'>247</span>
<span class='line-number'>248</span>
<span class='line-number'>249</span>
<span class='line-number'>250</span>
<span class='line-number'>251</span>
<span class='line-number'>252</span>
<span class='line-number'>253</span>
<span class='line-number'>254</span>
<span class='line-number'>255</span>
<span class='line-number'>256</span>
<span class='line-number'>257</span>
<span class='line-number'>258</span>
<span class='line-number'>259</span>
<span class='line-number'>260</span>
<span class='line-number'>261</span>
<span class='line-number'>262</span>
<span class='line-number'>263</span>
<span class='line-number'>264</span>
<span class='line-number'>265</span>
<span class='line-number'>266</span>
<span class='line-number'>267</span>
<span class='line-number'>268</span>
<span class='line-number'>269</span>
<span class='line-number'>270</span>
<span class='line-number'>271</span>
<span class='line-number'>272</span>
<span class='line-number'>273</span>
<span class='line-number'>274</span>
<span class='line-number'>275</span>
<span class='line-number'>276</span>
<span class='line-number'>277</span>
<span class='line-number'>278</span>
<span class='line-number'>279</span>
<span class='line-number'>280</span>
<span class='line-number'>281</span>
<span class='line-number'>282</span>
<span class='line-number'>283</span>
<span class='line-number'>284</span>
<span class='line-number'>285</span>
<span class='line-number'>286</span>
<span class='line-number'>287</span>
<span class='line-number'>288</span>
<span class='line-number'>289</span>
<span class='line-number'>290</span>
<span class='line-number'>291</span>
<span class='line-number'>292</span>
<span class='line-number'>293</span>
<span class='line-number'>294</span>
<span class='line-number'>295</span>
<span class='line-number'>296</span>
<span class='line-number'>297</span>
<span class='line-number'>298</span>
<span class='line-number'>299</span>
<span class='line-number'>300</span>
<span class='line-number'>301</span>
<span class='line-number'>302</span>
<span class='line-number'>303</span>
<span class='line-number'>304</span>
<span class='line-number'>305</span>
<span class='line-number'>306</span>
<span class='line-number'>307</span>
<span class='line-number'>308</span>
<span class='line-number'>309</span>
<span class='line-number'>310</span>
<span class='line-number'>311</span>
<span class='line-number'>312</span>
<span class='line-number'>313</span>
<span class='line-number'>314</span>
<span class='line-number'>315</span>
<span class='line-number'>316</span>
<span class='line-number'>317</span>
<span class='line-number'>318</span>
<span class='line-number'>319</span>
<span class='line-number'>320</span>
<span class='line-number'>321</span>
<span class='line-number'>322</span>
<span class='line-number'>323</span>
<span class='line-number'>324</span>
<span class='line-number'>325</span>
<span class='line-number'>326</span>
<span class='line-number'>327</span>
<span class='line-number'>328</span>
<span class='line-number'>329</span>
<span class='line-number'>330</span>
<span class='line-number'>331</span>
<span class='line-number'>332</span>
<span class='line-number'>333</span>
<span class='line-number'>334</span>
<span class='line-number'>335</span>
<span class='line-number'>336</span>
<span class='line-number'>337</span>
<span class='line-number'>338</span>
<span class='line-number'>339</span>
<span class='line-number'>340</span>
<span class='line-number'>341</span>
<span class='line-number'>342</span>
<span class='line-number'>343</span>
<span class='line-number'>344</span>
<span class='line-number'>345</span>
<span class='line-number'>346</span>
<span class='line-number'>347</span>
<span class='line-number'>348</span>
<span class='line-number'>349</span>
<span class='line-number'>350</span>
<span class='line-number'>351</span>
<span class='line-number'>352</span>
<span class='line-number'>353</span>
<span class='line-number'>354</span>
<span class='line-number'>355</span>
<span class='line-number'>356</span>
<span class='line-number'>357</span>
<span class='line-number'>358</span>
<span class='line-number'>359</span>
<span class='line-number'>360</span>
<span class='line-number'>361</span>
<span class='line-number'>362</span>
<span class='line-number'>363</span>
<span class='line-number'>364</span>
<span class='line-number'>365</span>
<span class='line-number'>366</span>
<span class='line-number'>367</span>
<span class='line-number'>368</span>
<span class='line-number'>369</span>
<span class='line-number'>370</span>
<span class='line-number'>371</span>
<span class='line-number'>372</span>
<span class='line-number'>373</span>
<span class='line-number'>374</span>
<span class='line-number'>375</span>
<span class='line-number'>376</span>
<span class='line-number'>377</span>
<span class='line-number'>378</span>
<span class='line-number'>379</span>
<span class='line-number'>380</span>
<span class='line-number'>381</span>
<span class='line-number'>382</span>
<span class='line-number'>383</span>
<span class='line-number'>384</span>
<span class='line-number'>385</span>
<span class='line-number'>386</span>
<span class='line-number'>387</span>
<span class='line-number'>388</span>
<span class='line-number'>389</span>
<span class='line-number'>390</span>
<span class='line-number'>391</span>
<span class='line-number'>392</span>
<span class='line-number'>393</span>
<span class='line-number'>394</span>
<span class='line-number'>395</span>
<span class='line-number'>396</span>
<span class='line-number'>397</span>
<span class='line-number'>398</span>
<span class='line-number'>399</span>
<span class='line-number'>400</span>
<span class='line-number'>401</span>
<span class='line-number'>402</span>
<span class='line-number'>403</span>
<span class='line-number'>404</span>
<span class='line-number'>405</span>
<span class='line-number'>406</span>
<span class='line-number'>407</span>
<span class='line-number'>408</span>
<span class='line-number'>409</span>
<span class='line-number'>410</span>
<span class='line-number'>411</span>
<span class='line-number'>412</span>
<span class='line-number'>413</span>
<span class='line-number'>414</span>
<span class='line-number'>415</span>
<span class='line-number'>416</span>
<span class='line-number'>417</span>
<span class='line-number'>418</span>
<span class='line-number'>419</span>
<span class='line-number'>420</span>
<span class='line-number'>421</span>
<span class='line-number'>422</span>
<span class='line-number'>423</span>
<span class='line-number'>424</span>
<span class='line-number'>425</span>
<span class='line-number'>426</span>
<span class='line-number'>427</span>
<span class='line-number'>428</span>
<span class='line-number'>429</span>
<span class='line-number'>430</span>
<span class='line-number'>431</span>
<span class='line-number'>432</span>
<span class='line-number'>433</span>
<span class='line-number'>434</span>
<span class='line-number'>435</span>
<span class='line-number'>436</span>
<span class='line-number'>437</span>
<span class='line-number'>438</span>
<span class='line-number'>439</span>
<span class='line-number'>440</span>
<span class='line-number'>441</span>
<span class='line-number'>442</span>
<span class='line-number'>443</span>
<span class='line-number'>444</span>
<span class='line-number'>445</span>
<span class='line-number'>446</span>
<span class='line-number'>447</span>
<span class='line-number'>448</span>
<span class='line-number'>449</span>
<span class='line-number'>450</span>
<span class='line-number'>451</span>
<span class='line-number'>452</span>
<span class='line-number'>453</span>
<span class='line-number'>454</span>
<span class='line-number'>455</span>
<span class='line-number'>456</span>
<span class='line-number'>457</span>
<span class='line-number'>458</span>
<span class='line-number'>459</span>
<span class='line-number'>460</span>
<span class='line-number'>461</span>
<span class='line-number'>462</span>
<span class='line-number'>463</span>
<span class='line-number'>464</span>
<span class='line-number'>465</span>
<span class='line-number'>466</span>
<span class='line-number'>467</span>
<span class='line-number'>468</span>
<span class='line-number'>469</span>
<span class='line-number'>470</span>
<span class='line-number'>471</span>
<span class='line-number'>472</span>
<span class='line-number'>473</span>
<span class='line-number'>474</span>
<span class='line-number'>475</span>
<span class='line-number'>476</span>
<span class='line-number'>477</span>
<span class='line-number'>478</span>
<span class='line-number'>479</span>
<span class='line-number'>480</span>
<span class='line-number'>481</span>
<span class='line-number'>482</span>
<span class='line-number'>483</span>
<span class='line-number'>484</span>
<span class='line-number'>485</span>
<span class='line-number'>486</span>
<span class='line-number'>487</span>
<span class='line-number'>488</span>
<span class='line-number'>489</span>
<span class='line-number'>490</span>
<span class='line-number'>491</span>
<span class='line-number'>492</span>
<span class='line-number'>493</span>
<span class='line-number'>494</span>
<span class='line-number'>495</span>
<span class='line-number'>496</span>
<span class='line-number'>497</span>
<span class='line-number'>498</span>
<span class='line-number'>499</span>
<span class='line-number'>500</span>
<span class='line-number'>501</span>
<span class='line-number'>502</span>
<span class='line-number'>503</span>
<span class='line-number'>504</span>
<span class='line-number'>505</span>
<span class='line-number'>506</span>
<span class='line-number'>507</span>
<span class='line-number'>508</span>
<span class='line-number'>509</span>
<span class='line-number'>510</span>
<span class='line-number'>511</span>
<span class='line-number'>512</span>
<span class='line-number'>513</span>
<span class='line-number'>514</span>
<span class='line-number'>515</span>
<span class='line-number'>516</span>
<span class='line-number'>517</span>
<span class='line-number'>518</span>
<span class='line-number'>519</span>
<span class='line-number'>520</span>
<span class='line-number'>521</span>
<span class='line-number'>522</span>
<span class='line-number'>523</span>
<span class='line-number'>524</span>
<span class='line-number'>525</span>
<span class='line-number'>526</span>
<span class='line-number'>527</span>
<span class='line-number'>528</span>
<span class='line-number'>529</span>
<span class='line-number'>530</span>
<span class='line-number'>531</span>
<span class='line-number'>532</span>
<span class='line-number'>533</span>
<span class='line-number'>534</span>
<span class='line-number'>535</span>
<span class='line-number'>536</span>
<span class='line-number'>537</span>
<span class='line-number'>538</span>
<span class='line-number'>539</span>
<span class='line-number'>540</span>
<span class='line-number'>541</span>
<span class='line-number'>542</span>
<span class='line-number'>543</span>
<span class='line-number'>544</span>
<span class='line-number'>545</span>
<span class='line-number'>546</span>
<span class='line-number'>547</span>
<span class='line-number'>548</span>
<span class='line-number'>549</span>
<span class='line-number'>550</span>
<span class='line-number'>551</span>
<span class='line-number'>552</span>
<span class='line-number'>553</span>
<span class='line-number'>554</span>
<span class='line-number'>555</span>
<span class='line-number'>556</span>
<span class='line-number'>557</span>
<span class='line-number'>558</span>
<span class='line-number'>559</span>
<span class='line-number'>560</span>
<span class='line-number'>561</span>
<span class='line-number'>562</span>
<span class='line-number'>563</span>
<span class='line-number'>564</span>
<span class='line-number'>565</span>
<span class='line-number'>566</span>
<span class='line-number'>567</span>
<span class='line-number'>568</span>
<span class='line-number'>569</span>
<span class='line-number'>570</span>
<span class='line-number'>571</span>
<span class='line-number'>572</span>
<span class='line-number'>573</span>
<span class='line-number'>574</span>
<span class='line-number'>575</span>
<span class='line-number'>576</span>
<span class='line-number'>577</span>
<span class='line-number'>578</span>
<span class='line-number'>579</span>
<span class='line-number'>580</span>
<span class='line-number'>581</span>
<span class='line-number'>582</span>
<span class='line-number'>583</span>
<span class='line-number'>584</span>
<span class='line-number'>585</span>
<span class='line-number'>586</span>
<span class='line-number'>587</span>
<span class='line-number'>588</span>
<span class='line-number'>589</span>
<span class='line-number'>590</span>
<span class='line-number'>591</span>
<span class='line-number'>592</span>
<span class='line-number'>593</span>
<span class='line-number'>594</span>
<span class='line-number'>595</span>
<span class='line-number'>596</span>
<span class='line-number'>597</span>
<span class='line-number'>598</span>
<span class='line-number'>599</span>
<span class='line-number'>600</span>
<span class='line-number'>601</span>
<span class='line-number'>602</span>
<span class='line-number'>603</span>
<span class='line-number'>604</span>
<span class='line-number'>605</span>
<span class='line-number'>606</span>
<span class='line-number'>607</span>
<span class='line-number'>608</span>
<span class='line-number'>609</span>
<span class='line-number'>610</span>
<span class='line-number'>611</span>
<span class='line-number'>612</span>
<span class='line-number'>613</span>
<span class='line-number'>614</span>
<span class='line-number'>615</span>
<span class='line-number'>616</span>
<span class='line-number'>617</span>
<span class='line-number'>618</span>
<span class='line-number'>619</span>
<span class='line-number'>620</span>
<span class='line-number'>621</span>
<span class='line-number'>622</span>
<span class='line-number'>623</span>
<span class='line-number'>624</span>
<span class='line-number'>625</span>
<span class='line-number'>626</span>
<span class='line-number'>627</span>
<span class='line-number'>628</span>
<span class='line-number'>629</span>
<span class='line-number'>630</span>
<span class='line-number'>631</span>
<span class='line-number'>632</span>
<span class='line-number'>633</span>
<span class='line-number'>634</span>
<span class='line-number'>635</span>
<span class='line-number'>636</span>
<span class='line-number'>637</span>
<span class='line-number'>638</span>
<span class='line-number'>639</span>
<span class='line-number'>640</span>
<span class='line-number'>641</span>
<span class='line-number'>642</span>
<span class='line-number'>643</span>
<span class='line-number'>644</span>
<span class='line-number'>645</span>
<span class='line-number'>646</span>
<span class='line-number'>647</span>
<span class='line-number'>648</span>
<span class='line-number'>649</span>
<span class='line-number'>650</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>static struct xfrm_type ah_type =  // net/ipv4/ah4.c
</span><span class='line'>{
</span><span class='line'>&#9;.description    = "AH4",
</span><span class='line'>&#9;.owner          = THIS_MODULE,
</span><span class='line'>&#9;.proto          = IPPROTO_AH,
</span><span class='line'>&#9;.flags          = XFRM_TYPE_REPLAY_PROT,
</span><span class='line'>&#9;.init_state     = ah_init_state, //状态初始化
</span><span class='line'>&#9;.destructor     = ah_destroy,//协议释放
</span><span class='line'>&#9;.input          = ah_input,   //协议输入
</span><span class='line'>&#9;.output         = ah_output //协议输出
</span><span class='line'>};
</span><span class='line'>状态初始化
</span><span class='line'>ah_data数据结构
</span><span class='line'>struct ah_data //include/net/ah.h
</span><span class='line'>{
</span><span class='line'>&#9;u8                      *work_icv;    //工作初始化向量
</span><span class='line'>&#9;int                     icv_full_len;    //初始化向量完整长度
</span><span class='line'>&#9;int                     icv_trunc_len;  //初始化向量截断长度
</span><span class='line'>&#9;struct crypto_hash      *tfm;        //HASH算法
</span><span class='line'>};
</span><span class='line'>&#9;该函数被xfrm状态(SA)初始化函数xfrm_init_state调用，用来生成SA中所有的AH数据处理结构相关信息
</span><span class='line'>static int ah_init_state(struct xfrm_state *x)
</span><span class='line'>{
</span><span class='line'>&#9;struct ah_data *ahp = NULL;
</span><span class='line'>&#9;struct xfrm_algo_desc *aalg_desc;
</span><span class='line'>&#9;struct crypto_hash *tfm;
</span><span class='line'>
</span><span class='line'>&#9;if (!x-&gt;aalg) //对AH协议的SA, 认证算法是必须的, 否则就没法进行AH认证了
</span><span class='line'>&#9;&#9;goto error;
</span><span class='line'>
</span><span class='line'>&#9;if (x-&gt;encap)//如果要进行UDP封装(进行NAT穿越), 错误, 因为AH是不支持NAT的
</span><span class='line'>&#9;&#9;goto error;
</span><span class='line'>
</span><span class='line'>&#9;ahp = kzalloc(sizeof(*ahp), GFP_KERNEL);//分配ah_data数据结构空间
</span><span class='line'>&#9;if (ahp == NULL)
</span><span class='line'>&#9;&#9;return -ENOMEM;
</span><span class='line'>
</span><span class='line'>&#9;//分配认证算法HASH结构指针并赋值给AH数据结构
</span><span class='line'>&#9;//算法是固定相同的, 但在每个应用使用算法时的上下文是不同的, 该结构就是描述具体应用时的相关处理的上下文数据的
</span><span class='line'>&#9;tfm = crypto_alloc_hash(x-&gt;aalg-&gt;alg_name, 0, CRYPTO_ALG_ASYNC);
</span><span class='line'>&#9;if (IS_ERR(tfm))
</span><span class='line'>&#9;&#9;goto error;
</span><span class='line'>
</span><span class='line'>&#9;ahp-&gt;tfm = tfm;
</span><span class='line'>&#9;//设置认证算法密钥
</span><span class='line'>&#9;if (crypto_hash_setkey(tfm, x-&gt;aalg-&gt;alg_key, (x-&gt;aalg-&gt;alg_key_len + 7) / 8))
</span><span class='line'>&#9;&#9;goto error;
</span><span class='line'>&#9;/*                                                                                         
</span><span class='line'>&#9; * Lookup the algorithm description maintained by xfrm_algo,                               
</span><span class='line'>&#9; * verify crypto transform properties, and store information                               
</span><span class='line'>&#9; * we need for AH processing.  This lookup cannot fail here                                
</span><span class='line'>&#9; * after a successful crypto_alloc_hash().                                                 
</span><span class='line'>&#9; */
</span><span class='line'>&#9;aalg_desc = xfrm_aalg_get_byname(x-&gt;aalg-&gt;alg_name, 0);//查找算法描述结构
</span><span class='line'>&#9;BUG_ON(!aalg_desc);
</span><span class='line'>
</span><span class='line'>&#9;if (aalg_desc-&gt;uinfo.auth.icv_fullbits / 8 != crypto_hash_digestsize(tfm)) {
</span><span class='line'>&#9;&#9;printk(KERN_INFO "AH: %s digestsize %u != %hu\n", x-&gt;aalg-&gt;alg_name, crypto_hash_digestsize(tfm),
</span><span class='line'>&#9;&#9;&#9;&#9;aalg_desc-&gt;uinfo.auth.icv_fullbits/8);
</span><span class='line'>&#9;&#9;goto error;
</span><span class='line'>&#9;}
</span><span class='line'>&#9;//AH数据结构的初始化向量的总长和截断长度的赋值
</span><span class='line'>&#9;ahp-&gt;icv_full_len = aalg_desc-&gt;uinfo.auth.icv_fullbits/8;
</span><span class='line'>&#9;ahp-&gt;icv_trunc_len = aalg_desc-&gt;uinfo.auth.icv_truncbits/8;
</span><span class='line'>
</span><span class='line'>&#9;BUG_ON(ahp-&gt;icv_trunc_len &gt; MAX_AH_AUTH_LEN);
</span><span class='line'>&#9;//分配初始化向量空间, 没对其赋值, 其初始值就是随机值, 这也是初始化向量所需要的
</span><span class='line'>&#9;ahp-&gt;work_icv = kmalloc(ahp-&gt;icv_full_len, GFP_KERNEL);
</span><span class='line'>&#9;if (!ahp-&gt;work_icv)
</span><span class='line'>&#9;&#9;goto error;
</span><span class='line'>
</span><span class='line'>&#9;//AH类型SA中AH头长度: ip_auth_hdr结构和初始化向量长度, 按8字节对齐 
</span><span class='line'>&#9;//反映在AH封装操作时要将数据包增加的长度
</span><span class='line'>&#9;x-&gt;props.header_len = XFRM_ALIGN8(sizeof(struct ip_auth_hdr) + ahp-&gt;icv_trunc_len);
</span><span class='line'>
</span><span class='line'>&#9;if (x-&gt;props.mode == XFRM_MODE_TUNNEL)//如果是通道模式, 增加IP头长度
</span><span class='line'>&#9;&#9;x-&gt;props.header_len += sizeof(struct iphdr);
</span><span class='line'>&#9;x-&gt;data = ahp;//SA数据指向AH数据结构
</span><span class='line'>&#9;return 0;
</span><span class='line'>error:
</span><span class='line'>&#9;if (ahp) {
</span><span class='line'>&#9;&#9;kfree(ahp-&gt;work_icv);
</span><span class='line'>&#9;&#9;crypto_free_hash(ahp-&gt;tfm);
</span><span class='line'>&#9;&#9;kfree(ahp);
</span><span class='line'>&#9;}
</span><span class='line'>&#9;return -EINVAL;
</span><span class='line'>}
</span><span class='line'>&#9;接收数据处理, 在xfrm4_rcv_encap()函数中调用，进行AH认证, 剥离AH头
</span><span class='line'>static int ah_input(struct xfrm_state *x, struct sk_buff *skb)
</span><span class='line'>{
</span><span class='line'>&#9;int ah_hlen;
</span><span class='line'>&#9;int ihl;
</span><span class='line'>&#9;int nexthdr;
</span><span class='line'>&#9;int err = -EINVAL;
</span><span class='line'>&#9;struct iphdr *iph;
</span><span class='line'>&#9;struct ip_auth_hdr *ah;
</span><span class='line'>&#9;struct ah_data *ahp;
</span><span class='line'>&#9;char work_buf[60]; //IP头备份空间
</span><span class='line'>
</span><span class='line'>&#9;if (!pskb_may_pull(skb, sizeof(*ah)))//skb数据包要准备留出AH头空间
</span><span class='line'>&#9;&#9;goto out;
</span><span class='line'>
</span><span class='line'>&#9;ah = (struct ip_auth_hdr *)skb-&gt;data; //IP上层数据为AH数据
</span><span class='line'>&#9;//SA相关的AH处理数据
</span><span class='line'>&#9;ahp = x-&gt;data;
</span><span class='line'>&#9;nexthdr = ah-&gt;nexthdr;
</span><span class='line'>&#9;ah_hlen = (ah-&gt;hdrlen + 2) &lt;&lt; 2;
</span><span class='line'>
</span><span class='line'>&#9;//AH头部长度合法性检查
</span><span class='line'>&#9;if (ah_hlen != XFRM_ALIGN8(sizeof(*ah) + ahp-&gt;icv_full_len) && ah_hlen != XFRM_ALIGN8(sizeof(*ah) + ahp-&gt;icv_trunc_len))
</span><span class='line'>&#9;&#9;goto out;
</span><span class='line'>&#9;//skb数据包要准备留出实际AH头空间
</span><span class='line'>&#9;if (!pskb_may_pull(skb, ah_hlen))
</span><span class='line'>&#9;&#9;goto out;
</span><span class='line'>&#9;/* We are going to _remove_ AH header to keep sockets happy, so... Later this can change. */
</span><span class='line'>&#9;if (skb_cloned(skb) && pskb_expand_head(skb, 0, 0, GFP_ATOMIC))//对于clone的包要复制成独立包
</span><span class='line'>&#9;&#9;goto out;
</span><span class='line'>
</span><span class='line'>&#9;skb-&gt;ip_summed = CHECKSUM_NONE;
</span><span class='line'>
</span><span class='line'>&#9;ah = (struct ip_auth_hdr *)skb-&gt;data;//可能包已经进行了复制, 所以对ah重新赋值
</span><span class='line'>&#9;iph = ip_hdr(skb);
</span><span class='line'>
</span><span class='line'>&#9;ihl = skb-&gt;data - skb_network_header(skb); //IP头长度
</span><span class='line'>&#9;memcpy(work_buf, iph, ihl); //备份外部IP头数据
</span><span class='line'>
</span><span class='line'>&#9;//将IP头中的一些参数清零, 这些参数不进行认证
</span><span class='line'>&#9;iph-&gt;ttl = 0;
</span><span class='line'>&#9;iph-&gt;tos = 0;
</span><span class='line'>&#9;iph-&gt;frag_off = 0;
</span><span class='line'>&#9;iph-&gt;check = 0;
</span><span class='line'>
</span><span class='line'>&#9;if (ihl &gt; sizeof(*iph)) {//IP头长度超过20字节时,处理IP选项参数
</span><span class='line'>&#9;&#9;__be32 dummy;
</span><span class='line'>&#9;&#9;if (ip_clear_mutable_options(iph, &dummy))
</span><span class='line'>&#9;&#9;&#9;goto out;
</span><span class='line'>&#9;}
</span><span class='line'>&#9;{
</span><span class='line'>&#9;&#9;u8 auth_data[MAX_AH_AUTH_LEN];//认证数据缓冲区
</span><span class='line'>
</span><span class='line'>&#9;&#9;memcpy(auth_data, ah-&gt;auth_data, ahp-&gt;icv_trunc_len);//拷贝数据包中的认证数据到缓冲区
</span><span class='line'>&#9;&#9;skb_push(skb, ihl);//包括IP头部分数据
</span><span class='line'>
</span><span class='line'>&#9;&#9;err = ah_mac_digest(ahp, skb, ah-&gt;auth_data);//计算认证值是否匹配, 非0表示出错
</span><span class='line'>&#9;&#9;if (err)
</span><span class='line'>&#9;&#9;&#9;goto out;
</span><span class='line'>&#9;&#9;err = -EINVAL;
</span><span class='line'>&#9;&#9;if (memcmp(ahp-&gt;work_icv, auth_data, ahp-&gt;icv_trunc_len)) {//复制一定长度的认证数据作为初始化向量
</span><span class='line'>&#9;&#9;&#9;x-&gt;stats.integrity_failed++;
</span><span class='line'>&#9;&#9;&#9;goto out;
</span><span class='line'>&#9;&#9;}
</span><span class='line'>&#9;}
</span><span class='line'>&#9;skb-&gt;network_header += ah_hlen; //更新网络头字段
</span><span class='line'>&#9;memcpy(skb_network_header(skb), work_buf, ihl);//将原来IP头数据拷贝到原来AH头后面作为新IP头
</span><span class='line'>&#9;skb-&gt;transport_header = skb-&gt;network_header;
</span><span class='line'>&#9;__skb_pull(skb, ah_hlen + ihl);//skb包缩减原来的IP头和AH头, 以新IP头作为数据开始
</span><span class='line'>
</span><span class='line'>&#9;return nexthdr; //返回AH内部包裹的协议
</span><span class='line'>out:
</span><span class='line'>&#9;return err;
</span><span class='line'>}
</span><span class='line'>&#9;发送数据处理, 在xfrm4_output_one()中调用，计算AH认证值, 添加AH头
</span><span class='line'>static int ah_output(struct xfrm_state *x, struct sk_buff *skb)
</span><span class='line'>{
</span><span class='line'>&#9;int err;
</span><span class='line'>&#9;struct iphdr *iph, *top_iph;
</span><span class='line'>&#9;struct ip_auth_hdr *ah;
</span><span class='line'>&#9;struct ah_data *ahp;
</span><span class='line'>&#9;union {//临时IP头缓冲区, 最大IP头60字节
</span><span class='line'>&#9;&#9;struct iphdr    iph;
</span><span class='line'>&#9;&#9;char            buf[60];
</span><span class='line'>&#9;} tmp_iph;
</span><span class='line'>
</span><span class='line'>&#9;skb_push(skb, -skb_network_offset(skb)); //data指针移动到网络头位置
</span><span class='line'>&#9;top_iph = ip_hdr(skb);//当前的IP头将作为最外部IP头
</span><span class='line'>&#9;iph = &tmp_iph.iph; //临时IP头,用于临时保存IP头内部分字段数据
</span><span class='line'>
</span><span class='line'>&#9;//将当前IP头中不进行认证的字段数据复制到临时IP头
</span><span class='line'>&#9;iph-&gt;tos = top_iph-&gt;tos;
</span><span class='line'>&#9;iph-&gt;ttl = top_iph-&gt;ttl;
</span><span class='line'>&#9;iph-&gt;frag_off = top_iph-&gt;frag_off;
</span><span class='line'>
</span><span class='line'>&#9;if (top_iph-&gt;ihl != 5) {//如果有IP选项, 处理IP选项
</span><span class='line'>&#9;&#9;iph-&gt;daddr = top_iph-&gt;daddr;
</span><span class='line'>&#9;&#9;memcpy(iph+1, top_iph+1, top_iph-&gt;ihl*4 - sizeof(struct iphdr));
</span><span class='line'>&#9;&#9;err = ip_clear_mutable_options(top_iph, &top_iph-&gt;daddr);
</span><span class='line'>&#9;&#9;if (err)
</span><span class='line'>&#9;&#9;&#9;goto error;
</span><span class='line'>&#9;}
</span><span class='line'>&#9;//AH头定位在外部IP头后面, skb缓冲中已经预留出AH头的数据部分了,
</span><span class='line'>&#9;//这是通过mode-&gt;output函数预留的, 通常调用type-&gt;output前要调用mode-&gt;oputput，参考上面函数xfrm_output
</span><span class='line'>&#9;ah = ip_auth_hdr(skb);
</span><span class='line'>&#9;ah-&gt;nexthdr = *skb_mac_header(skb);//AH中的下一个头用mac中指定的协议
</span><span class='line'>&#9;*skb_mac_header(skb) = IPPROTO_AH; //mac中协议字段改为AH
</span><span class='line'>
</span><span class='line'>&#9;//将外部IP头的不进行认证计算的部分字段清零
</span><span class='line'>&#9;top_iph-&gt;tos = 0;
</span><span class='line'>&#9;top_iph-&gt;tot_len = htons(skb-&gt;len);
</span><span class='line'>&#9;top_iph-&gt;frag_off = 0;
</span><span class='line'>&#9;top_iph-&gt;ttl = 0;
</span><span class='line'>&#9;top_iph-&gt;check = 0;
</span><span class='line'>
</span><span class='line'>&#9;ahp = x-&gt;data;//AH数据处理结构
</span><span class='line'>&#9;ah-&gt;hdrlen  = (XFRM_ALIGN8(sizeof(*ah) + ahp-&gt;icv_trunc_len) &gt;&gt; 2) - 2;//AH头长度对齐
</span><span class='line'>
</span><span class='line'>&#9;//AH头参数赋值
</span><span class='line'>&#9;ah-&gt;reserved = 0;
</span><span class='line'>&#9;ah-&gt;spi = x-&gt;id.spi;//SPI值
</span><span class='line'>&#9;ah-&gt;seq_no = htonl(XFRM_SKB_CB(skb)-&gt;seq);//序列号
</span><span class='line'>
</span><span class='line'>&#9;spin_lock_bh(&x-&gt;lock);
</span><span class='line'>&#9;err = ah_mac_digest(ahp, skb, ah-&gt;auth_data);//对skb进行AH认证值的计算
</span><span class='line'>&#9;memcpy(ah-&gt;auth_data, ahp-&gt;work_icv, ahp-&gt;icv_trunc_len);//赋值初始化向量值到认证数据部分
</span><span class='line'>&#9;spin_unlock_bh(&x-&gt;lock);
</span><span class='line'>
</span><span class='line'>&#9;if (err)
</span><span class='line'>&#9;&#9;goto error;
</span><span class='line'>
</span><span class='line'>&#9;// 恢复原来IP头的的不认证部分的值
</span><span class='line'>&#9;top_iph-&gt;tos = iph-&gt;tos;
</span><span class='line'>&#9;top_iph-&gt;ttl = iph-&gt;ttl;
</span><span class='line'>&#9;top_iph-&gt;frag_off = iph-&gt;frag_off;
</span><span class='line'>
</span><span class='line'>&#9;if (top_iph-&gt;ihl != 5) { //处理ip选项
</span><span class='line'>&#9;&#9;top_iph-&gt;daddr = iph-&gt;daddr;
</span><span class='line'>&#9;&#9;memcpy(top_iph+1, iph+1, top_iph-&gt;ihl*4 - sizeof(struct iphdr));
</span><span class='line'>&#9;}
</span><span class='line'>&#9;err = 0;
</span><span class='line'>error:
</span><span class='line'>&#9;return err;
</span><span class='line'>}
</span><span class='line'>static struct xfrm_type esp_type = //net/ipv4/esp4.c
</span><span class='line'>{
</span><span class='line'>&#9;.description    = "ESP4",
</span><span class='line'>&#9;.owner          = THIS_MODULE,
</span><span class='line'>&#9;.proto          = IPPROTO_ESP,
</span><span class='line'>&#9;.flags          = XFRM_TYPE_REPLAY_PROT,
</span><span class='line'>&#9;.init_state     = esp_init_state,
</span><span class='line'>&#9;.destructor     = esp_destroy,
</span><span class='line'>&#9;.get_mtu        = esp4_get_mtu, //获取mtu
</span><span class='line'>&#9;.input          = esp_input,
</span><span class='line'>&#9;.output         = esp_output
</span><span class='line'>};
</span><span class='line'>esp_data数据结构
</span><span class='line'>struct esp_data
</span><span class='line'>{
</span><span class='line'>&#9;struct scatterlist              sgbuf[ESP_NUM_FAST_SG];
</span><span class='line'>
</span><span class='line'>&#9;/* Confidentiality */
</span><span class='line'>&#9;struct {//加密使用的相关数据
</span><span class='line'>&#9;&#9;int                     padlen;     //填充长度    /* 0..255 */
</span><span class='line'>&#9;&#9;/* ivlen is offset from enc_data, where encrypted data start.                      
</span><span class='line'>&#9;&#9; * It is logically different of crypto_tfm_alg_ivsize(tfm).                        
</span><span class='line'>&#9;&#9; * We assume that it is either zero (no ivec), or                                  
</span><span class='line'>&#9;&#9; * &gt;= crypto_tfm_alg_ivsize(tfm). */
</span><span class='line'>&#9;&#9;int                     ivlen;     //初始化向量长度
</span><span class='line'>&#9;&#9;int                     ivinitted;  //初始化向量是否初始化标志
</span><span class='line'>&#9;&#9;u8                      *ivec;       //初始化向量 /* ivec buffer */
</span><span class='line'>&#9;&#9;struct crypto_blkcipher *tfm;        //加密算法   /* crypto handle */
</span><span class='line'>&#9;} conf;
</span><span class='line'>&#9;/* Integrity. It is active when icv_full_len != 0 */
</span><span class='line'>&#9;struct {//认证使用的相关数据
</span><span class='line'>&#9;&#9;u8                      *work_icv;//初始化向量
</span><span class='line'>&#9;&#9;int                     icv_full_len;//初始化向量全长
</span><span class='line'>&#9;&#9;int                   icv_trunc_len;//初始化向量截断长度
</span><span class='line'>&#9;&#9;struct crypto_hash      *tfm;//HASH算法
</span><span class='line'>&#9;} auth;
</span><span class='line'>};
</span><span class='line'>ESP的esp_data数据结构初始化
</span><span class='line'>static int esp_init_state(struct xfrm_state *x)
</span><span class='line'>{
</span><span class='line'>&#9;struct esp_data *esp = NULL;
</span><span class='line'>&#9;struct crypto_blkcipher *tfm;
</span><span class='line'>&#9;u32 align;
</span><span class='line'>
</span><span class='line'>&#9;if (x-&gt;ealg == NULL)//ESP加密算法是必须的
</span><span class='line'>&#9;&#9;goto error;
</span><span class='line'>
</span><span class='line'>&#9;esp = kzalloc(sizeof(*esp), GFP_KERNEL);//分配esp_data数据结构空间
</span><span class='line'>&#9;if (esp == NULL)
</span><span class='line'>&#9;&#9;return -ENOMEM;
</span><span class='line'>
</span><span class='line'>&#9;//如果定义了认证算法, 初始化认证算法参数, 和AH类似
</span><span class='line'>&#9;if (x-&gt;aalg) {
</span><span class='line'>&#9;&#9;struct xfrm_algo_desc *aalg_desc;
</span><span class='line'>&#9;&#9;struct crypto_hash *hash;
</span><span class='line'>&#9;&#9;//分配HASH算法的实现
</span><span class='line'>&#9;&#9;hash = crypto_alloc_hash(x-&gt;aalg-&gt;alg_name, 0, CRYPTO_ALG_ASYNC);
</span><span class='line'>&#9;&#9;if (IS_ERR(hash))
</span><span class='line'>&#9;&#9;&#9;goto error;
</span><span class='line'>
</span><span class='line'>&#9;&#9;esp-&gt;auth.tfm = hash;
</span><span class='line'>&#9;&#9;//设置HASH算法密钥
</span><span class='line'>&#9;&#9;if (crypto_hash_setkey(hash, x-&gt;aalg-&gt;alg_key, (x-&gt;aalg-&gt;alg_key_len + 7) / 8))
</span><span class='line'>&#9;&#9;&#9;goto error;
</span><span class='line'>
</span><span class='line'>&#9;&#9;//找到算法描述
</span><span class='line'>&#9;&#9;aalg_desc = xfrm_aalg_get_byname(x-&gt;aalg-&gt;alg_name, 0);
</span><span class='line'>&#9;&#9;BUG_ON(!aalg_desc);
</span><span class='line'>
</span><span class='line'>&#9;&#9;//检查算法初始化向量长度合法性
</span><span class='line'>&#9;&#9;if (aalg_desc-&gt;uinfo.auth.icv_fullbits/8 != crypto_hash_digestsize(hash)) {
</span><span class='line'>&#9;&#9;&#9;NETDEBUG(KERN_INFO "ESP: %s digestsize %u != %hu\n", x-&gt;aalg-&gt;alg_name,
</span><span class='line'>&#9;&#9;&#9;&#9;&#9;crypto_hash_digestsize(hash), aalg_desc-&gt;uinfo.auth.icv_fullbits/8);
</span><span class='line'>&#9;&#9;&#9;goto error;
</span><span class='line'>&#9;&#9;}
</span><span class='line'>&#9;&#9;//初始化向量的全长和截断长度
</span><span class='line'>&#9;&#9;esp-&gt;auth.icv_full_len = aalg_desc-&gt;uinfo.auth.icv_fullbits/8;
</span><span class='line'>&#9;&#9;esp-&gt;auth.icv_trunc_len = aalg_desc-&gt;uinfo.auth.icv_truncbits/8;
</span><span class='line'>&#9;&#9;esp-&gt;auth.work_icv = kmalloc(esp-&gt;auth.icv_full_len, GFP_KERNEL);//分配全长度的初始化向量空间
</span><span class='line'>&#9;&#9;if (!esp-&gt;auth.work_icv)
</span><span class='line'>&#9;&#9;&#9;goto error;
</span><span class='line'>&#9;}
</span><span class='line'>&#9;//查找加密算法的具体实现结构
</span><span class='line'>&#9;tfm = crypto_alloc_blkcipher(x-&gt;ealg-&gt;alg_name, 0, CRYPTO_ALG_ASYNC);
</span><span class='line'>&#9;if (IS_ERR(tfm))
</span><span class='line'>&#9;&#9;goto error;
</span><span class='line'>&#9;esp-&gt;conf.tfm = tfm;
</span><span class='line'>&#9;esp-&gt;conf.ivlen = crypto_blkcipher_ivsize(tfm);//初始化向量大小
</span><span class='line'>&#9;esp-&gt;conf.padlen = 0;//填充数据长度初始化为0
</span><span class='line'>
</span><span class='line'>&#9;if (esp-&gt;conf.ivlen) {//初始化向量长度非0, 分配具体的初始化向量空间
</span><span class='line'>&#9;&#9;esp-&gt;conf.ivec = kmalloc(esp-&gt;conf.ivlen, GFP_KERNEL);
</span><span class='line'>&#9;&#9;if (unlikely(esp-&gt;conf.ivec == NULL))
</span><span class='line'>&#9;&#9;&#9;goto error;
</span><span class='line'>&#9;&#9;esp-&gt;conf.ivinitted = 0;
</span><span class='line'>&#9;}
</span><span class='line'>&#9;//设置加密算法密钥
</span><span class='line'>&#9;if (crypto_blkcipher_setkey(tfm, x-&gt;ealg-&gt;alg_key, (x-&gt;ealg-&gt;alg_key_len + 7) / 8))
</span><span class='line'>&#9;&#9;goto error;
</span><span class='line'>&#9;//定义SA中ESP头部长度: ESP头加初始化向量长度
</span><span class='line'>&#9;//反映在ESP封装操作时要将数据包增加的长度
</span><span class='line'>&#9;x-&gt;props.header_len = sizeof(struct ip_esp_hdr) + esp-&gt;conf.ivlen;
</span><span class='line'>
</span><span class='line'>&#9;if (x-&gt;props.mode == XFRM_MODE_TUNNEL)//如果是通道模式, 还需要增加IP头长度
</span><span class='line'>&#9;&#9;x-&gt;props.header_len += sizeof(struct iphdr);
</span><span class='line'>&#9;else if (x-&gt;props.mode == XFRM_MODE_BEET)//如果是BEET模式, 还需要增加IP头长度
</span><span class='line'>&#9;&#9;x-&gt;props.header_len += IPV4_BEET_PHMAXLEN;
</span><span class='line'>&#9;if (x-&gt;encap) {//如果要进行UDP封装
</span><span class='line'>&#9;&#9;struct xfrm_encap_tmpl *encap = x-&gt;encap;
</span><span class='line'>&#9;&#9;switch (encap-&gt;encap_type) {
</span><span class='line'>&#9;&#9;&#9;default:
</span><span class='line'>&#9;&#9;&#9;&#9;goto error;
</span><span class='line'>&#9;&#9;&#9;case UDP_ENCAP_ESPINUDP://该类型封装增加UDP头长度
</span><span class='line'>&#9;&#9;&#9;&#9;x-&gt;props.header_len += sizeof(struct udphdr);
</span><span class='line'>&#9;&#9;&#9;&#9;break;
</span><span class='line'>&#9;&#9;&#9;case UDP_ENCAP_ESPINUDP_NON_IKE://该类型封装增加UDP头长度外加加8字节
</span><span class='line'>&#9;&#9;&#9;&#9;x-&gt;props.header_len += sizeof(struct udphdr) + 2 * sizeof(u32);
</span><span class='line'>&#9;&#9;&#9;&#9;break;
</span><span class='line'>&#9;&#9;}
</span><span class='line'>&#9;}
</span><span class='line'>&#9;x-&gt;data = esp;//将esp_data作为SA的data指针
</span><span class='line'>
</span><span class='line'>&#9;align = ALIGN(crypto_blkcipher_blocksize(esp-&gt;conf.tfm), 4); //加密块长度, 按4字节对齐
</span><span class='line'>&#9;if (esp-&gt;conf.padlen)
</span><span class='line'>&#9;&#9;align = max_t(u32, align, esp-&gt;conf.padlen);
</span><span class='line'>&#9;x-&gt;props.trailer_len = align + 1 + esp-&gt;auth.icv_trunc_len; //加密块长度 + 1 + 认证长度
</span><span class='line'>&#9;return 0;
</span><span class='line'>&#9;......
</span><span class='line'>}
</span><span class='line'>获取mtu
</span><span class='line'>static u32 esp4_get_mtu(struct xfrm_state *x, int mtu)
</span><span class='line'>{
</span><span class='line'>&#9;struct esp_data *esp = x-&gt;data;
</span><span class='line'>&#9;u32 blksize = ALIGN(crypto_blkcipher_blocksize(esp-&gt;conf.tfm), 4);//加密块长度, 按4字节对齐
</span><span class='line'>&#9;u32 align = max_t(u32, blksize, esp-&gt;conf.padlen);
</span><span class='line'>&#9;u32 rem;
</span><span class='line'>
</span><span class='line'>&#9;mtu -= x-&gt;props.header_len + esp-&gt;auth.icv_trunc_len;
</span><span class='line'>&#9;rem = mtu & (align - 1);
</span><span class='line'>&#9;mtu &= ~(align - 1); ///mtu对齐
</span><span class='line'>
</span><span class='line'>&#9;switch (x-&gt;props.mode) {
</span><span class='line'>&#9;&#9;case XFRM_MODE_TUNNEL:
</span><span class='line'>&#9;&#9;&#9;break;
</span><span class='line'>&#9;&#9;default:
</span><span class='line'>&#9;&#9;case XFRM_MODE_TRANSPORT://传输模式下
</span><span class='line'>&#9;&#9;&#9;/* The worst case */
</span><span class='line'>&#9;&#9;&#9;mtu -= blksize - 4;
</span><span class='line'>&#9;&#9;&#9;mtu += min_t(u32, blksize - 4, rem);
</span><span class='line'>&#9;&#9;&#9;break;
</span><span class='line'>&#9;&#9;case XFRM_MODE_BEET:
</span><span class='line'>&#9;&#9;&#9;/* The worst case. */
</span><span class='line'>&#9;&#9;&#9;mtu += min_t(u32, IPV4_BEET_PHMAXLEN, rem);
</span><span class='line'>&#9;&#9;&#9;break;
</span><span class='line'>&#9;}
</span><span class='line'>&#9;return mtu - 2;
</span><span class='line'>}
</span><span class='line'>接收数据处理, 在xfrm4_rcv_encap()函数中调用
</span><span class='line'>&#9;进行ESP认证解密, 剥离ESP头, 解密成普通数据包, 数据包长度减少
</span><span class='line'>static int esp_input(struct xfrm_state *x, struct sk_buff *skb)
</span><span class='line'>{
</span><span class='line'>&#9;struct iphdr *iph;
</span><span class='line'>&#9;struct ip_esp_hdr *esph;
</span><span class='line'>&#9;struct esp_data *esp = x-&gt;data;
</span><span class='line'>&#9;struct crypto_blkcipher *tfm = esp-&gt;conf.tfm;
</span><span class='line'>&#9;struct blkcipher_desc desc = { .tfm = tfm };
</span><span class='line'>&#9;struct sk_buff *trailer;
</span><span class='line'>&#9;int blksize = ALIGN(crypto_blkcipher_blocksize(tfm), 4);
</span><span class='line'>&#9;int alen = esp-&gt;auth.icv_trunc_len;//认证初始化向量截断长度
</span><span class='line'>&#9;//需要加密的数据长度: 总长减ESP头, 加密初始化向量长度, 认证初始化向量长度
</span><span class='line'>&#9;int elen = skb-&gt;len - sizeof(*esph) - esp-&gt;conf.ivlen - alen;
</span><span class='line'>&#9;int nfrags;
</span><span class='line'>&#9;int ihl;
</span><span class='line'>&#9;u8 nexthdr[2];
</span><span class='line'>&#9;struct scatterlist *sg;
</span><span class='line'>&#9;int padlen;
</span><span class='line'>&#9;int err;
</span><span class='line'>
</span><span class='line'>&#9;if (!pskb_may_pull(skb, sizeof(*esph)))//在skb头要有足够的ESP头空间
</span><span class='line'>&#9;&#9;goto out;
</span><span class='line'>
</span><span class='line'>&#9;if (elen &lt;= 0 || (elen & (blksize-1)))//检查需要加密的数据长度, 必须大于0而且按块大小对齐的
</span><span class='line'>&#9;&#9;goto out;
</span><span class='line'>
</span><span class='line'>&#9;/* If integrity check is required, do this. */
</span><span class='line'>&#9;if (esp-&gt;auth.icv_full_len) {//认证计算处理
</span><span class='line'>&#9;&#9;u8 sum[alen];
</span><span class='line'>&#9;&#9;//计算认证值, 认证值保存在esp_data结构中
</span><span class='line'>&#9;&#9;err = esp_mac_digest(esp, skb, 0, skb-&gt;len - alen);
</span><span class='line'>&#9;&#9;if (err)
</span><span class='line'>&#9;&#9;&#9;goto out;
</span><span class='line'>
</span><span class='line'>&#9;&#9;//将skb中的认证初始化向量部分数据拷贝到缓冲区sum中
</span><span class='line'>&#9;&#9;if (skb_copy_bits(skb, skb-&gt;len - alen, sum, alen))
</span><span class='line'>&#9;&#9;&#9;BUG();
</span><span class='line'>
</span><span class='line'>&#9;&#9;//比较sum中的向量值和认证算法结构中的向量值是否匹配, 数据包正常情况下应该是相同的
</span><span class='line'>&#9;&#9;if (unlikely(memcmp(esp-&gt;auth.work_icv, sum, alen))) {
</span><span class='line'>&#9;&#9;&#9;x-&gt;stats.integrity_failed++;
</span><span class='line'>&#9;&#9;&#9;goto out;
</span><span class='line'>&#9;&#9;}
</span><span class='line'>&#9;}
</span><span class='line'>&#9;//使数据包可写，返回使用了多少个内存页
</span><span class='line'>&#9;if ((nfrags = skb_cow_data(skb, 0, &trailer)) &lt; 0)
</span><span class='line'>&#9;&#9;goto out;
</span><span class='line'>
</span><span class='line'>&#9;skb-&gt;ip_summed = CHECKSUM_NONE;
</span><span class='line'>&#9;//定位在数据包中的ESP头位置, 为当前的data位置
</span><span class='line'>&#9;esph = (struct ip_esp_hdr *)skb-&gt;data;
</span><span class='line'>
</span><span class='line'>&#9;/* Get ivec. This can be wrong, check against another impls. */
</span><span class='line'>&#9;if (esp-&gt;conf.ivlen)//设置加密算法的初始化向量
</span><span class='line'>&#9;&#9;crypto_blkcipher_set_iv(tfm, esph-&gt;enc_data, esp-&gt;conf.ivlen);//拷贝esph头后的数据到加密算法结构中
</span><span class='line'>
</span><span class='line'>&#9;sg = &esp-&gt;sgbuf[0];
</span><span class='line'>
</span><span class='line'>&#9;if (unlikely(nfrags &gt; ESP_NUM_FAST_SG)) {//内存页超过 4
</span><span class='line'>&#9;&#9;sg = kmalloc(sizeof(struct scatterlist)*nfrags, GFP_ATOMIC);
</span><span class='line'>&#9;&#9;if (!sg)
</span><span class='line'>&#9;&#9;&#9;goto out;
</span><span class='line'>&#9;}
</span><span class='line'>&#9;sg_init_table(sg, nfrags);
</span><span class='line'>&#9;skb_to_sgvec(skb, sg, sizeof(*esph) + esp-&gt;conf.ivlen, elen);
</span><span class='line'>
</span><span class='line'>&#9;//解密操作, 返回非0表示失败
</span><span class='line'>&#9;err = crypto_blkcipher_decrypt(&desc, sg, sg, elen);
</span><span class='line'>&#9;if (unlikely(sg != &esp-&gt;sgbuf[0]))
</span><span class='line'>&#9;&#9;kfree(sg);
</span><span class='line'>&#9;if (unlikely(err))//解密失败返回
</span><span class='line'>&#9;&#9;return err;
</span><span class='line'>
</span><span class='line'>&#9;if (skb_copy_bits(skb, skb-&gt;len-alen-2, nexthdr, 2))//拷贝两字节数据
</span><span class='line'>&#9;&#9;BUG();
</span><span class='line'>
</span><span class='line'>&#9;padlen = nexthdr[0]; //填充数据长度
</span><span class='line'>&#9;if (padlen+2 &gt;= elen)
</span><span class='line'>&#9;&#9;goto out;
</span><span class='line'>&#9;/* RFC4303: Drop dummy packets without any error */
</span><span class='line'>&#9;if (nexthdr[1] == IPPROTO_NONE)
</span><span class='line'>&#9;&#9;goto out;
</span><span class='line'>
</span><span class='line'>&#9;iph = ip_hdr(skb);//IP头
</span><span class='line'>&#9;ihl = iph-&gt;ihl * 4;
</span><span class='line'>
</span><span class='line'>&#9;if (x-&gt;encap) {//如果是NAT穿越情况, 进行一些处理
</span><span class='line'>&#9;&#9;struct xfrm_encap_tmpl *encap = x-&gt;encap;//xfrm封装模板
</span><span class='line'>&#9;&#9;struct udphdr *uh = (void *)(skb_network_header(skb) + ihl);//定位UDP数据头位置, 在IP头之后
</span><span class='line'>
</span><span class='line'>&#9;&#9;//如果IP头源地址和SA提议中的源地址不同或源端口不同
</span><span class='line'>&#9;&#9;if (iph-&gt;saddr != x-&gt;props.saddr.a4 || uh-&gt;source != encap-&gt;encap_sport) {
</span><span class='line'>&#9;&#9;&#9;xfrm_address_t ipaddr;
</span><span class='line'>&#9;&#9;&#9;ipaddr.a4 = iph-&gt;saddr;//保存当前IP头源地址
</span><span class='line'>&#9;&#9;&#9;km_new_mapping(x, &ipaddr, uh-&gt;source);//进行NAT通知回调处理
</span><span class='line'>&#9;&#9;}
</span><span class='line'>&#9;&#9;if (x-&gt;props.mode == XFRM_MODE_TRANSPORT)//如果是传输模式, 设置不需要计算校验和
</span><span class='line'>&#9;&#9;&#9;skb-&gt;ip_summed = CHECKSUM_UNNECESSARY;
</span><span class='line'>&#9;}
</span><span class='line'>&#9;//缩减skb数据包长度，调整len和tail字段
</span><span class='line'>&#9;pskb_trim(skb, skb-&gt;len - alen - padlen - 2);
</span><span class='line'>
</span><span class='line'>&#9;//调整data到esph头和数据后面
</span><span class='line'>&#9;__skb_pull(skb, sizeof(*esph) + esp-&gt;conf.ivlen);
</span><span class='line'>&#9;skb_set_transport_header(skb, -ihl); //定位传输层头，data前面20字节处
</span><span class='line'>
</span><span class='line'>&#9;return nexthdr[1]; //返回记录的IP头中协议
</span><span class='line'>out:
</span><span class='line'>&#9;return -EINVAL;
</span><span class='line'>}
</span><span class='line'>发送数据处理, 在xfrm4_output_one()中调用
</span><span class='line'>添加ESP头, 对数据包进行加密和认证处理, 数据包长度扩大
</span><span class='line'>&#9;在NAT穿越情况下会封装为UDP数据
</span><span class='line'>static int esp_output(struct xfrm_state *x, struct sk_buff *skb)
</span><span class='line'>{
</span><span class='line'>&#9;int err;
</span><span class='line'>&#9;struct ip_esp_hdr *esph;
</span><span class='line'>&#9;struct crypto_blkcipher *tfm;
</span><span class='line'>&#9;struct blkcipher_desc desc;
</span><span class='line'>&#9;struct esp_data *esp;
</span><span class='line'>&#9;struct sk_buff *trailer;
</span><span class='line'>&#9;u8 *tail;
</span><span class='line'>&#9;int blksize;
</span><span class='line'>&#9;int clen;
</span><span class='line'>&#9;int alen;
</span><span class='line'>&#9;int nfrags;
</span><span class='line'>
</span><span class='line'>&#9;/* skb is pure payload to encrypt */
</span><span class='line'>&#9;err = -ENOMEM;
</span><span class='line'>
</span><span class='line'>&#9;/* Round to block size */
</span><span class='line'>&#9;clen = skb-&gt;len;//加密块的初始值
</span><span class='line'>
</span><span class='line'>&#9;esp = x-&gt;data;//获取SA的esp_data数据结构
</span><span class='line'>&#9;alen = esp-&gt;auth.icv_trunc_len;//认证初始化向量截断长度
</span><span class='line'>&#9;tfm = esp-&gt;conf.tfm;//加密算法
</span><span class='line'>&#9;//给块加密算法描述结构赋值
</span><span class='line'>&#9;desc.tfm = tfm;
</span><span class='line'>&#9;desc.flags = 0;
</span><span class='line'>&#9;//每个加密块大小
</span><span class='line'>&#9;blksize = ALIGN(crypto_blkcipher_blocksize(tfm), 4);
</span><span class='line'>&#9;clen = ALIGN(clen + 2, blksize);//对齐要加密的数据总长
</span><span class='line'>
</span><span class='line'>&#9;if (esp-&gt;conf.padlen)//如果要考虑填充, 继续对齐
</span><span class='line'>&#9;&#9;clen = ALIGN(clen, esp-&gt;conf.padlen);
</span><span class='line'>&#9;//使数据包可写
</span><span class='line'>&#9;if ((nfrags = skb_cow_data(skb, clen-skb-&gt;len+alen, &trailer)) &lt; 0)
</span><span class='line'>&#9;&#9;goto error;
</span><span class='line'>
</span><span class='line'>&#9;/* Fill padding... */
</span><span class='line'>&#9;tail = skb_tail_pointer(trailer);//长度对齐后填充多余长度部分内容
</span><span class='line'>&#9;do {
</span><span class='line'>&#9;&#9;int i;
</span><span class='line'>&#9;&#9;for (i = 0;  i &lt; clen - skb-&gt;len - 2; i++)
</span><span class='line'>&#9;&#9;&#9;tail[i] = i + 1;
</span><span class='line'>&#9;} while (0);
</span><span class='line'>&#9;//最后两字节表示填充数据的长度和ip中原来的协议
</span><span class='line'>&#9;tail[clen - skb-&gt;len - 2] = (clen - skb-&gt;len) - 2; //数据长度
</span><span class='line'>&#9;pskb_put(skb, trailer, clen - skb-&gt;len);//调整skb-&gt;tail位置
</span><span class='line'>
</span><span class='line'>&#9;//将IP头部分扩展回来，data调整到网络头位置
</span><span class='line'>&#9;skb_push(skb, -skb_network_offset(skb));
</span><span class='line'>&#9;esph = ip_esp_hdr(skb);//esp头跟在IP头后
</span><span class='line'>&#9;*(skb_tail_pointer(trailer) - 1) = *skb_mac_header(skb); //记录ip中原来的协议
</span><span class='line'>&#9;*skb_mac_header(skb) = IPPROTO_ESP; //修改ip头中协议
</span><span class='line'>
</span><span class='line'>&#9;spin_lock_bh(&x-&gt;lock);
</span><span class='line'>&#9;/* this is non-NULL only with UDP Encapsulation */
</span><span class='line'>&#9;if (x-&gt;encap) {//NAT穿越情况下要将数据封装为UDP包
</span><span class='line'>&#9;&#9;struct xfrm_encap_tmpl *encap = x-&gt;encap;
</span><span class='line'>&#9;&#9;struct udphdr *uh;
</span><span class='line'>&#9;&#9;__be32 *udpdata32;
</span><span class='line'>
</span><span class='line'>&#9;&#9;uh = (struct udphdr *)esph;//IP头后改为UDP头
</span><span class='line'>&#9;&#9;//填充UDP头参数, 源端口, 目的端口, UDP数据长度
</span><span class='line'>&#9;&#9;uh-&gt;source = encap-&gt;encap_sport;
</span><span class='line'>&#9;&#9;uh-&gt;dest = encap-&gt;encap_dport;
</span><span class='line'>&#9;&#9;uh-&gt;len = htons(skb-&gt;len + alen - skb_transport_offset(skb));
</span><span class='line'>&#9;&#9;uh-&gt;check = 0;//校验和为0, 表示不需要计算校验和, ESP本身就进行认证了
</span><span class='line'>
</span><span class='line'>&#9;&#9;switch (encap-&gt;encap_type) {
</span><span class='line'>&#9;&#9;&#9;default:
</span><span class='line'>&#9;&#9;&#9;case UDP_ENCAP_ESPINUDP://在该模式下ESP头跟在UDP头后面
</span><span class='line'>&#9;&#9;&#9;&#9;esph = (struct ip_esp_hdr *)(uh + 1);
</span><span class='line'>&#9;&#9;&#9;&#9;break;
</span><span class='line'>&#9;&#9;&#9;case UDP_ENCAP_ESPINUDP_NON_IKE://在该模式下ESP头跟在UDP头后面2字节处
</span><span class='line'>&#9;&#9;&#9;&#9;udpdata32 = (__be32 *)(uh + 1);
</span><span class='line'>&#9;&#9;&#9;&#9;udpdata32[0] = udpdata32[1] = 0;
</span><span class='line'>&#9;&#9;&#9;&#9;esph = (struct ip_esp_hdr *)(udpdata32 + 2);
</span><span class='line'>&#9;&#9;&#9;&#9;break;
</span><span class='line'>&#9;&#9;}
</span><span class='line'>&#9;&#9;*skb_mac_header(skb) = IPPROTO_UDP;//外部IP头协议是UDP
</span><span class='line'>&#9;}
</span><span class='line'>&#9;//填充ESP头中的SPI和序列号
</span><span class='line'>&#9;esph-&gt;spi = x-&gt;id.spi;
</span><span class='line'>&#9;esph-&gt;seq_no = htonl(XFRM_SKB_CB(skb)-&gt;seq);
</span><span class='line'>
</span><span class='line'>&#9;//如果加密初始化向量长度非零, 设置加密算法中的初始化向量
</span><span class='line'>&#9;if (esp-&gt;conf.ivlen) {
</span><span class='line'>&#9;&#9;if (unlikely(!esp-&gt;conf.ivinitted)) {
</span><span class='line'>&#9;&#9;&#9;get_random_bytes(esp-&gt;conf.ivec, esp-&gt;conf.ivlen);
</span><span class='line'>&#9;&#9;&#9;esp-&gt;conf.ivinitted = 1;
</span><span class='line'>&#9;&#9;}
</span><span class='line'>&#9;&#9;crypto_blkcipher_set_iv(tfm, esp-&gt;conf.ivec, esp-&gt;conf.ivlen);
</span><span class='line'>&#9;}
</span><span class='line'>&#9;//加密操作
</span><span class='line'>&#9;do {
</span><span class='line'>&#9;&#9;struct scatterlist *sg = &esp-&gt;sgbuf[0];
</span><span class='line'>&#9;&#9;if (unlikely(nfrags &gt; ESP_NUM_FAST_SG)) {
</span><span class='line'>&#9;&#9;&#9;sg = kmalloc(sizeof(struct scatterlist)*nfrags, GFP_ATOMIC);
</span><span class='line'>&#9;&#9;&#9;if (!sg)
</span><span class='line'>&#9;&#9;&#9;&#9;goto unlock;
</span><span class='line'>&#9;&#9;}
</span><span class='line'>&#9;&#9;sg_init_table(sg, nfrags);
</span><span class='line'>&#9;&#9;skb_to_sgvec(skb, sg, esph-&gt;enc_data + esp-&gt;conf.ivlen - skb-&gt;data, clen);//对数据加密
</span><span class='line'>&#9;&#9;err = crypto_blkcipher_encrypt(&desc, sg, sg, clen);
</span><span class='line'>&#9;&#9;if (unlikely(sg != &esp-&gt;sgbuf[0]))
</span><span class='line'>&#9;&#9;&#9;kfree(sg);
</span><span class='line'>&#9;} while (0);
</span><span class='line'>
</span><span class='line'>&#9;if (esp-&gt;conf.ivlen) {//将加密算法初始化向量拷贝到数据包
</span><span class='line'>&#9;&#9;memcpy(esph-&gt;enc_data, esp-&gt;conf.ivec, esp-&gt;conf.ivlen);
</span><span class='line'>&#9;&#9;crypto_blkcipher_get_iv(tfm, esp-&gt;conf.ivec, esp-&gt;conf.ivlen);
</span><span class='line'>&#9;}
</span><span class='line'>
</span><span class='line'>&#9;if (esp-&gt;auth.icv_full_len) {//认证计算, 计算出HASH值并拷贝到数据包中
</span><span class='line'>&#9;&#9;err = esp_mac_digest(esp, skb, (u8 *)esph - skb-&gt;data, sizeof(*esph) + esp-&gt;conf.ivlen + clen);
</span><span class='line'>&#9;&#9;memcpy(pskb_put(skb, trailer, alen), esp-&gt;auth.work_icv, alen);
</span><span class='line'>&#9;}
</span><span class='line'>unlock:
</span><span class='line'>&#9;spin_unlock_bh(&x-&gt;lock);
</span><span class='line'>error:
</span><span class='line'>&#9;return err;
</span><span class='line'>}
</span><span class='line'>static struct xfrm_type ipcomp_type = { //net/ipv4/ipcomp.c  ip压缩协议
</span><span class='line'>&#9;.description    = "IPCOMP4",
</span><span class='line'>&#9;.owner          = THIS_MODULE,
</span><span class='line'>&#9;.proto          = IPPROTO_COMP,
</span><span class='line'>&#9;.init_state     = ipcomp_init_state,
</span><span class='line'>&#9;.destructor     = ipcomp_destroy,
</span><span class='line'>&#9;.input          = ipcomp_input,
</span><span class='line'>&#9;.output         = ipcomp_output
</span><span class='line'>};
</span><span class='line'>static struct xfrm_type ipip_type = {   ///net/ipv4/xfrm4_tunnel.c ipip协议
</span><span class='line'>&#9;.description    = "IPIP",
</span><span class='line'>&#9;.owner          = THIS_MODULE,
</span><span class='line'>&#9;.proto          = IPPROTO_IPIP,
</span><span class='line'>&#9;.init_state     = ipip_init_state,
</span><span class='line'>&#9;.destructor     = ipip_destroy,
</span><span class='line'>&#9;.input          = ipip_xfrm_rcv,
</span><span class='line'>&#9;.output         = ipip_output
</span><span class='line'>};
</span><span class='line'>static int ipip_output(struct xfrm_state *x, struct sk_buff *skb)
</span><span class='line'>{
</span><span class='line'>&#9;skb_push(skb, -skb_network_offset(skb));
</span><span class='line'>&#9;return 0;
</span><span class='line'>}
</span><span class='line'>static int ipip_xfrm_rcv(struct xfrm_state *x, struct sk_buff *skb)
</span><span class='line'>{
</span><span class='line'>&#9;return ip_hdr(skb)-&gt;protocol;
</span><span class='line'>}</span></code></pre></td></tr></table></div></figure>


<p>[模式函数实现]</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
<span class='line-number'>16</span>
<span class='line-number'>17</span>
<span class='line-number'>18</span>
<span class='line-number'>19</span>
<span class='line-number'>20</span>
<span class='line-number'>21</span>
<span class='line-number'>22</span>
<span class='line-number'>23</span>
<span class='line-number'>24</span>
<span class='line-number'>25</span>
<span class='line-number'>26</span>
<span class='line-number'>27</span>
<span class='line-number'>28</span>
<span class='line-number'>29</span>
<span class='line-number'>30</span>
<span class='line-number'>31</span>
<span class='line-number'>32</span>
<span class='line-number'>33</span>
<span class='line-number'>34</span>
<span class='line-number'>35</span>
<span class='line-number'>36</span>
<span class='line-number'>37</span>
<span class='line-number'>38</span>
<span class='line-number'>39</span>
<span class='line-number'>40</span>
<span class='line-number'>41</span>
<span class='line-number'>42</span>
<span class='line-number'>43</span>
<span class='line-number'>44</span>
<span class='line-number'>45</span>
<span class='line-number'>46</span>
<span class='line-number'>47</span>
<span class='line-number'>48</span>
<span class='line-number'>49</span>
<span class='line-number'>50</span>
<span class='line-number'>51</span>
<span class='line-number'>52</span>
<span class='line-number'>53</span>
<span class='line-number'>54</span>
<span class='line-number'>55</span>
<span class='line-number'>56</span>
<span class='line-number'>57</span>
<span class='line-number'>58</span>
<span class='line-number'>59</span>
<span class='line-number'>60</span>
<span class='line-number'>61</span>
<span class='line-number'>62</span>
<span class='line-number'>63</span>
<span class='line-number'>64</span>
<span class='line-number'>65</span>
<span class='line-number'>66</span>
<span class='line-number'>67</span>
<span class='line-number'>68</span>
<span class='line-number'>69</span>
<span class='line-number'>70</span>
<span class='line-number'>71</span>
<span class='line-number'>72</span>
<span class='line-number'>73</span>
<span class='line-number'>74</span>
<span class='line-number'>75</span>
<span class='line-number'>76</span>
<span class='line-number'>77</span>
<span class='line-number'>78</span>
<span class='line-number'>79</span>
<span class='line-number'>80</span>
<span class='line-number'>81</span>
<span class='line-number'>82</span>
<span class='line-number'>83</span>
<span class='line-number'>84</span>
<span class='line-number'>85</span>
<span class='line-number'>86</span>
<span class='line-number'>87</span>
<span class='line-number'>88</span>
<span class='line-number'>89</span>
<span class='line-number'>90</span>
<span class='line-number'>91</span>
<span class='line-number'>92</span>
<span class='line-number'>93</span>
<span class='line-number'>94</span>
<span class='line-number'>95</span>
<span class='line-number'>96</span>
<span class='line-number'>97</span>
<span class='line-number'>98</span>
<span class='line-number'>99</span>
<span class='line-number'>100</span>
<span class='line-number'>101</span>
<span class='line-number'>102</span>
<span class='line-number'>103</span>
<span class='line-number'>104</span>
<span class='line-number'>105</span>
<span class='line-number'>106</span>
<span class='line-number'>107</span>
<span class='line-number'>108</span>
<span class='line-number'>109</span>
<span class='line-number'>110</span>
<span class='line-number'>111</span>
<span class='line-number'>112</span>
<span class='line-number'>113</span>
<span class='line-number'>114</span>
<span class='line-number'>115</span>
<span class='line-number'>116</span>
<span class='line-number'>117</span>
<span class='line-number'>118</span>
<span class='line-number'>119</span>
<span class='line-number'>120</span>
<span class='line-number'>121</span>
<span class='line-number'>122</span>
<span class='line-number'>123</span>
<span class='line-number'>124</span>
<span class='line-number'>125</span>
<span class='line-number'>126</span>
<span class='line-number'>127</span>
<span class='line-number'>128</span>
<span class='line-number'>129</span>
<span class='line-number'>130</span>
<span class='line-number'>131</span>
<span class='line-number'>132</span>
<span class='line-number'>133</span>
<span class='line-number'>134</span>
<span class='line-number'>135</span>
<span class='line-number'>136</span>
<span class='line-number'>137</span>
<span class='line-number'>138</span>
<span class='line-number'>139</span>
<span class='line-number'>140</span>
<span class='line-number'>141</span>
<span class='line-number'>142</span>
<span class='line-number'>143</span>
<span class='line-number'>144</span>
<span class='line-number'>145</span>
<span class='line-number'>146</span>
<span class='line-number'>147</span>
<span class='line-number'>148</span>
<span class='line-number'>149</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>static struct xfrm_mode xfrm4_tunnel_mode = { //通道模式结构定义  net/ipv4/xfrm4_mode_tunnel.c
</span><span class='line'>&#9;.input = xfrm4_tunnel_input,
</span><span class='line'>&#9;.output = xfrm4_tunnel_output,
</span><span class='line'>&#9;.owner = THIS_MODULE,
</span><span class='line'>&#9;.encap = XFRM_MODE_TUNNEL,
</span><span class='line'>&#9;.flags = XFRM_MODE_FLAG_TUNNEL,
</span><span class='line'>};
</span><span class='line'>&#9;通道模式下的接收函数, 解封装
</span><span class='line'>static int xfrm4_tunnel_input(struct xfrm_state *x, struct sk_buff *skb)
</span><span class='line'>{
</span><span class='line'>&#9;struct iphdr *iph = ip_hdr(skb);
</span><span class='line'>&#9;const unsigned char *old_mac;
</span><span class='line'>&#9;int err = -EINVAL;
</span><span class='line'>
</span><span class='line'>&#9;switch (iph-&gt;protocol){//IP协议为IPPROTO_IPIP(4)
</span><span class='line'>&#9;&#9;case IPPROTO_IPIP:
</span><span class='line'>&#9;&#9;&#9;break;
</span><span class='line'>#if defined(CONFIG_IPV6) || defined (CONFIG_IPV6_MODULE)
</span><span class='line'>&#9;&#9;case IPPROTO_IPV6:
</span><span class='line'>&#9;&#9;&#9;break;
</span><span class='line'>#endif
</span><span class='line'>&#9;&#9;default:
</span><span class='line'>&#9;&#9;&#9;goto out;
</span><span class='line'>&#9;}
</span><span class='line'>&#9;//需要在skb头留出IP头的长度(20字节)
</span><span class='line'>&#9;if (!pskb_may_pull(skb, sizeof(struct iphdr)))
</span><span class='line'>&#9;&#9;goto out;
</span><span class='line'>
</span><span class='line'>&#9;//如果是clone包,重新拷贝一个
</span><span class='line'>&#9;if (skb_cloned(skb) && (err = pskb_expand_head(skb, 0, 0, GFP_ATOMIC)))
</span><span class='line'>&#9;&#9;goto out;
</span><span class='line'>
</span><span class='line'>&#9;iph = ip_hdr(skb);
</span><span class='line'>&#9;if (iph-&gt;protocol == IPPROTO_IPIP) {
</span><span class='line'>&#9;&#9;if (x-&gt;props.flags & XFRM_STATE_DECAP_DSCP)//复制dscp字段
</span><span class='line'>&#9;&#9;&#9;ipv4_copy_dscp(iph, ipip_hdr(skb));
</span><span class='line'>
</span><span class='line'>&#9;&#9;if (!(x-&gt;props.flags & XFRM_STATE_NOECN))//非XFRM_STATE_NOECN时进行ECN解封装
</span><span class='line'>&#9;&#9;&#9;ipip_ecn_decapsulate(skb);
</span><span class='line'>&#9;}
</span><span class='line'>#if defined(CONFIG_IPV6) || defined (CONFIG_IPV6_MODULE)
</span><span class='line'>&#9;else {
</span><span class='line'>&#9;&#9;if (!(x-&gt;props.flags & XFRM_STATE_NOECN))
</span><span class='line'>&#9;&#9;&#9;ipip6_ecn_decapsulate(iph, skb);
</span><span class='line'>&#9;&#9;skb-&gt;protocol = htons(ETH_P_IPV6);
</span><span class='line'>&#9;}
</span><span class='line'>#endif
</span><span class='line'>&#9;//将硬件地址挪到数据包缓冲区前
</span><span class='line'>&#9;old_mac = skb_mac_header(skb);//取出mac头位置
</span><span class='line'>&#9;//现在skb-&gt;data指向内部ip头，所以下面在内部ip头前面把原来的mac头复制过去
</span><span class='line'>&#9;skb_set_mac_header(skb, -skb-&gt;mac_len);
</span><span class='line'>&#9;memmove(skb_mac_header(skb), old_mac, skb-&gt;mac_len);
</span><span class='line'>&#9;skb_reset_network_header(skb);//重置网络头，网络头为内部ip头，现在外部ip头已经被剥离（被mac头复盖了)
</span><span class='line'>&#9;err = 0;
</span><span class='line'>out:
</span><span class='line'>&#9;return err;
</span><span class='line'>}
</span><span class='line'>&#9;通道模式下的数据发出函数, 进行封装
</span><span class='line'>static int xfrm4_tunnel_output(struct xfrm_state *x, struct sk_buff *skb)
</span><span class='line'>{
</span><span class='line'>&#9;struct dst_entry *dst = skb-&gt;dst;
</span><span class='line'>&#9;struct xfrm_dst *xdst = (struct xfrm_dst*)dst;
</span><span class='line'>&#9;struct iphdr *iph, *top_iph;
</span><span class='line'>&#9;int flags;
</span><span class='line'>
</span><span class='line'>&#9;iph = ip_hdr(skb);
</span><span class='line'>&#9;//数据头部增加外部IP头的长度，重置网络头位置
</span><span class='line'>&#9;skb_set_network_header(skb, -x-&gt;props.header_len);
</span><span class='line'>&#9;skb-&gt;mac_header = skb-&gt;network_header +  offsetof(struct iphdr, protocol);//mac头指向ip协议字段
</span><span class='line'>&#9;skb-&gt;transport_header = skb-&gt;network_header + sizeof(*iph);//传输头指向ip头后面
</span><span class='line'>
</span><span class='line'>&#9;top_iph = ip_hdr(skb); //获取外部ip头
</span><span class='line'>&#9;//填写外部IP头参数
</span><span class='line'>&#9;top_iph-&gt;ihl = 5;
</span><span class='line'>&#9;top_iph-&gt;version = 4;
</span><span class='line'>
</span><span class='line'>&#9;flags = x-&gt;props.flags;
</span><span class='line'>
</span><span class='line'>&#9;/* DS disclosed */
</span><span class='line'>&#9;if (xdst-&gt;route-&gt;ops-&gt;family == AF_INET) {
</span><span class='line'>&#9;&#9;top_iph-&gt;protocol = IPPROTO_IPIP;//外部IP头内的协议号为IPIP(4)
</span><span class='line'>&#9;&#9;top_iph-&gt;tos = INET_ECN_encapsulate(iph-&gt;tos, iph-&gt;tos);//重新计算TOS
</span><span class='line'>&#9;&#9;top_iph-&gt;frag_off = (flags & XFRM_STATE_NOPMTUDISC) ?  0 : (iph-&gt;frag_off & htons(IP_DF));//处理分片包情况
</span><span class='line'>&#9;}
</span><span class='line'>#if defined(CONFIG_IPV6) || defined (CONFIG_IPV6_MODULE)
</span><span class='line'>&#9;else {
</span><span class='line'>&#9;&#9;struct ipv6hdr *ipv6h = (struct ipv6hdr*)iph;
</span><span class='line'>&#9;&#9;top_iph-&gt;protocol = IPPROTO_IPV6;
</span><span class='line'>&#9;&#9;top_iph-&gt;tos = INET_ECN_encapsulate(iph-&gt;tos, ipv6_get_dsfield(ipv6h));
</span><span class='line'>&#9;&#9;top_iph-&gt;frag_off = 0;
</span><span class='line'>&#9;}
</span><span class='line'>#endif
</span><span class='line'>&#9;if (flags & XFRM_STATE_NOECN)
</span><span class='line'>&#9;&#9;IP_ECN_clear(top_iph);
</span><span class='line'>
</span><span class='line'>&#9;if (!top_iph-&gt;frag_off)
</span><span class='line'>&#9;&#9;__ip_select_ident(top_iph, dst-&gt;child, 0);
</span><span class='line'>
</span><span class='line'>&#9;top_iph-&gt;ttl = dst_metric(dst-&gt;child, RTAX_HOPLIMIT);
</span><span class='line'>
</span><span class='line'>&#9;top_iph-&gt;saddr = x-&gt;props.saddr.a4;//外部源地址用proposal中的源地址
</span><span class='line'>&#9;top_iph-&gt;daddr = x-&gt;id.daddr.a4;//外部目的地址是SA中的目的地址
</span><span class='line'>
</span><span class='line'>&#9;skb-&gt;protocol = htons(ETH_P_IP);
</span><span class='line'>
</span><span class='line'>&#9;memset(&(IPCB(skb)-&gt;opt), 0, sizeof(struct ip_options));//IP选项部分设置为0
</span><span class='line'>&#9;return 0;
</span><span class='line'>}
</span><span class='line'>static struct xfrm_mode xfrm4_transport_mode = { //传输模式结构定义  net/ipv4/xfrm4_mode_transport.c
</span><span class='line'>&#9;.input = xfrm4_transport_input,
</span><span class='line'>&#9;.output = xfrm4_transport_output,
</span><span class='line'>&#9;.owner = THIS_MODULE,
</span><span class='line'>&#9;.encap = XFRM_MODE_TRANSPORT,
</span><span class='line'>};
</span><span class='line'>&#9;传输模式下的数据输入函数
</span><span class='line'>static int xfrm4_transport_input(struct xfrm_state *x, struct sk_buff *skb)
</span><span class='line'>{
</span><span class='line'>&#9;int ihl = skb-&gt;data - skb_transport_header(skb); //获取ip头长度
</span><span class='line'>
</span><span class='line'>&#9;if (skb-&gt;transport_header != skb-&gt;network_header) {
</span><span class='line'>&#9;&#9;//移动网络头到传输头位置，现在传输层头指向的是data前ip头长度字节位置
</span><span class='line'>&#9;&#9;memmove(skb_transport_header(skb), skb_network_header(skb), ihl);
</span><span class='line'>&#9;&#9;skb-&gt;network_header = skb-&gt;transport_header;//设置网络头
</span><span class='line'>&#9;}
</span><span class='line'>&#9;ip_hdr(skb)-&gt;tot_len = htons(skb-&gt;len + ihl); //重新对数据包长度赋值
</span><span class='line'>&#9;skb_reset_transport_header(skb); //重置传输头位置，为data位置
</span><span class='line'>&#9;return 0;
</span><span class='line'>}
</span><span class='line'>&#9;传输模式下的数据发出函数
</span><span class='line'>static int xfrm4_transport_output(struct xfrm_state *x, struct sk_buff *skb)
</span><span class='line'>{
</span><span class='line'>&#9;struct iphdr *iph = ip_hdr(skb);
</span><span class='line'>&#9;int ihl = iph-&gt;ihl * 4;
</span><span class='line'>
</span><span class='line'>&#9;skb_set_network_header(skb, -x-&gt;props.header_len); //重新设置网络头位置，向前移出一个props.header_len长的空位
</span><span class='line'>&#9;skb-&gt;mac_header = skb-&gt;network_header + offsetof(struct iphdr, protocol); //mac头值设置为ip头中协议字段的位置
</span><span class='line'>&#9;skb-&gt;transport_header = skb-&gt;network_header + ihl; //传输头在网络头 + ip头长度后面的位置
</span><span class='line'>&#9;__skb_pull(skb, ihl);//将skb-&gt;data移动到ip头后面
</span><span class='line'>
</span><span class='line'>&#9;memmove(skb_network_header(skb), iph, ihl); //拷贝原始ip头到新网络头位置
</span><span class='line'>&#9;return 0;
</span><span class='line'>}
</span><span class='line'>static struct xfrm_mode xfrm4_beet_mode = {  //beet模式  net/ipv4/xfrm4_mode_beet.c
</span><span class='line'>&#9;.input = xfrm4_beet_input,
</span><span class='line'>&#9;.output = xfrm4_beet_output,
</span><span class='line'>&#9;.owner = THIS_MODULE,
</span><span class='line'>&#9;.encap = XFRM_MODE_BEET,
</span><span class='line'>&#9;.flags = XFRM_MODE_FLAG_TUNNEL,
</span><span class='line'>};</span></code></pre></td></tr></table></div></figure>


<p>[IPV4下的xfrm策略]</p>

<p>IPV4的策略协议相关处理结构定义如下.</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
<span class='line-number'>16</span>
<span class='line-number'>17</span>
<span class='line-number'>18</span>
<span class='line-number'>19</span>
<span class='line-number'>20</span>
<span class='line-number'>21</span>
<span class='line-number'>22</span>
<span class='line-number'>23</span>
<span class='line-number'>24</span>
<span class='line-number'>25</span>
<span class='line-number'>26</span>
<span class='line-number'>27</span>
<span class='line-number'>28</span>
<span class='line-number'>29</span>
<span class='line-number'>30</span>
<span class='line-number'>31</span>
<span class='line-number'>32</span>
<span class='line-number'>33</span>
<span class='line-number'>34</span>
<span class='line-number'>35</span>
<span class='line-number'>36</span>
<span class='line-number'>37</span>
<span class='line-number'>38</span>
<span class='line-number'>39</span>
<span class='line-number'>40</span>
<span class='line-number'>41</span>
<span class='line-number'>42</span>
<span class='line-number'>43</span>
<span class='line-number'>44</span>
<span class='line-number'>45</span>
<span class='line-number'>46</span>
<span class='line-number'>47</span>
<span class='line-number'>48</span>
<span class='line-number'>49</span>
<span class='line-number'>50</span>
<span class='line-number'>51</span>
<span class='line-number'>52</span>
<span class='line-number'>53</span>
<span class='line-number'>54</span>
<span class='line-number'>55</span>
<span class='line-number'>56</span>
<span class='line-number'>57</span>
<span class='line-number'>58</span>
<span class='line-number'>59</span>
<span class='line-number'>60</span>
<span class='line-number'>61</span>
<span class='line-number'>62</span>
<span class='line-number'>63</span>
<span class='line-number'>64</span>
<span class='line-number'>65</span>
<span class='line-number'>66</span>
<span class='line-number'>67</span>
<span class='line-number'>68</span>
<span class='line-number'>69</span>
<span class='line-number'>70</span>
<span class='line-number'>71</span>
<span class='line-number'>72</span>
<span class='line-number'>73</span>
<span class='line-number'>74</span>
<span class='line-number'>75</span>
<span class='line-number'>76</span>
<span class='line-number'>77</span>
<span class='line-number'>78</span>
<span class='line-number'>79</span>
<span class='line-number'>80</span>
<span class='line-number'>81</span>
<span class='line-number'>82</span>
<span class='line-number'>83</span>
<span class='line-number'>84</span>
<span class='line-number'>85</span>
<span class='line-number'>86</span>
<span class='line-number'>87</span>
<span class='line-number'>88</span>
<span class='line-number'>89</span>
<span class='line-number'>90</span>
<span class='line-number'>91</span>
<span class='line-number'>92</span>
<span class='line-number'>93</span>
<span class='line-number'>94</span>
<span class='line-number'>95</span>
<span class='line-number'>96</span>
<span class='line-number'>97</span>
<span class='line-number'>98</span>
<span class='line-number'>99</span>
<span class='line-number'>100</span>
<span class='line-number'>101</span>
<span class='line-number'>102</span>
<span class='line-number'>103</span>
<span class='line-number'>104</span>
<span class='line-number'>105</span>
<span class='line-number'>106</span>
<span class='line-number'>107</span>
<span class='line-number'>108</span>
<span class='line-number'>109</span>
<span class='line-number'>110</span>
<span class='line-number'>111</span>
<span class='line-number'>112</span>
<span class='line-number'>113</span>
<span class='line-number'>114</span>
<span class='line-number'>115</span>
<span class='line-number'>116</span>
<span class='line-number'>117</span>
<span class='line-number'>118</span>
<span class='line-number'>119</span>
<span class='line-number'>120</span>
<span class='line-number'>121</span>
<span class='line-number'>122</span>
<span class='line-number'>123</span>
<span class='line-number'>124</span>
<span class='line-number'>125</span>
<span class='line-number'>126</span>
<span class='line-number'>127</span>
<span class='line-number'>128</span>
<span class='line-number'>129</span>
<span class='line-number'>130</span>
<span class='line-number'>131</span>
<span class='line-number'>132</span>
<span class='line-number'>133</span>
<span class='line-number'>134</span>
<span class='line-number'>135</span>
<span class='line-number'>136</span>
<span class='line-number'>137</span>
<span class='line-number'>138</span>
<span class='line-number'>139</span>
<span class='line-number'>140</span>
<span class='line-number'>141</span>
<span class='line-number'>142</span>
<span class='line-number'>143</span>
<span class='line-number'>144</span>
<span class='line-number'>145</span>
<span class='line-number'>146</span>
<span class='line-number'>147</span>
<span class='line-number'>148</span>
<span class='line-number'>149</span>
<span class='line-number'>150</span>
<span class='line-number'>151</span>
<span class='line-number'>152</span>
<span class='line-number'>153</span>
<span class='line-number'>154</span>
<span class='line-number'>155</span>
<span class='line-number'>156</span>
<span class='line-number'>157</span>
<span class='line-number'>158</span>
<span class='line-number'>159</span>
<span class='line-number'>160</span>
<span class='line-number'>161</span>
<span class='line-number'>162</span>
<span class='line-number'>163</span>
<span class='line-number'>164</span>
<span class='line-number'>165</span>
<span class='line-number'>166</span>
<span class='line-number'>167</span>
<span class='line-number'>168</span>
<span class='line-number'>169</span>
<span class='line-number'>170</span>
<span class='line-number'>171</span>
<span class='line-number'>172</span>
<span class='line-number'>173</span>
<span class='line-number'>174</span>
<span class='line-number'>175</span>
<span class='line-number'>176</span>
<span class='line-number'>177</span>
<span class='line-number'>178</span>
<span class='line-number'>179</span>
<span class='line-number'>180</span>
<span class='line-number'>181</span>
<span class='line-number'>182</span>
<span class='line-number'>183</span>
<span class='line-number'>184</span>
<span class='line-number'>185</span>
<span class='line-number'>186</span>
<span class='line-number'>187</span>
<span class='line-number'>188</span>
<span class='line-number'>189</span>
<span class='line-number'>190</span>
<span class='line-number'>191</span>
<span class='line-number'>192</span>
<span class='line-number'>193</span>
<span class='line-number'>194</span>
<span class='line-number'>195</span>
<span class='line-number'>196</span>
<span class='line-number'>197</span>
<span class='line-number'>198</span>
<span class='line-number'>199</span>
<span class='line-number'>200</span>
<span class='line-number'>201</span>
<span class='line-number'>202</span>
<span class='line-number'>203</span>
<span class='line-number'>204</span>
<span class='line-number'>205</span>
<span class='line-number'>206</span>
<span class='line-number'>207</span>
<span class='line-number'>208</span>
<span class='line-number'>209</span>
<span class='line-number'>210</span>
<span class='line-number'>211</span>
<span class='line-number'>212</span>
<span class='line-number'>213</span>
<span class='line-number'>214</span>
<span class='line-number'>215</span>
<span class='line-number'>216</span>
<span class='line-number'>217</span>
<span class='line-number'>218</span>
<span class='line-number'>219</span>
<span class='line-number'>220</span>
<span class='line-number'>221</span>
<span class='line-number'>222</span>
<span class='line-number'>223</span>
<span class='line-number'>224</span>
<span class='line-number'>225</span>
<span class='line-number'>226</span>
<span class='line-number'>227</span>
<span class='line-number'>228</span>
<span class='line-number'>229</span>
<span class='line-number'>230</span>
<span class='line-number'>231</span>
<span class='line-number'>232</span>
<span class='line-number'>233</span>
<span class='line-number'>234</span>
<span class='line-number'>235</span>
<span class='line-number'>236</span>
<span class='line-number'>237</span>
<span class='line-number'>238</span>
<span class='line-number'>239</span>
<span class='line-number'>240</span>
<span class='line-number'>241</span>
<span class='line-number'>242</span>
<span class='line-number'>243</span>
<span class='line-number'>244</span>
<span class='line-number'>245</span>
<span class='line-number'>246</span>
<span class='line-number'>247</span>
<span class='line-number'>248</span>
<span class='line-number'>249</span>
<span class='line-number'>250</span>
<span class='line-number'>251</span>
<span class='line-number'>252</span>
<span class='line-number'>253</span>
<span class='line-number'>254</span>
<span class='line-number'>255</span>
<span class='line-number'>256</span>
<span class='line-number'>257</span>
<span class='line-number'>258</span>
<span class='line-number'>259</span>
<span class='line-number'>260</span>
<span class='line-number'>261</span>
<span class='line-number'>262</span>
<span class='line-number'>263</span>
<span class='line-number'>264</span>
<span class='line-number'>265</span>
<span class='line-number'>266</span>
<span class='line-number'>267</span>
<span class='line-number'>268</span>
<span class='line-number'>269</span>
<span class='line-number'>270</span>
<span class='line-number'>271</span>
<span class='line-number'>272</span>
<span class='line-number'>273</span>
<span class='line-number'>274</span>
<span class='line-number'>275</span>
<span class='line-number'>276</span>
<span class='line-number'>277</span>
<span class='line-number'>278</span>
<span class='line-number'>279</span>
<span class='line-number'>280</span>
<span class='line-number'>281</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>static struct xfrm_policy_afinfo xfrm4_policy_afinfo = { //net/ipv4/xfrm4_policy.c
</span><span class='line'>&#9;.family =               AF_INET,
</span><span class='line'>&#9;.dst_ops =              &xfrm4_dst_ops,
</span><span class='line'>&#9;.dst_lookup =           xfrm4_dst_lookup,
</span><span class='line'>&#9;.get_saddr =            xfrm4_get_saddr,
</span><span class='line'>&#9;.find_bundle =          __xfrm4_find_bundle,
</span><span class='line'>&#9;.bundle_create =        __xfrm4_bundle_create,
</span><span class='line'>&#9;.decode_session =       _decode_session4,
</span><span class='line'>};
</span><span class='line'>&#9;IPV4的路由查找, 就是普通是路由查找方法，返回0成功
</span><span class='line'>static int xfrm4_dst_lookup(struct xfrm_dst **dst, struct flowi *fl)
</span><span class='line'>{
</span><span class='line'>&#9;return __ip_route_output_key((struct rtable**)dst, fl);
</span><span class='line'>}
</span><span class='line'>&#9;查找地址, 这个函数是在通道模式下, 源地址没明确指定时调用的,查找获取外部头中的源地址
</span><span class='line'>static int xfrm4_get_saddr(xfrm_address_t *saddr, xfrm_address_t *daddr)
</span><span class='line'>{
</span><span class='line'>&#9;struct rtable *rt;
</span><span class='line'>&#9;//通道的流结构定义,用于查找路由
</span><span class='line'>&#9;struct flowi fl_tunnel = {
</span><span class='line'>&#9;&#9;.nl_u = {
</span><span class='line'>&#9;&#9;&#9;.ip4_u = {
</span><span class='line'>&#9;&#9;&#9;&#9;.daddr = daddr-&gt;a4,
</span><span class='line'>&#9;&#9;&#9;},
</span><span class='line'>
</span><span class='line'>&#9;&#9;},
</span><span class='line'>&#9;};
</span><span class='line'>&#9;//根据目的地址找路由
</span><span class='line'>&#9;if (!xfrm4_dst_lookup((struct xfrm_dst **)&rt, &fl_tunnel)) {
</span><span class='line'>&#9;&#9;saddr-&gt;a4 = rt-&gt;rt_src;//将找到的路由项中的源地址作为通道模式下的外部源地址
</span><span class='line'>&#9;&#9;dst_release(&rt-&gt;u.dst);
</span><span class='line'>&#9;&#9;return 0;
</span><span class='line'>&#9;}
</span><span class='line'>&#9;return -EHOSTUNREACH;
</span><span class='line'>}
</span><span class='line'>查找策略中的安全路由, 查找条件是流结构的定义的参数
</span><span class='line'>static struct dst_entry * __xfrm4_find_bundle(struct flowi *fl, struct xfrm_policy *policy)
</span><span class='line'>{
</span><span class='line'>&#9;struct dst_entry *dst;
</span><span class='line'>&#9;read_lock_bh(&policy-&gt;lock);
</span><span class='line'>
</span><span class='line'>&#9;//遍历策略的安全路由链表
</span><span class='line'>&#9;for (dst = policy-&gt;bundles; dst; dst = dst-&gt;next) {
</span><span class='line'>&#9;&#9;struct xfrm_dst *xdst = (struct xfrm_dst*)dst;
</span><span class='line'>&#9;&#9;//比较网卡位置, 目的地址, 源地址, TOS值是否匹配
</span><span class='line'>&#9;&#9;//同时检查该安全路由是否可用
</span><span class='line'>&#9;&#9;if (xdst-&gt;u.rt.fl.oif == fl-&gt;oif &&     /*XXX*/
</span><span class='line'>&#9;&#9;&#9;&#9;xdst-&gt;u.rt.fl.fl4_dst == fl-&gt;fl4_dst &&
</span><span class='line'>&#9;&#9;&#9;&#9;xdst-&gt;u.rt.fl.fl4_src == fl-&gt;fl4_src &&
</span><span class='line'>&#9;&#9;&#9;&#9;xdst-&gt;u.rt.fl.fl4_tos == fl-&gt;fl4_tos &&
</span><span class='line'>&#9;&#9;&#9;&#9;xfrm_bundle_ok(policy, xdst, fl, AF_INET, 0)) {
</span><span class='line'>&#9;&#9;&#9;dst_clone(dst);
</span><span class='line'>&#9;&#9;&#9;break;
</span><span class='line'>&#9;&#9;}
</span><span class='line'>&#9;}
</span><span class='line'>&#9;read_unlock_bh(&policy-&gt;lock);
</span><span class='line'>&#9;return dst;
</span><span class='line'>}
</span><span class='line'>创建安全路由
</span><span class='line'>static int __xfrm4_bundle_create(struct xfrm_policy *policy, struct xfrm_state **xfrm, int nx, struct flowi *fl, struct dst_entry **dst_p)
</span><span class='line'>{
</span><span class='line'>&#9;struct dst_entry *dst, *dst_prev;
</span><span class='line'>&#9;struct rtable *rt0 = (struct rtable*)(*dst_p);
</span><span class='line'>&#9;struct rtable *rt = rt0;
</span><span class='line'>&#9;struct flowi fl_tunnel = {
</span><span class='line'>&#9;&#9;.nl_u = {
</span><span class='line'>&#9;&#9;&#9;.ip4_u = {
</span><span class='line'>&#9;&#9;&#9;&#9;.saddr = fl-&gt;fl4_src,
</span><span class='line'>&#9;&#9;&#9;&#9;.daddr = fl-&gt;fl4_dst,
</span><span class='line'>&#9;&#9;&#9;&#9;.tos = fl-&gt;fl4_tos
</span><span class='line'>&#9;&#9;&#9;}
</span><span class='line'>&#9;&#9;}
</span><span class='line'>&#9;};
</span><span class='line'>&#9;int i;
</span><span class='line'>&#9;int err;
</span><span class='line'>&#9;int header_len = 0;
</span><span class='line'>&#9;int trailer_len = 0;
</span><span class='line'>
</span><span class='line'>&#9;dst = dst_prev = NULL;
</span><span class='line'>&#9;dst_hold(&rt-&gt;u.dst);
</span><span class='line'>
</span><span class='line'>&#9;//循环次数为策略中SA的数量, 每个SA对应一个安全路由, 一个安全路由对应对数据包的一个操作: 如压缩, ESP封装, AH封装等
</span><span class='line'>&#9;for (i = 0; i &lt; nx; i++) {
</span><span class='line'>&#9;&#9;//分配安全路由, 安全路由的操作结构是xfrm4_dst_ops
</span><span class='line'>&#9;&#9;//因为定义了很多不同类型的路由, 每种路由都有各自的操作结构, 这样在上层可用统一的接口进行路由处理
</span><span class='line'>&#9;&#9;struct dst_entry *dst1 = dst_alloc(&xfrm4_dst_ops);
</span><span class='line'>&#9;&#9;struct xfrm_dst *xdst;
</span><span class='line'>
</span><span class='line'>&#9;&#9;if (unlikely(dst1 == NULL)) {
</span><span class='line'>&#9;&#9;&#9;err = -ENOBUFS;
</span><span class='line'>&#9;&#9;&#9;dst_release(&rt-&gt;u.dst);
</span><span class='line'>&#9;&#9;&#9;goto error;
</span><span class='line'>&#9;&#9;}
</span><span class='line'>
</span><span class='line'>&#9;&#9;if (!dst)//第一次循环
</span><span class='line'>&#9;&#9;&#9;dst = dst1;
</span><span class='line'>
</span><span class='line'>&#9;&#9;else {//将新分配的安全路由作为前一个路由的child
</span><span class='line'>&#9;&#9;&#9;dst_prev-&gt;child = dst1;
</span><span class='line'>&#9;&#9;&#9;dst1-&gt;flags |= DST_NOHASH;
</span><span class='line'>&#9;&#9;&#9;dst_clone(dst1);
</span><span class='line'>&#9;&#9;}
</span><span class='line'>
</span><span class='line'>&#9;&#9;xdst = (struct xfrm_dst *)dst1;
</span><span class='line'>&#9;&#9;//安全路由中保留相应的普通路由
</span><span class='line'>&#9;&#9;xdst-&gt;route = &rt-&gt;u.dst;
</span><span class='line'>&#9;&#9;xdst-&gt;genid = xfrm[i]-&gt;genid;
</span><span class='line'>&#9;&#9;//新节点的next是上一个节点
</span><span class='line'>&#9;&#9;dst1-&gt;next = dst_prev;
</span><span class='line'>&#9;&#9;dst_prev = dst1;//现在prev指向新节点
</span><span class='line'>
</span><span class='line'>&#9;&#9;header_len += xfrm[i]-&gt;props.header_len;
</span><span class='line'>&#9;&#9;trailer_len += xfrm[i]-&gt;props.trailer_len;
</span><span class='line'>
</span><span class='line'>&#9;&#9;//如果是通道模式, 需要重新包裹外部IP头, 需要重新寻找外部IP头的路由
</span><span class='line'>&#9;&#9;if (xfrm[i]-&gt;props.mode != XFRM_MODE_TRANSPORT) {
</span><span class='line'>&#9;&#9;&#9;unsigned short encap_family = xfrm[i]-&gt;props.family;
</span><span class='line'>&#9;&#9;&#9;switch (encap_family) {
</span><span class='line'>&#9;&#9;&#9;&#9;case AF_INET:
</span><span class='line'>&#9;&#9;&#9;&#9;&#9;fl_tunnel.fl4_dst = xfrm[i]-&gt;id.daddr.a4;
</span><span class='line'>&#9;&#9;&#9;&#9;&#9;fl_tunnel.fl4_src = xfrm[i]-&gt;props.saddr.a4;
</span><span class='line'>&#9;&#9;&#9;&#9;&#9;break;
</span><span class='line'>#if defined(CONFIG_IPV6) || defined (CONFIG_IPV6_MODULE)
</span><span class='line'>&#9;&#9;&#9;&#9;case AF_INET6:
</span><span class='line'>&#9;&#9;&#9;&#9;&#9;ipv6_addr_copy(&fl_tunnel.fl6_dst, (struct in6_addr*)&xfrm[i]-&gt;id.daddr.a6);
</span><span class='line'>&#9;&#9;&#9;&#9;&#9;ipv6_addr_copy(&fl_tunnel.fl6_src, (struct in6_addr*)&xfrm[i]-&gt;props.saddr.a6);
</span><span class='line'>&#9;&#9;&#9;&#9;&#9;break;
</span><span class='line'>#endif
</span><span class='line'>&#9;&#9;&#9;&#9;default:
</span><span class='line'>&#9;&#9;&#9;&#9;&#9;BUG_ON(1);
</span><span class='line'>&#9;&#9;&#9;}
</span><span class='line'>&#9;&#9;&#9;err = xfrm_dst_lookup((struct xfrm_dst **)&rt, &fl_tunnel, encap_family);
</span><span class='line'>&#9;&#9;&#9;if (err)
</span><span class='line'>&#9;&#9;&#9;&#9;goto error;
</span><span class='line'>&#9;&#9;} else
</span><span class='line'>&#9;&#9;&#9;dst_hold(&rt-&gt;u.dst);
</span><span class='line'>&#9;}
</span><span class='line'>&#9;//将最新节点的child指向最后的普通路由
</span><span class='line'>&#9;dst_prev-&gt;child = &rt-&gt;u.dst;
</span><span class='line'>&#9;//最开始分配的安全路由的path指向最后的普通路由
</span><span class='line'>&#9;dst-&gt;path = &rt-&gt;u.dst;
</span><span class='line'>
</span><span class='line'>&#9;//将最开始的全路由点作为要返回的路由节点链表头
</span><span class='line'>&#9;*dst_p = dst;
</span><span class='line'>&#9;dst = dst_prev;//dst现在是最新分配的节点
</span><span class='line'>&#9;dst_prev = *dst_p;//prev现在指向最开始分配的全节点
</span><span class='line'>&#9;i = 0;
</span><span class='line'>
</span><span class='line'>&#9;为更好理解上面的操作, 用图来表示. 以上循环形成了下图水平方向的一个链表, 链表中的最左边的路由项节点dst为最老的安全路由项,
</span><span class='line'>&#9;新分配的安全路由项通过child链接成链表, child通过next指向老节点, 最后一项是数据包封装完后的最后普通路由项.
</span><span class='line'>&#9;垂直方向的链表是在xfrm_lookup()中形成的, 是多个策略同时起作用的情况, 一般情况下就只有一个策略, 本文中可不考虑多策略的情况.
</span><span class='line'>
</span><span class='line'>&#9;&#9;&#9;rt0.u.dst        rt.u.dst                rt.u.dst
</span><span class='line'>&#9;&#9;&#9;^               ^                      ^
</span><span class='line'>&#9;&#9;&#9;route |         route |             route   |           
</span><span class='line'>&#9;&#9;&#9;|       child     |       child          |
</span><span class='line'>&#9;&#9;&#9;bundle  +-----+  -----&gt; +-----+ -----&gt;     +-----+ child
</span><span class='line'>&#9;&#9;&#9;policy -------&gt;| dst  |  &lt;----- | dst  | &lt;----- ...  | dst | -----&gt; rt.u.dst (普通路由)
</span><span class='line'>&#9;&#9;&#9;+-----+   next   +-----+  next       +-----+
</span><span class='line'>&#9;&#9;&#9;|
</span><span class='line'>&#9;&#9;&#9;|next
</span><span class='line'>&#9;&#9;&#9;|
</span><span class='line'>&#9;&#9;&#9;V       child             child
</span><span class='line'>&#9;&#9;&#9;+-----+  -----&gt; +-----+ -----&gt;    +-----+ child
</span><span class='line'>&#9;&#9;&#9;| dst  |  &lt;----- | dst  | &lt;----- ...| dst  | -----&gt; rt.u.dst
</span><span class='line'>&#9;&#9;&#9;+-----+   next   +-----+  next      +-----+
</span><span class='line'>&#9;&#9;&#9;|
</span><span class='line'>&#9;&#9;&#9;|next
</span><span class='line'>&#9;&#9;&#9;|
</span><span class='line'>&#9;&#9;&#9;V
</span><span class='line'>&#9;....
</span><span class='line'>&#9;//对新生成的每个安全路由项填充结构参数
</span><span class='line'>&#9;for (; dst_prev != &rt-&gt;u.dst; dst_prev = dst_prev-&gt;child) {
</span><span class='line'>&#9;&#9;struct xfrm_dst *x = (struct xfrm_dst*)dst_prev;
</span><span class='line'>&#9;&#9;x-&gt;u.rt.fl = *fl;
</span><span class='line'>
</span><span class='line'>&#9;&#9;dst_prev-&gt;xfrm = xfrm[i++];
</span><span class='line'>&#9;&#9;dst_prev-&gt;dev = rt-&gt;u.dst.dev;
</span><span class='line'>&#9;&#9;if (rt-&gt;u.dst.dev)
</span><span class='line'>&#9;&#9;&#9;dev_hold(rt-&gt;u.dst.dev);
</span><span class='line'>
</span><span class='line'>&#9;&#9;dst_prev-&gt;obsolete      = -1;
</span><span class='line'>&#9;&#9;dst_prev-&gt;flags        |= DST_HOST;
</span><span class='line'>&#9;&#9;dst_prev-&gt;lastuse       = jiffies;
</span><span class='line'>&#9;&#9;dst_prev-&gt;header_len    = header_len;
</span><span class='line'>&#9;&#9;dst_prev-&gt;nfheader_len  = 0;
</span><span class='line'>&#9;&#9;dst_prev-&gt;trailer_len   = trailer_len;
</span><span class='line'>&#9;&#9;memcpy(&dst_prev-&gt;metrics, &x-&gt;route-&gt;metrics, sizeof(dst_prev-&gt;metrics));
</span><span class='line'>
</span><span class='line'>&#9;&#9;/* Copy neighbout for reachability confirmation */
</span><span class='line'>&#9;&#9;dst_prev-&gt;neighbour     = neigh_clone(rt-&gt;u.dst.neighbour);
</span><span class='line'>&#9;&#9;dst_prev-&gt;input         = rt-&gt;u.dst.input;
</span><span class='line'>&#9;&#9;//注意安全路由的输出函数是xfrm4_output，参考上面数据发送
</span><span class='line'>&#9;&#9;dst_prev-&gt;output = dst_prev-&gt;xfrm-&gt;outer_mode-&gt;afinfo-&gt;output;
</span><span class='line'>&#9;&#9;if (rt0-&gt;peer)
</span><span class='line'>&#9;&#9;&#9;atomic_inc(&rt0-&gt;peer-&gt;refcnt);
</span><span class='line'>
</span><span class='line'>&#9;&#9;x-&gt;u.rt.peer = rt0-&gt;peer;
</span><span class='line'>
</span><span class='line'>&#9;&#9;/* Sheit... I remember I did this right. Apparently,                               
</span><span class='line'>&#9;&#9; * it was magically lost, so this code needs audit */
</span><span class='line'>&#9;&#9;x-&gt;u.rt.rt_flags = rt0-&gt;rt_flags&(RTCF_BROADCAST|RTCF_MULTICAST|RTCF_LOCAL);
</span><span class='line'>&#9;&#9;x-&gt;u.rt.rt_type = rt0-&gt;rt_type;
</span><span class='line'>&#9;&#9;x-&gt;u.rt.rt_src = rt0-&gt;rt_src;
</span><span class='line'>&#9;&#9;x-&gt;u.rt.rt_dst = rt0-&gt;rt_dst;
</span><span class='line'>&#9;&#9;x-&gt;u.rt.rt_gateway = rt0-&gt;rt_gateway;
</span><span class='line'>&#9;&#9;x-&gt;u.rt.rt_spec_dst = rt0-&gt;rt_spec_dst;
</span><span class='line'>&#9;&#9;x-&gt;u.rt.idev = rt0-&gt;idev;
</span><span class='line'>&#9;&#9;in_dev_hold(rt0-&gt;idev);
</span><span class='line'>&#9;&#9;header_len -= x-&gt;u.dst.xfrm-&gt;props.header_len;
</span><span class='line'>&#9;&#9;trailer_len -= x-&gt;u.dst.xfrm-&gt;props.trailer_len;
</span><span class='line'>&#9;}
</span><span class='line'>&#9;//初始化路由项的MTU值
</span><span class='line'>&#9;xfrm_init_pmtu(dst);
</span><span class='line'>&#9;return 0;
</span><span class='line'>error:
</span><span class='line'>&#9;if (dst)
</span><span class='line'>
</span><span class='line'>&#9;&#9;dst_free(dst);
</span><span class='line'>&#9;return err;
</span><span class='line'>}
</span><span class='line'>&#9;解码skb数据, 填充流结构
</span><span class='line'>static void _decode_session4(struct sk_buff *skb, struct flowi *fl)
</span><span class='line'>{
</span><span class='line'>&#9;struct iphdr *iph = ip_hdr(skb);
</span><span class='line'>&#9;//xprth指向IP头后的上层协议头起始
</span><span class='line'>&#9;u8 *xprth = skb_network_header(skb) + iph-&gt;ihl * 4;
</span><span class='line'>&#9;memset(fl, 0, sizeof(struct flowi));
</span><span class='line'>
</span><span class='line'>&#9;if (!(iph-&gt;frag_off & htons(IP_MF | IP_OFFSET))) {//数据包必须不是分片包
</span><span class='line'>&#9;&#9;switch (iph-&gt;protocol) {
</span><span class='line'>&#9;&#9;&#9;//对UDP(17), TCP(6), SCTP(132)和DCCP(33)协议, 要提取源端口和目的端口
</span><span class='line'>&#9;&#9;&#9;//头4字节是源端口和目的端口
</span><span class='line'>&#9;&#9;&#9;case IPPROTO_UDP:
</span><span class='line'>&#9;&#9;&#9;case IPPROTO_UDPLITE:
</span><span class='line'>&#9;&#9;&#9;case IPPROTO_TCP:
</span><span class='line'>&#9;&#9;&#9;case IPPROTO_SCTP:
</span><span class='line'>&#9;&#9;&#9;case IPPROTO_DCCP:
</span><span class='line'>&#9;&#9;&#9;&#9;//要让skb预留出IP头长度加4字节的长度, 在IP层data应该指向最外面的IP头
</span><span class='line'>&#9;&#9;&#9;&#9;if (pskb_may_pull(skb, xprth + 4 - skb-&gt;data)) {
</span><span class='line'>&#9;&#9;&#9;&#9;&#9;__be16 *ports = (__be16 *)xprth;
</span><span class='line'>&#9;&#9;&#9;&#9;&#9;fl-&gt;fl_ip_sport = ports[0];
</span><span class='line'>&#9;&#9;&#9;&#9;&#9;fl-&gt;fl_ip_dport = ports[1];
</span><span class='line'>&#9;&#9;&#9;&#9;}
</span><span class='line'>&#9;&#9;&#9;&#9;break;
</span><span class='line'>&#9;&#9;&#9;case IPPROTO_ICMP://对ICMP(1)协议要提取ICMP包的类型和编码, 2字节
</span><span class='line'>&#9;&#9;&#9;&#9;if (pskb_may_pull(skb, xprth + 2 - skb-&gt;data)) {
</span><span class='line'>&#9;&#9;&#9;&#9;&#9;u8 *icmp = xprth;
</span><span class='line'>&#9;&#9;&#9;&#9;&#9;fl-&gt;fl_icmp_type = icmp[0];
</span><span class='line'>&#9;&#9;&#9;&#9;&#9;fl-&gt;fl_icmp_code = icmp[1];
</span><span class='line'>&#9;&#9;&#9;&#9;}
</span><span class='line'>&#9;&#9;&#9;&#9;break;
</span><span class='line'>&#9;&#9;&#9;case IPPROTO_ESP://对于ESP(50)协议要提取其中的SPI值, 4字节
</span><span class='line'>&#9;&#9;&#9;&#9;if (pskb_may_pull(skb, xprth + 4 - skb-&gt;data)) {
</span><span class='line'>&#9;&#9;&#9;&#9;&#9;__be32 *ehdr = (__be32 *)xprth;
</span><span class='line'>&#9;&#9;&#9;&#9;&#9;fl-&gt;fl_ipsec_spi = ehdr[0];
</span><span class='line'>&#9;&#9;&#9;&#9;}
</span><span class='line'>&#9;&#9;&#9;&#9;break;
</span><span class='line'>&#9;&#9;&#9;case IPPROTO_AH://对于AH(51)协议要提取其中的SPI值, 4字节
</span><span class='line'>&#9;&#9;&#9;&#9;if (pskb_may_pull(skb, xprth + 8 - skb-&gt;data)) {
</span><span class='line'>&#9;&#9;&#9;&#9;&#9;__be32 *ah_hdr = (__be32*)xprth;
</span><span class='line'>&#9;&#9;&#9;&#9;&#9;fl-&gt;fl_ipsec_spi = ah_hdr[1];
</span><span class='line'>&#9;&#9;&#9;&#9;}
</span><span class='line'>&#9;&#9;&#9;&#9;break;
</span><span class='line'>&#9;&#9;&#9;case IPPROTO_COMP://对于COMP(108)协议要提取其中CPI值作为SPI值, 2字节
</span><span class='line'>&#9;&#9;&#9;&#9;if (pskb_may_pull(skb, xprth + 4 - skb-&gt;data)) {
</span><span class='line'>&#9;&#9;&#9;&#9;&#9;__be16 *ipcomp_hdr = (__be16 *)xprth;
</span><span class='line'>&#9;&#9;&#9;&#9;&#9;fl-&gt;fl_ipsec_spi = htonl(ntohs(ipcomp_hdr[1]));
</span><span class='line'>&#9;&#9;&#9;&#9;}
</span><span class='line'>&#9;&#9;&#9;&#9;break;
</span><span class='line'>&#9;&#9;&#9;default:
</span><span class='line'>&#9;&#9;&#9;&#9;fl-&gt;fl_ipsec_spi = 0;
</span><span class='line'>&#9;&#9;&#9;&#9;break;
</span><span class='line'>&#9;&#9;}
</span><span class='line'>&#9;}
</span><span class='line'>&#9;//填充协议,源地址,目的地址, TOS参数
</span><span class='line'>&#9;fl-&gt;proto = iph-&gt;protocol;
</span><span class='line'>&#9;fl-&gt;fl4_dst = iph-&gt;daddr;
</span><span class='line'>&#9;fl-&gt;fl4_src = iph-&gt;saddr;
</span><span class='line'>&#9;fl-&gt;fl4_tos = iph-&gt;tos;
</span><span class='line'>}</span></code></pre></td></tr></table></div></figure>


<p>[网卡通知回调实现]</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
<span class='line-number'>16</span>
<span class='line-number'>17</span>
<span class='line-number'>18</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>xfrm的网卡通知回调结构
</span><span class='line'>static struct notifier_block xfrm_dev_notifier = {
</span><span class='line'>&#9;xfrm_dev_event,
</span><span class='line'>&#9;NULL,
</span><span class='line'>&#9;0
</span><span class='line'>};
</span><span class='line'>static int xfrm_dev_event(struct notifier_block *this, unsigned long event, void *ptr)
</span><span class='line'>{
</span><span class='line'>&#9;struct net_device *dev = ptr;
</span><span class='line'>&#9;if (dev-&gt;nd_net != &init_net)
</span><span class='line'>&#9;&#9;return NOTIFY_DONE;
</span><span class='line'>
</span><span class='line'>&#9;switch (event) {
</span><span class='line'>&#9;&#9;case NETDEV_DOWN: //如果网卡down掉的话, 清除相关的所有的xfrm路由项
</span><span class='line'>&#9;&#9;&#9;xfrm_flush_bundles(); 实现为xfrm_prune_bundles(stale_bundle);
</span><span class='line'>&#9;}
</span><span class='line'>&#9;return NOTIFY_DONE;
</span><span class='line'>}</span></code></pre></td></tr></table></div></figure>



</div>


  <footer>
    <p class="meta">
      
  

<span class="byline author vcard">Posted by <span class="fn">kk</span></span>

      




<time class='entry-date' datetime='2021-06-15T21:23:00+08:00'><span class='date'>2021-06-15</span> <span class='time'>21:23:00</span></time>
      

<span class="categories">
  
    <a class='category' href='/blog/cats/kernel/'>kernel</a>, <a class='category' href='/blog/cats/kernel~ipsec/'>ipsec</a>
  
</span>


    </p>
    
      
    
    <p class="meta">
      
        <a class="basic-alignment left" href="/blog/2021/06/15/net-clusterip/" title="Previous Post: ipt_CLUSTERIP">&laquo; ipt_CLUSTERIP</a>
      
      
        <a class="basic-alignment right" href="/blog/2021/06/15/net-ipsec-esp/" title="Next Post: Linux2.6下ESP包解析流程">Linux2.6下ESP包解析流程 &raquo;</a>
      
    </p>
    <p class="meta">
	<div style='white-space: nowrap;'>
	<img src="/images/wx_ok.png" width=150px; height=150px; style="margin-left:100px;">
	<img src="/images/ali_ok.png" width=150px; height=150px; style="margin-left:100px;">
	</div>
    </p>


<!-- alert 替代 -->
<script type="text/javascript">
	cssCode = "<style type='text/css'>"
		+ ".nbaMask { position: fixed; z-index: 1000; top: 0; right: 0; left: 0; bottom: 0; background: rgba(0, 0, 0, 0.5); } "
		+ ".nbaMaskTransparent { position: fixed; z-index: 1000; top: 0; right: 0; left: 0; bottom: 0; } "
		+ ".nbaDialog { position: fixed; z-index: 5000; width: 80%; max-width: 500px; top: 50%; left: 50%; -webkit-transform: translate(-50%, -50%); transform: translate(-50%, -50%); background-color: #fff; text-align: center; border-radius: 8px; overflow: hidden; opacity: 1; color: white; }"
		+ ".nbaDialog .nbaDialogHd { padding: .2rem .27rem .08rem .27rem; text-align: left; padding-left: 10px; padding-top: 10px; } "
		+ ".nbaDialog .nbaDialogHd .nbaDialogTitle { color:black; font-size: 17px; font-weight: 400; } "
		+ ".nbaDialog .nbaDialogBd { padding: 0 .27rem; font-size: 15px; line-height: 1.3; word-wrap: break-word; word-break: break-all; color: #000000; } "
		+ ".nbaDialog .nbaDialogFt { background: #1a6ada; float: right; margin-right:10px; margin-bottom:10px; position: relative; border-radius: 5px; width:60px;  line-height: 30px; font-size: 15px; display: -webkit-box; display: -webkit-flex; display: flex; } "
		+ ".nbaDialog .nbaDialogFt:after { content: ' '; position: absolute; left: 0; top: 0; right: 0; height: 1px; border-top: 1px solid #e6e6e6; color: #e6e6e6; -webkit-transform-origin: 0 0; transform-origin: 0 0; -webkit-transform: scaleY(0.5); transform: scaleY(0.5); } "
		+ ".nbaDialog .nbaDialogBtn { display: block; -webkit-box-flex: 1; -webkit-flex: 1; flex: 1; color: white; text-decoration: none; -webkit-tap-highlight-color: transparent; position: relative; margin-bottom: 0; } "
		+ ".nbaDialog .nbaDialogBtn:after { content: ' '; position: absolute; left: 0; top: 0; width: 1px; bottom: 0; border-left: 1px solid #e6e6e6; color: #e6e6e6; -webkit-transform-origin: 0 0; transform-origin: 0 0; -webkit-transform: scaleX(0.5); transform: scaleX(0.5); } "
		+ ".nbaDialog a { text-decoration: none; -webkit-tap-highlight-color: transparent; }"
		+ "</style>";

	htmlCode = "<div id='dialogs2' style='display: none'>"
		+ "  <div class='nbaMask'></div>"
		+ "  <div class='nbaDialog'>"
		+ "    <div class='nbaDialogHd'>"
		+ "        <strong class='nbaDialogTitle'>提示：</strong>"
		+ "    </div><br>"
		+ ' <div style="white-space: nowrap;"> <img src="/images/wx_ok.png" width="130px;" height="130px;"> <img src="/images/ali_ok.png" width="130px;" height="130px;" style="margin-left:100px;"> </div> '
		+ "    <div class='nbaDialogBd' id='dialog_msg2' style='white-space:normal;'>弹窗内容，告知当前状态、信息和解决方法，描述文字尽量控制在三行内</div>"
		+ "    <div class='nbaDialogHd'>"
		+ "        <strong class='nbaDialogTitle'></strong>"
		+ "    </div><br>"
		+ "    <div class='nbaDialogFt'>"
		+ "        <a href='javascript:;' class='nbaDialogBtn nbaDialogBtnPrimary' style='display:none;' id='dialog_ok2'>确定</a>"
		+ "    </div>"
		+ "  </div>"
		+ "</div>";

	htmlCode2 = "<div id='dialogs22' style='display: none;'>"
		+ "  <div class='nbaDialog' id='dialogs22_s' style='background:gray; top:50%; border-radius: 18px;'>"
		+ "    <div class='nbaDialogBd' id='dialog_msg22' style='white-space:normal; color:white;padding-top:10px;'>弹窗内容，告知当前状态、信息和解决方法，描述文字尽量控制在三行内</div>"
		+ "    <div class='nbaDialogHd'>"
		+ "        <strong class='nbaDialogTitle'></strong>"
		+ "    </div>"
		+ "  </div>"
		+ "</div>";

function showd()
{
	document.getElementById("dialog_ok2").style.display = '';
}

function alert_money(msg) {
	var div = document.createElement("div");
	div.innerHTML = cssCode + htmlCode;
	document.body.appendChild(div);

	var dialogs2 = document.getElementById("dialogs2");
	dialogs2.style.display = 'block';

	var dialog_msg2 = document.getElementById("dialog_msg2");
	dialog_msg2.innerHTML = msg;

	// var dialog_cancel = document.getElementById("dialog_cancel");
	//	dialog_cancel.onclick = function() {
	//	dialogs2.style.display = 'none';
	// };
	var dialog_ok2 = document.getElementById("dialog_ok2");
	dialog_ok2.onclick = function() {
		dialogs2.style.display = 'none';
		//callback();
	};

	setTimeout("showd()", 10*1000);
};

alert_money('');

</script>


  </footer>
</article>

</div>
<aside class="sidebar" id='load_sidebar'>
</aside>
<script type="text/javascript">
  $('#load_sidebar').load('/sidebar.html');
</script>

    </div>
  </div>
  <footer role="contentinfo">  Copyright &copy; 2024 - kk -
  <span class="credit">Powered by <a href="http://octopress.org">Octopress</a></span>
  <a title="Top" href="#" id="scroll2top" style="position: fixed; height: 50px; bottom: 30px; right: 25px; cursor: pointer; z-index: 9999; display: block; opacity: 1;"><img src="/images/scrollup.png"></a>
  <script src="/javascripts/scroll2top.js"></script>

<!-- Matomo -->
<script>
  var _paq = window._paq = window._paq || [];
  /* tracker methods like "setCustomDimension" should be called before "trackPageView" */
  _paq.push(['trackPageView']);
  _paq.push(['enableLinkTracking']);
  (function() {
    var u="//www.abcxyzkk.xyz/matomo/";
    _paq.push(['setTrackerUrl', u+'matomo.php']);
    _paq.push(['setSiteId', '1']);
    var d=document, g=d.createElement('script'), s=d.getElementsByTagName('script')[0];
    g.async=true; g.src=u+'matomo.js'; s.parentNode.insertBefore(g,s);
  })();
</script>
<!-- End Matomo Code -->


<!-- Histats.com  (div with counter) --><div id="histats_counter"></div>
<!-- Histats.com  START  (aync)-->
<!--
<script type="text/javascript">var _Hasync= _Hasync|| [];
_Hasync.push(['Histats.start', '1,4673876,4,107,170,20,00010000']);
_Hasync.push(['Histats.fasi', '1']);
_Hasync.push(['Histats.track_hits', '']);
(function() {
var hs = document.createElement('script'); hs.type = 'text/javascript'; hs.async = true;
hs.src = ('//s10.histats.com/js15_as.js');
(document.getElementsByTagName('head')[0] || document.getElementsByTagName('body')[0]).appendChild(hs);
})();</script>
<noscript><a href="/" target="_blank"><img  src="//sstatic1.histats.com/0.gif?4673876&101" alt="simple hit counter" border="0"></a></noscript>
-->
<!-- Histats.com  END  -->

<!--  <script type="text/javascript">var cnzz_protocol = (("https:" == document.location.protocol) ? " https://" : " http://");document.write(unescape("%3Cspan id='cnzz_stat_icon_1253604690'%3E%3C/span%3E%3Cscript src='" + cnzz_protocol + "s95.cnzz.com/z_stat.php%3Fid%3D1253604690' type='text/javascript'%3E%3C/script%3E"));</script>
-->


<!--
<script>

// TODO 无法获取框架内元素
function autoads()
{
try {
	console.log('start');
	var txt = document.getElementById('mys-content').innerHTML;
	var len = txt.length;
	var url = '';
	console.log(len);
	for (var i = 0; i < len - 10; i ++) {
		if (txt.substring(i, i + 6) == 'href="') {
			i = i + 6;
			url = '';
			for ( ; i < len; i ++) {
				if (txt[i] == '"')
					break;
				url += txt[i];
			}
			url = url.replace(/&amp;/g, '&');
		//	console.log(url);
		}
	}
	console.log(url);
	if (url != '' && Math.random() < 0.3)
		window.open(url, "_blank");
} catch (e) {
}
}

window.onload = function() {
	setTimeout("autoads()", 5*1000);
}
</script>
-->


</footer>
  





</body>
</html>
