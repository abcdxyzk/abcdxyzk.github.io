<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

  <title><![CDATA[Category: 2015~12 | kk Blog —— 通用基础]]></title>
  <link href="http://abcdxyzk.github.io/blog/cats/2015~12/atom.xml" rel="self"/>
  <link href="http://abcdxyzk.github.io/"/>
  <updated>2024-06-24T16:02:54+08:00</updated>
  <id>http://abcdxyzk.github.io/</id>
  <author>
    <name><![CDATA[kk]]></name>
    
  </author>
  <generator uri="http://octopress.org/">Octopress</generator>

  
  <entry>
    <title type="html"><![CDATA[Web压力测试工具]]></title>
    <link href="http://abcdxyzk.github.io/blog/2015/12/27/kernel-net-test-tool/"/>
    <updated>2015-12-27T02:51:00+08:00</updated>
    <id>http://abcdxyzk.github.io/blog/2015/12/27/kernel-net-test-tool</id>
    <content type="html"><![CDATA[<h4>curl wget 不验证证书进行https请求</h4>

<p> wget &lsquo;<a href="https://x.x.x.x/get_ips">https://x.x.x.x/get_ips</a>&rsquo; &ndash;no-check-certificate</p>

<p>curl &lsquo;<a href="https://x.x.x.x/get_ips">https://x.x.x.x/get_ips</a>&rsquo; -k</p>

<hr />

<p><a href="https://blog.csdn.net/hqzxsc2006/article/details/50547684">https://blog.csdn.net/hqzxsc2006/article/details/50547684</a></p>

<h4>通过curl得到http各阶段的响应时间</h4>

<p>url_effective The URL that was fetched last. This is most meaningful if you&rsquo;ve told curl to follow location: headers.</p>

<p>filename_effective The ultimate filename that curl writes out to. This is only meaningful if curl is told to write to a file with the &ndash;remote-name or &ndash;output option. It&rsquo;s most useful in combination with the &ndash;remote-header-name option. (Added in 7.25.1)</p>

<p>http_code http状态码，如200成功,301转向,404未找到,500服务器错误等。(The numerical response code that was found in the last retrieved HTTP(S) or FTP(s) transfer. In 7.18.2 the alias response_code was added to show the same info.)</p>

<p>http_connect The numerical code that was found in the last response (from a proxy) to a curl CONNECT request. (Added in 7.12.4)</p>

<p>time_total 总时间，按秒计。精确到小数点后三位。 （The total time, in seconds, that the full operation lasted. The time will be displayed with millisecond resolution.）</p>

<p>time_namelookup DNS解析时间,从请求开始到DNS解析完毕所用时间。(The time, in seconds, it took from the start until the name resolving was completed.)</p>

<p>time_connect 连接时间,从开始到建立TCP连接完成所用时间,包括前边DNS解析时间，如果需要单纯的得到连接时间，用这个time_connect时间减去前边time_namelookup时间。以下同理，不再赘述。(The time, in seconds, it took from the start until the TCP connect to the remote host (or proxy) was completed.)</p>

<p>time_appconnect 连接建立完成时间，如SSL/SSH等建立连接或者完成三次握手时间。(The time, in seconds, it took from the start until the SSL/SSH/etc connect/handshake to the remote host was completed. (Added in 7.19.0))</p>

<p>time_pretransfer 从开始到准备传输的时间。(The time, in seconds, it took from the start until the file transfer was just about to begin. This includes all pre-transfer commands and negotiations that are specific to the particular protocol(s) involved.)</p>

<p>time_redirect 重定向时间，包括到最后一次传输前的几次重定向的DNS解析，连接，预传输，传输时间。(The time, in seconds, it took for all redirection steps include name lookup, connect, pretransfer and transfer before the final transaction was started. time_redirect shows the complete execution time for multiple redirections. (Added in 7.12.3))</p>

<p>time_starttransfer 开始传输时间。在client发出请求之后，Web 服务器返回数据的第一个字节所用的时间(The time, in seconds, it took from the start until the first byte was just about to be transferred. This includes time_pretransfer and also the time the server needed to calculate the result.)</p>

<p>size_download 下载大小。(The total amount of bytes that were downloaded.)</p>

<p>size_upload 上传大小。(The total amount of bytes that were uploaded.)</p>

<p>size_header  下载的header的大小(The total amount of bytes of the downloaded headers.)</p>

<p>size_request 请求的大小。(The total amount of bytes that were sent in the HTTP request.)</p>

<p>speed_download 下载速度，单位-字节每秒。(The average download speed that curl measured for the complete download. Bytes per second.)</p>

<p>speed_upload 上传速度,单位-字节每秒。(The average upload speed that curl measured for the complete upload. Bytes per second.)</p>

<p>content_type 就是content-Type，不用多说了，这是一个访问我博客首页返回的结果示例(text/html; charset=UTF-8)；(The Content-Type of the requested document, if there was any.)</p>

<p>num_connects Number of new connects made in the recent transfer. (Added in 7.12.3)</p>

<p>num_redirects Number of redirects that were followed in the request. (Added in 7.12.3)</p>

<p>redirect_url When a HTTP request was made without -L to follow redirects, this variable will show the actual URL a redirect would take you to. (Added in 7.18.2)</p>

<p>ftp_entry_path The initial path libcurl ended up in when logging on to the remote FTP server. (Added in 7.15.4)</p>

<p>ssl_verify_result ssl认证结果，返回0表示认证成功。( The result of the SSL peer certificate verification that was requested. 0 means the verification was successful. (Added in 7.19.0))</p>

<p>1、可以直接访问使用：</p>

<pre><code>    curl -o /dev/null -s -w %{http_code}:%{http_connect}:%{content_type}:%{time_namelookup}:%{time_redirect}:%{time_pretransfer}:%{time_connect}:%{time_starttransfer}:%{time_total}:%{speed_download} www.baidu.com
</code></pre>

<p>输出变量需要按照%{variable_name}的格式，如果需要输出%，double一下即可，即%%，同时，\n是换行，\r是回车，\t是TAB。</p>

<p>-w 指定格式化文件</p>

<p>-o 请求重定向到,不带此参数则控制台输出返回结果</p>

<p>-s 静默，不显示进度</p>

<p>2、也可以定义时间格式化文件访问</p>

<pre><code>    #vim  curl-time.txt 
    \n
                  http: %{http_code}\n
                   dns: %{time_namelookup}s\n
              redirect: %{time_redirect}s\n
          time_connect: %{time_connect}s\n
       time_appconnect: %{time_appconnect}s\n
      time_pretransfer: %{time_pretransfer}s\n
    time_starttransfer: %{time_starttransfer}s\n
         size_download: %{size_download}bytes\n
        speed_download: %{speed_download}B/s\n
                      ----------\n
            time_total: %{time_total}s\n
    \n
</code></pre>

<pre><code>    curl -w "@curl_time.txt"  -s  -H "Content-Type: application/json" --insecure --header 'Host: passport.500.com' --data '{"platform":"android","userimei":"F5D815EA2BD8DBARD","app_channel":"10000","mbimei":"9DB358AF","version":"3.1.4","username":"hqzx","userpass":"976af4"}' --compressed https://119.147.113.177/user/login
</code></pre>

<hr />

<p><a href="http://297020555.blog.51cto.com/1396304/592386">http://297020555.blog.51cto.com/1396304/592386</a></p>

<pre><code>    */1 * * * * cd /root/test ; ./curl.sh &gt; /dev/null 2&gt;&amp;1
    */1 * * * * cd /root/test ; ./ping.sh &gt; /dev/null 2&gt;&amp;1

    curl.sh:
    if ps aux | grep curl | grep "30M" &gt; /dev/null ; then
        echo "..." &gt; /dev/null
    else
        ./curl_1.sh &amp;
        ./curl_2.sh &amp;
    fi

    curl_1.sh &amp; curl_2.sh:
    URL=192.168.1.3:80/30M
    T=`date "+%F %T"`
    curl $URL -s -o /tmp/df -w "$T %{time_connect} %{time_starttransfer} %{time_total} %{speed_download} %{http_code}\n" &gt;&gt; t_down

    ping.sh:
    date "+%F %T" &gt;&gt; ping_out
    ping -q -f -c 1000 192.168.1.3 &gt;&gt; ping_out
</code></pre>

<p>res.sh:
<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
<span class='line-number'>16</span>
<span class='line-number'>17</span>
<span class='line-number'>18</span>
<span class='line-number'>19</span>
<span class='line-number'>20</span>
<span class='line-number'>21</span>
<span class='line-number'>22</span>
<span class='line-number'>23</span>
<span class='line-number'>24</span>
<span class='line-number'>25</span>
<span class='line-number'>26</span>
<span class='line-number'>27</span>
<span class='line-number'>28</span>
<span class='line-number'>29</span>
<span class='line-number'>30</span>
<span class='line-number'>31</span>
<span class='line-number'>32</span>
<span class='line-number'>33</span>
<span class='line-number'>34</span>
<span class='line-number'>35</span>
<span class='line-number'>36</span>
<span class='line-number'>37</span>
<span class='line-number'>38</span>
<span class='line-number'>39</span>
<span class='line-number'>40</span>
<span class='line-number'>41</span>
<span class='line-number'>42</span>
<span class='line-number'>43</span>
<span class='line-number'>44</span>
<span class='line-number'>45</span>
<span class='line-number'>46</span>
<span class='line-number'>47</span>
<span class='line-number'>48</span>
<span class='line-number'>49</span>
<span class='line-number'>50</span>
<span class='line-number'>51</span>
<span class='line-number'>52</span>
<span class='line-number'>53</span>
<span class='line-number'>54</span>
<span class='line-number'>55</span>
<span class='line-number'>56</span>
<span class='line-number'>57</span>
<span class='line-number'>58</span>
<span class='line-number'>59</span>
<span class='line-number'>60</span>
<span class='line-number'>61</span>
<span class='line-number'>62</span>
<span class='line-number'>63</span>
<span class='line-number'>64</span>
<span class='line-number'>65</span>
<span class='line-number'>66</span>
<span class='line-number'>67</span>
<span class='line-number'>68</span>
<span class='line-number'>69</span>
<span class='line-number'>70</span>
<span class='line-number'>71</span>
<span class='line-number'>72</span>
<span class='line-number'>73</span>
<span class='line-number'>74</span>
<span class='line-number'>75</span>
<span class='line-number'>76</span>
<span class='line-number'>77</span>
<span class='line-number'>78</span>
<span class='line-number'>79</span>
<span class='line-number'>80</span>
<span class='line-number'>81</span>
<span class='line-number'>82</span>
<span class='line-number'>83</span>
<span class='line-number'>84</span>
<span class='line-number'>85</span>
<span class='line-number'>86</span>
<span class='line-number'>87</span>
<span class='line-number'>88</span>
<span class='line-number'>89</span>
<span class='line-number'>90</span>
<span class='line-number'>91</span>
<span class='line-number'>92</span>
<span class='line-number'>93</span>
<span class='line-number'>94</span>
<span class='line-number'>95</span>
<span class='line-number'>96</span>
<span class='line-number'>97</span>
<span class='line-number'>98</span>
<span class='line-number'>99</span>
<span class='line-number'>100</span>
<span class='line-number'>101</span>
<span class='line-number'>102</span>
<span class='line-number'>103</span>
<span class='line-number'>104</span>
<span class='line-number'>105</span>
<span class='line-number'>106</span>
<span class='line-number'>107</span>
<span class='line-number'>108</span>
<span class='line-number'>109</span>
<span class='line-number'>110</span>
<span class='line-number'>111</span>
<span class='line-number'>112</span>
<span class='line-number'>113</span>
<span class='line-number'>114</span>
<span class='line-number'>115</span>
<span class='line-number'>116</span>
<span class='line-number'>117</span>
<span class='line-number'>118</span>
<span class='line-number'>119</span>
<span class='line-number'>120</span>
<span class='line-number'>121</span>
<span class='line-number'>122</span>
<span class='line-number'>123</span>
<span class='line-number'>124</span>
<span class='line-number'>125</span>
<span class='line-number'>126</span>
<span class='line-number'>127</span>
<span class='line-number'>128</span>
<span class='line-number'>129</span>
<span class='line-number'>130</span>
<span class='line-number'>131</span>
<span class='line-number'>132</span>
<span class='line-number'>133</span>
<span class='line-number'>134</span>
<span class='line-number'>135</span>
<span class='line-number'>136</span>
<span class='line-number'>137</span>
<span class='line-number'>138</span>
<span class='line-number'>139</span>
<span class='line-number'>140</span>
<span class='line-number'>141</span>
<span class='line-number'>142</span>
<span class='line-number'>143</span>
<span class='line-number'>144</span>
<span class='line-number'>145</span>
<span class='line-number'>146</span>
<span class='line-number'>147</span>
<span class='line-number'>148</span>
<span class='line-number'>149</span>
<span class='line-number'>150</span>
<span class='line-number'>151</span>
<span class='line-number'>152</span>
<span class='line-number'>153</span>
<span class='line-number'>154</span>
<span class='line-number'>155</span>
<span class='line-number'>156</span>
<span class='line-number'>157</span>
<span class='line-number'>158</span>
<span class='line-number'>159</span>
<span class='line-number'>160</span>
<span class='line-number'>161</span>
<span class='line-number'>162</span>
<span class='line-number'>163</span>
<span class='line-number'>164</span>
<span class='line-number'>165</span>
<span class='line-number'>166</span>
<span class='line-number'>167</span>
<span class='line-number'>168</span>
<span class='line-number'>169</span>
<span class='line-number'>170</span>
<span class='line-number'>171</span>
<span class='line-number'>172</span>
<span class='line-number'>173</span>
<span class='line-number'>174</span>
<span class='line-number'>175</span>
<span class='line-number'>176</span>
<span class='line-number'>177</span>
<span class='line-number'>178</span>
<span class='line-number'>179</span>
<span class='line-number'>180</span>
<span class='line-number'>181</span>
<span class='line-number'>182</span>
<span class='line-number'>183</span>
<span class='line-number'>184</span>
<span class='line-number'>185</span>
<span class='line-number'>186</span>
<span class='line-number'>187</span>
<span class='line-number'>188</span>
<span class='line-number'>189</span>
<span class='line-number'>190</span>
<span class='line-number'>191</span>
<span class='line-number'>192</span>
<span class='line-number'>193</span>
<span class='line-number'>194</span>
<span class='line-number'>195</span>
<span class='line-number'>196</span>
<span class='line-number'>197</span>
<span class='line-number'>198</span>
<span class='line-number'>199</span>
<span class='line-number'>200</span>
<span class='line-number'>201</span>
<span class='line-number'>202</span>
<span class='line-number'>203</span>
<span class='line-number'>204</span>
<span class='line-number'>205</span>
<span class='line-number'>206</span>
<span class='line-number'>207</span>
<span class='line-number'>208</span>
<span class='line-number'>209</span>
<span class='line-number'>210</span>
<span class='line-number'>211</span>
<span class='line-number'>212</span>
<span class='line-number'>213</span>
<span class='line-number'>214</span>
<span class='line-number'>215</span>
<span class='line-number'>216</span>
<span class='line-number'>217</span>
<span class='line-number'>218</span>
<span class='line-number'>219</span>
<span class='line-number'>220</span>
<span class='line-number'>221</span>
<span class='line-number'>222</span>
<span class='line-number'>223</span>
<span class='line-number'>224</span>
<span class='line-number'>225</span>
<span class='line-number'>226</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>#sed -i -e &lsquo;:a;N;$!ba;s/(:..)\n/\1 /g&rsquo; t_down
</span><span class='line'>cat ping_out | grep -E &ldquo;-|loss&rdquo; | grep -v statistics &gt; ping_tmp
</span><span class='line'>sed -i -e &lsquo;:a;N;$!ba;s/(:..)\n/\1 /g&rsquo; ping_tmp&lt;/p&gt;
</span><span class='line'>
</span><span class='line'>&lt;pre&gt;&lt;code&gt;python res.py &gt; res_out
</span><span class='line'>python res2.py
</span><span class='line'>&lt;/code&gt;&lt;/pre&gt;
</span><span class='line'>
</span><span class='line'>&lt;pre&gt;&lt;code&gt;
</span><span class='line'>统计结果和ping汇聚 res.py:
</span><span class='line'>&lt;/code&gt;&lt;/pre&gt;
</span><span class='line'>
</span><span class='line'>&lt;pre&gt;&lt;code&gt;import time
</span><span class='line'>
</span><span class='line'>ff = open('t1_down').readlines()
</span><span class='line'>qq = open('t2_down').readlines()
</span><span class='line'>ping = open('ping_tmp').readlines()
</span><span class='line'>
</span><span class='line'>j = 0
</span><span class='line'>for i in range(0, len(ff)):
</span><span class='line'>f = ff[i].strip().split(' ')
</span><span class='line'>q = qq[i].strip().split(' ')
</span><span class='line'>
</span><span class='line'>if (len(f) != len(q)):
</span><span class='line'>    break
</span><span class='line'>
</span><span class='line'>timeArray = time.strptime(f[0]+" "+f[1], "%Y-%m-%d %H:%M:%S")
</span><span class='line'>ft = time.mktime(timeArray)
</span><span class='line'>
</span><span class='line'>if (i &lt; len(ff) - 1):
</span><span class='line'>    fn = ff[i+1].strip().split(' ')
</span><span class='line'>    fnt = time.mktime(time.strptime(fn[0] + " " + fn[1], "%Y-%m-%d %H:%M:%S"))
</span><span class='line'>else:
</span><span class='line'>    fnt = time.mktime(time.strptime("2020-01-01 00:00:00", "%Y-%m-%d %H:%M:%S"))
</span><span class='line'>
</span><span class='line'>po = "0"
</span><span class='line'>while (j &lt; len(ping)):
</span><span class='line'>    p = ping[j].strip().split(' ')
</span><span class='line'>    pt = time.mktime(time.strptime(p[0]+" "+p[1], "%Y-%m-%d %H:%M:%S"))
</span><span class='line'>    if (pt &gt; fnt):
</span><span class='line'>        break
</span><span class='line'>    j = j + 1
</span><span class='line'>    if (pt &gt;= ft - 10):
</span><span class='line'>        po = p[8]
</span><span class='line'>        break
</span><span class='line'>
</span><span class='line'>print f[0], f[1], int(float(f[6])/1000), int(float(q[6])/1000), po
</span><span class='line'>&lt;/code&gt;&lt;/pre&gt;
</span><span class='line'>
</span><span class='line'>&lt;pre&gt;&lt;code&gt;
</span><span class='line'>分时段统计res2.py:
</span><span class='line'>&lt;/code&gt;&lt;/pre&gt;
</span><span class='line'>
</span><span class='line'>&lt;pre&gt;&lt;code&gt;#coding:utf-8
</span><span class='line'>
</span><span class='line'>r = open('res_out').readlines()
</span><span class='line'>
</span><span class='line'>hs1 = {}
</span><span class='line'>hs2 = {}
</span><span class='line'>hsw = {}
</span><span class='line'>hl = {}
</span><span class='line'>hr = {}
</span><span class='line'>hm = {}
</span><span class='line'>
</span><span class='line'>for line in r:
</span><span class='line'>arr = line.strip().split(' ')
</span><span class='line'>h1 = int(arr[1][0:2])
</span><span class='line'>if h1 &gt;= 2 and h1 &lt;= 9:
</span><span class='line'>    h2 = "H2-9"
</span><span class='line'>else:
</span><span class='line'>    h2 = "H10-25"
</span><span class='line'>h3 = 'Hall'
</span><span class='line'>for h in (h1, h2, h3):
</span><span class='line'>    if h not in hsw:
</span><span class='line'>        hs1[h] = hs2[h] = hsw[h] = hl[h] = hr[h] = hm[h] = 0
</span><span class='line'>    hs1[h] += int(arr[2])
</span><span class='line'>    hs2[h] += int(arr[3])
</span><span class='line'>    hsw[h] += 1
</span><span class='line'>    hl[h] += int(arr[4][0:-1])
</span><span class='line'>    hr[h] += int(arr[5])
</span><span class='line'>    hm[h] += int(arr[6])
</span><span class='line'>
</span><span class='line'>print "时段", "下载次数", "ff(KB/s)", "qq(KB/s)", "提升比例", "丢包率", "recovery_skb", "mark_skb"
</span><span class='line'>for h in sorted(hs1.keys()):
</span><span class='line'>s1 = hs1[h]/hsw[h]
</span><span class='line'>s2 = hs2[h]/hsw[h]
</span><span class='line'>s3 = hl[h]/hsw[h]
</span><span class='line'>s4 = hr[h]/hsw[h]
</span><span class='line'>s5 = hm[h]/hsw[h]
</span><span class='line'>#print h, hsw[h], s1, s2, 100*(s1-s2)/s2, s3, s4, s5
</span><span class='line'>print "%s\t%d\t%d\t%d\t%d\t%d\t%d\t%d" % (h, hsw[h], s1, s2, 100*(s1-s2)/s2, s3, s4, s5)
</span><span class='line'>&lt;/code&gt;&lt;/pre&gt;
</span><span class='line'>
</span><span class='line'>&lt;pre&gt;&lt;code&gt;
</span><span class='line'>#### 一、http_load
</span><span class='line'>http_load以并行复用的方式运行，用以测试web服务器的吞吐量与负载。但是它不同于大多数压力测试工具，它可以以一个单一的进程运行，一般不会把客户机搞死。还可以测试HTTPS类的网站请求。
</span><span class='line'>
</span><span class='line'>下载地址：http://www.acme.com/software/http_load/
</span><span class='line'>&lt;/code&gt;&lt;/pre&gt;
</span><span class='line'>
</span><span class='line'>&lt;pre&gt;&lt;code&gt;./http_load -verbose -proxy 192.168.99.6:80 -parallel 24 -seconds 1000 url.txt
</span><span class='line'>&lt;/code&gt;&lt;/pre&gt;
</span><span class='line'>
</span><span class='line'>&lt;pre&gt;&lt;code&gt;
</span><span class='line'>[http_load 改进版下载 http_load-09Mar2016-kk.tar.gz](/download/tools/http_load-09Mar2016-kk.tar.gz)  
</span><span class='line'>改进点：  
</span><span class='line'>2018-01-19:  
</span><span class='line'>1. 异常时打印更多信息("want_bytes=%ld got_bytes=%ld sport=%d connect_at=%ld now=%ld last=%ld")  
</span><span class='line'>2. http1.0 改成 http1.1 支持多次request  
</span><span class='line'>3. 增加 [ -requests times ] 参数, 在一条流中会发起times次request, 默认为1  
</span><span class='line'>2018-01-26:  
</span><span class='line'>4. 增加 [ -fastopen ] 参数，http协议增加fastopen测试，fastopen连接时改为阻塞模式。非阻塞模式syn无法附带数据  
</span><span class='line'>2018-04-12:  
</span><span class='line'>5. 修复 num_connections 可能出现的统计错误，以及fastopen可能出现的请求超时  
</span><span class='line'>2018-06-13:  
</span><span class='line'>6. https增加SNI信息，Makefile默认开启https支持  
</span><span class='line'>2019-02-19:  
</span><span class='line'>7. 修复IPV6的bug  
</span><span class='line'>2020-08-29:
</span><span class='line'>8. fastopen 支持非阻塞模式-nonblock，但第一次连接还得用block
</span><span class='line'>
</span><span class='line'>
</span><span class='line'>#### 二、webbench
</span><span class='line'>
</span><span class='line'>webbench是Linux下的一个网站压力测试工具，最多可以模拟3万个并发连接去测试网站的负载能力。
</span><span class='line'>&lt;/code&gt;&lt;/pre&gt;
</span><span class='line'>
</span><span class='line'>&lt;pre&gt;&lt;code&gt;用法：webbench -c 并发数 -t 运行测试时间 URL
</span><span class='line'>如：webbench -c 5000 -t 120 http://www.163.com
</span><span class='line'>&lt;/code&gt;&lt;/pre&gt;
</span><span class='line'>
</span><span class='line'>&lt;pre&gt;&lt;code&gt;
</span><span class='line'>#### 三、ab
</span><span class='line'>ab是apache自带的一款功能强大的测试工具。安装了apache一般就自带了，用法可以查看它的说明
</span><span class='line'>
</span><span class='line'>参数众多，一般我们用到的是-n 和-c
</span><span class='line'>
</span><span class='line'>例如：
</span><span class='line'>&lt;/code&gt;&lt;/pre&gt;
</span><span class='line'>
</span><span class='line'>&lt;pre&gt;&lt;code&gt;./ab -c 1000 -n 100 http://www.vpser.net/index.php
</span><span class='line'>&lt;/code&gt;&lt;/pre&gt;
</span><span class='line'>
</span><span class='line'>&lt;pre&gt;&lt;code&gt;这个表示同时处理1000个请求并运行100次index.php文件.
</span><span class='line'>
</span><span class='line'>#### 四、Siege
</span><span class='line'>一款开源的压力测试工具，可以根据配置对一个WEB站点进行多用户的并发访问，记录每个用户所有请求过程的相应时间，并在一定数量的并发访问下重复进行。
</span><span class='line'>官方：http://www.joedog.org/
</span><span class='line'>
</span><span class='line'>使用
</span><span class='line'>&lt;/code&gt;&lt;/pre&gt;
</span><span class='line'>
</span><span class='line'>&lt;pre&gt;&lt;code&gt;siege -c 200 -r 10 -f example.url
</span><span class='line'>&lt;/code&gt;&lt;/pre&gt;
</span><span class='line'>
</span><span class='line'>&lt;p&gt;```&lt;/p&gt;
</span><span class='line'>
</span><span class='line'>&lt;p&gt;-c是并发量，-r是重复次数。 url文件就是一个文本，每行都是一个url，它会从里面随机访问的。&lt;/p&gt;
</span><span class='line'>]]&gt;&lt;/content&gt;
</span><span class='line'>  &lt;/entry&gt;
</span><span class='line'>  
</span><span class='line'>  &lt;entry&gt;
</span><span class='line'>&lt;title type="html"&gt;&lt;![CDATA[乘2加1]]&gt;&lt;/title&gt;
</span><span class='line'>&lt;link href="http://abcdxyzk.github.io/blog/2015/12/27/alg-mul2_add2/"/&gt;
</span><span class='line'>&lt;updated&gt;2015-12-27T02:39:00+08:00&lt;/updated&gt;
</span><span class='line'>&lt;id&gt;http://abcdxyzk.github.io/blog/2015/12/27/alg-mul2_add2&lt;/id&gt;
</span><span class='line'>&lt;content type="html"&gt;&lt;![CDATA[&lt;p&gt;两个数A B，A&lt;B，两种操作：A=A+1 或 A=A*2，求A到B的最少操作次数。&lt;/p&gt;
</span><span class='line'>
</span><span class='line'>&lt;p&gt;首先如果A、B的二进制前缀不一样则一直A=A+1&lt;/p&gt;
</span><span class='line'>
</span><span class='line'>&lt;p&gt;然后A=A&lt;&lt;1，A、B前缀不一样再A=A+1&lt;/p&gt;
</span><span class='line'>]]&gt;&lt;/content&gt;
</span><span class='line'>  &lt;/entry&gt;
</span><span class='line'>  
</span><span class='line'>  &lt;entry&gt;
</span><span class='line'>&lt;title type="html"&gt;&lt;![CDATA[TCP拥塞控制窗口有效性验证机制]]&gt;&lt;/title&gt;
</span><span class='line'>&lt;link href="http://abcdxyzk.github.io/blog/2015/12/08/kernel-net-cwnd-test/"/&gt;
</span><span class='line'>&lt;updated&gt;2015-12-08T15:49:00+08:00&lt;/updated&gt;
</span><span class='line'>&lt;id&gt;http://abcdxyzk.github.io/blog/2015/12/08/kernel-net-cwnd-test&lt;/id&gt;
</span><span class='line'>&lt;content type="html"&gt;&lt;![CDATA[&lt;p&gt;blog.csdn.net/zhangskd/article/details/7609465&lt;/p&gt;
</span><span class='line'>
</span><span class='line'>&lt;h4&gt;概述&lt;/h4&gt;
</span><span class='line'>
</span><span class='line'>&lt;p&gt;问题1：当发送方长时间受到应用程序的限制，不能发送数据时，会使拥塞窗口无效。TCP是根据拥塞窗口来动态地估计网络带宽的。发送方受到应用程序的限制后，没有数据可以发送。那么此时的拥塞窗口就不能准确的反应网络状况，因为这个拥塞窗口是很早之前的。&lt;/p&gt;
</span><span class='line'>
</span><span class='line'>&lt;p&gt;问题2：当发送方受到应用程序限制，不能利用完拥塞窗口，会使拥塞窗口的增长无效。TCP不断调整cwnd来测试网络带宽。如果不能完全使用掉cwnd，就不知道网络能否承受得了cwnd的数据量，这种情况下的cwnd增长是无效的。&lt;/p&gt;
</span><span class='line'>
</span><span class='line'>&lt;h4&gt;原理&lt;/h4&gt;
</span><span class='line'>
</span><span class='line'>&lt;p&gt;TCP sender受到的两种限制&lt;/p&gt;
</span><span class='line'>
</span><span class='line'>&lt;p&gt;(1) application-limited ：when the sender sends less than is allowed by the congestion or receiver window.&lt;/p&gt;
</span><span class='line'>
</span><span class='line'>&lt;p&gt;(2) network-limited：when the sender is limited by the TCP window. More precisely, we define a network-limited period as any period when the sender is sending a full window of data.&lt;/p&gt;
</span><span class='line'>
</span><span class='line'>&lt;h5&gt;问题1描述&lt;/h5&gt;
</span><span class='line'>
</span><span class='line'>&lt;p&gt;TCP&rsquo;s congestion window controls the number of packets a TCP flow may have in the
</span><span class='line'>network at any time. However, long periods when the sender is idle or application-limited
</span><span class='line'>can lead to the invalidation of the congestion window, in that the congestion window no longer
</span><span class='line'>reflects current information about the state of the network.&lt;/p&gt;
</span><span class='line'>
</span><span class='line'>&lt;p&gt;The congestion window is set using an Additive-Increase, Multiplicative-Decrease(AIMD) mechanism
</span><span class='line'>that probes for available bandwidth, dynamically adapting to changing network conditions. This AIMD
</span><span class='line'>works well when the sender continually has data to send, as is typically the case for TCP used for
</span><span class='line'>bulk-data transfer. In contrast, for TCP used with telnet applications, the data sender often has little
</span><span class='line'>or no data to send, and the sending rate is often determined by the rate at which data is generated
</span><span class='line'>by the user.&lt;/p&gt;
</span><span class='line'>
</span><span class='line'>&lt;h5&gt;问题2描述&lt;/h5&gt;
</span><span class='line'>
</span><span class='line'>&lt;p&gt;An invalid congestion window also results when the congestion window is increased (i.e.,
</span><span class='line'>in TCP&rsquo;s slow-start or congestion avoidance phases) during application-limited periods, when the
</span><span class='line'>previous value of the congestion window might never have been fully utilized. As far as we know, all
</span><span class='line'>current TCP implementations increase the congestion window when an acknowledgement arrives,
</span><span class='line'>if allowed by the receiver&rsquo;s advertised window and the slow-start or congestion avoidance window
</span><span class='line'>increase algorithm, without checking to see if the previous value of the congestion window has in
</span><span class='line'>fact been used.&lt;/p&gt;
</span><span class='line'>
</span><span class='line'>&lt;p&gt;This document proposes that the window increase algorithm not be invoked during application-
</span><span class='line'>limited periods. This restriction prevents the congestion window from growing arbitrarily large,
</span><span class='line'>in the absence of evidence that the congestion window can be supported by the network.&lt;/p&gt;
</span><span class='line'>
</span><span class='line'>&lt;h4&gt;实现(1)&lt;/h4&gt;
</span><span class='line'>
</span><span class='line'>&lt;p&gt;发送方在发送数据包时，如果发送的数据包有负载，则会检测拥塞窗口是否超时。如果超时，则会使拥塞窗口失效并重新计算拥塞窗口。然后根据最近接收段的时间，确定是否进入pingpong模式。</span></code></pre></td></tr></table></div></figure>
    /<em> Congestion state accounting after a packet has been sent. </em>/<br/>
    static void tcp_event_data_sent (struct tcp_sock <em>tp, struct sock </em>sk)<br/>
    {<br/>
        struct inet_connection_sock *icsk = inet_csk(sk);<br/>
        const u32 now = tcp_time_stamp;</p>

<pre><code>    if (sysctl_tcp_slow_start_after_idle &amp;&amp;   
        (!tp-&gt;packets_out &amp;&amp; (s32) (now - tp-&gt;lsndtime) &gt; icsk-&gt;icsk_rto))  
        tcp_cwnd_restart(sk, __sk_dst_get(sk)); /* 重置cnwd */  

    tp-&gt;lsndtime = now; /* 更新最近发包的时间*/  

    /* If it is a reply for ato after last received packets,  
     * enter pingpong mode. */  
    if ((u32)(now - icsk-&gt;icsk_ack.lrcvtime) &lt; icsk.icsk_ack.ato)  
        icsk-&gt;icsk_ack.pingpong = 1;  
}  
</code></pre>

<pre><code>
tcp_event_data_sent()中，符合三个条件才重置cwnd：

（1）tcp_slow_start_after_idle选项设置，这个内核默认置为1
（2）tp-&gt;packets_out == 0，表示网络中没有未确认数据包
（3）now - tp-&gt;lsndtime &gt; icsk-&gt;icsk_rto，距离上次发送数据包的时间超过了RTO
</code></pre>

<pre><code>/* RFC2861. Reset CWND after idle period longer RTO to "restart window". 
 * This is the first part of cnwd validation mechanism. 
 */  
static void tcp_cwnd_restart (struct sock *sk, const struct dst_entry *dst)  
{  
    struct tcp_sock *tp = tcp_sk(sk);  
    s32 delta = tcp_time_stamp - tp-&gt;lsndtime;  

    /* 关于tcp_init_cwnd()可见上一篇blog.*/  
    u32 restart_cwnd = tcp_init_cwnd(tp, dst);  
    u32 cwnd = tp-&gt;snd_cwnd;  

    /* 触发拥塞窗口重置事件*/  
    tcp_ca_event(sk, CA_EVENT_CWND_RESTART);  

    /* 阈值保存下来，并没有重置。*/  
    tp-&gt;snd_ssthresh = tcp_current_ssthresh(sk);  
    restart_cwnd = min(restart_cwnd, cwnd);  

    /* 闲置时间每超过一个RTO且cwnd比重置后的大时，cwnd减半。*/  
    while((delta -= inet_csk(sk)-&gt;icsk_rto) &gt; 0 &amp;&amp; cwnd &gt; restart_cwnd)  
        cwnd &gt;&gt; 1;  

    tp-&gt;snd_cwnd = max(cwnd, restart_cwnd); /* 取其大者！*/  
    tp-&gt;snd_cwnd_stamp = tcp_time_stamp;  
    tp-&gt;snd_cwnd_used = 0;  
}  
</code></pre>

<pre><code>
那么调用tcp_cwnd_restart()后，tp-&gt;snd_cwnd是多少呢？这个是不确定的，要看闲置时间delta、闲置前的cwnd、路由器中设置的initcwnd。当然，最大概率的是：拥塞窗口降为闲置前cwnd的一半。

#### 实现(2)

在发送方成功发送一个数据包后，会检查从发送队列发出而未确认的数据包是否用完拥塞窗口。
如果拥塞窗口被用完了，说明发送方收到网络限制；
如果拥塞窗口没被用完，且距离上次检查时间超过了RTO，说明发送方收到应用程序限制。
</code></pre>

<pre><code>/* Congestion window validation.(RFC2861) */  
static void tcp_cwnd_validate(struct sock *sk) {  
    struct tcp_sock *tp = tcp_sk(sk);  

    if (tp-&gt;packets_out &gt;= tp-&gt;snd_cwnd) {  
        /* Network is feed fully. */  
        tp-&gt;snd_cwnd_used = 0; /*不用这个变量*/  
        tp-&gt;snd_cwnd_stamp = tcp_time_stamp; /* 更新检测时间*/  

    } else {  
        /* Network starves. */  
        if (tp-&gt;packets_out &gt; tp-&gt;snd_cwnd_used)  
            tp-&gt;snd_cwnd_used = tp-&gt;packets_out; /* 更新已使用窗口*/  

            /* 如果距离上次检测的时间，即距离上次发包时间已经超过RTO*/  
            if (sysctl_tcp_slow_start_after_idle &amp;&amp;  
                (s32) (tcp_time_stamp - tp-&gt;snd_cwnd_stamp) &gt;= inet_csk(sk)-&gt;icsk_rto)  
                tcp_cwnd_application_limited(sk);  
    }  
}  
</code></pre>

<pre><code>
在发送方收到应用程序的限制期间，每隔RTO时间，都会调用tcp_cwnd_application_limited()来重新设置sshresh和cwnd，具体如下：
</code></pre>

<pre><code>/* RFC2861, slow part. Adjust cwnd, after it was not full during one rto. 
 * As additional protections, we do not touch cwnd in retransmission phases, 
 * and if application hit its sndbuf limit recently. 
 */  
void tcp_cwnd_application_limited(struct sock *sk)  
{  
    struct tcp_sock *tp = tcp_sk(sk);  

    /* 只有处于Open态，应用程序没受到sndbuf限制时，才进行 
     * ssthresh和cwnd的重置。 
     */  
    if (inet_csk(sk)-&gt;icsk_ca_state == TCP_CA_Open &amp;&amp;   
        sk-&gt;sk_socket &amp;&amp; !test_bit(SOCK_NOSPACE, &amp;sk-&gt;sk_socket-&gt;flags)) {  

        /* Limited by application or receiver window. */  
        u32 init_win = tcp_init_cwnd(tp, __sk_dst_get(sk));  
        u32 win_used = max(tp-&gt;snd_cwnd_used, init_win);  

        /* 没用完拥塞窗口*/  
        if (win_used &lt; tp-&gt;snd_cwnd) {  
            /* 并没有减小ssthresh，反而增大，保留了过去的信息，以便之后有数据发送 
              * 时能快速增大到接近此时的窗口。 
              */  
            tp-&gt;snd_ssthresh = tcp_current_ssthresh(sk);   
            /* 减小了snd_cwnd */  
            tp-&gt;snd_cwnd = (tp-&gt;snd_cwnd + win_used) &gt;&gt; 1;  
        }  
        tp-&gt;snd_cwnd_used = 0;  
    }  
    tp-&gt;snd_cwnd_stamp = tcp_time_stamp; /* 更新最近的数据包发送时间*/  
}  
</code></pre>

<p>```</p>

<p>发送方受到应用程序限制，且限制的时间每经过RTO后，就会调用以上函数来处理snd_ssthresh和snd_cwnd：</p>

<p>（1）snd_ssthresh = max(snd_ssthresh, &frac34; cwnd)</p>

<p>慢启动阈值并没有减小，相反，如果此时cwnd较大，ssthresh会相应的增大。ssthresh是一个很重要的参数，它保留了旧的信息。这样一来，如果应用程序产生了大量的数据，发送方不再受到限制后，经过慢启动阶段，拥塞窗口就能快速恢复到接近以前的值了。</p>

<p>（2）snd_cwnd = (snd_cwnd + snd_cwnd_used) / 2</p>

<p>因为snd_cwnd_used &lt; snd_cwnd，所以snd_cwnd是减小了的。减小snd_cwnd是为了不让它盲目的增长。因为发送方没有利用完拥塞窗口，并不能检测到网络是否能承受该拥塞窗口，这时的增长是无根据的。</p>

<h4>结论</h4>

<p>在发送完数据包后，通过对拥塞窗口有效性的检验，能够避免使用不合理的拥塞窗口。</p>

<p>拥塞窗口代表着网络的状况，通过避免使用不合理的拥塞窗口，就能得到正确的网络状况，而不会采取一些不恰当的措施。</p>

<p>在上文的两种情况下，通过TCP的拥塞窗口有效性验证机制（TCP congestion window validationmechanism），能够更合理的利用网络、避免丢包，从而提高传输效率。</p>

<h4>Reference</h4>

<p>RFC2861</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Android 系统基本]]></title>
    <link href="http://abcdxyzk.github.io/blog/2015/12/08/android-base-adjust/"/>
    <updated>2015-12-08T15:20:00+08:00</updated>
    <id>http://abcdxyzk.github.io/blog/2015/12/08/android-base-adjust</id>
    <content type="html"><![CDATA[<p><a href="http://tieba.baidu.com/p/2687199243?see_lz=1">http://tieba.baidu.com/p/2687199243?see_lz=1</a></p>

<h3>二、锁定频率和核心</h3>

<h4>1. 了解热插拔</h4>

<p>热插拔驱动（Hotplug Driver）是控制cpu负载控制核心上线下线的驱动</p>

<p>注意：所有热插拔驱动都是根据负载调节cpu上下线，只是策略有不同。这不是“高通异步专利”</p>

<h5>高通机器默认热插拔：mpdecision</h5>

<pre><code>    /system/bin/mpdecision
</code></pre>

<p>这个热插拔驱动其实工作的蛮不错的。各个厂商之间略会有不同。个人建议使用8064以后机器的不使用第三方的热插拔驱动</p>

<h5>Exynos机器热插拔：pegasusq</h5>

<p>三星的热插拔驱动是集成在了governor（调速器）中的，这个调速器可以看作ondemand＋hotplug，工作方式为多核低频</p>

<h5>Tegra机器热插拔：hotplug</h5>

<p>两个字：渣渣<br/>
建议使用开发者开发的热插拔驱动</p>

<h4>2. 如何锁定cpu核心</h4>

<p>方法1: 使用kernel tuner</p>

<p>方法2: 使用脚本(只针对高通机器)：</p>

<pre><code>    #!/system/bin/sh

    stop mpdecision
    echo 0 &gt; /sys/devices/system/cpu/cpu1/online
    chmod 444 /sys/devices/system/cpu/cpu1/online
    echo 0 &gt; /sys/devices/system/cpu/cpu2/online
    chmod 444 /sys/devices/system/cpu/cpu2/online
    echo 1 &gt; /sys/devices/system/cpu/cpu3/online
    chmod 444 /sys/devices/system/cpu/cpu3/online
</code></pre>

<p>注意： 这样做将没有热插拔驱动工作，在空载时依然会有两个核心上线</p>

<h4>3. 如何锁定频率</h4>

<h5>（1）锁定cpu频率</h5>

<p>步骤1: 将governor设置为performance</p>

<p>方法很简单，用fauxclock，trickester mod，kernel tuner都可以搞定，并且不占用资源采样负载</p>

<p>弊端：如果不修改温度配置文件，将会受到降频影响</p>

<p>步骤2: 修改权限让温控进程无法对其降频</p>

<pre><code>    #!/system/bin/sh
    echo 你的cpu的最大频率 &gt; /sys/devices/system/cpu/cpu0/cpufreq/scaling_max_freq
    chmod 444 /sys/devices/system/cpu/cpu0/cpufreq/scaling_max_freq
    echo 你的cpu的最大频率 &gt; /sys/devices/system/cpu/cpu1/cpufreq/scaling_max_freq
    chmod 444 /sys/devices/system/cpu/cpu0/cpufreq/scaling_max_freq
    echo 你的cpu的最大频率 &gt; /sys/devices/system/cpu/cpu2/cpufreq/scaling_max_freq
    chmod 444 /sys/devices/system/cpu/cpu0/cpufreq/scaling_max_freq
    echo 你的cpu的最大频率 &gt; /sys/devices/system/cpu/cpu3/cpufreq/scaling_max_freq
    chmod 444 /sys/devices/system/cpu/cpu0/cpufreq/scaling_max_freq
</code></pre>

<p>注意：cpu频率以khz为单位，比如1728mhz应该在这里写为1728000</p>

<h5>(2)锁定gpu频率</h5>

<p>步骤1: 将governor设置为performance</p>

<p>方法很简单，用fauxclock，trickester mod，kernel tuner都可以搞定，并且不占用资源采样负载</p>

<p>弊端：如果不修改温度配置文件，将会受到降频影响</p>

<pre><code>    echo performance &gt; /sys/devices/system/cpu/cpu0/cpufreq/scaling_governor
    echo performance &gt; /sys/devices/system/cpu/cpu1/cpufreq/scaling_governor
    echo performance &gt; /sys/devices/system/cpu/cpu2/cpufreq/scaling_governor
    echo performance &gt; /sys/devices/system/cpu/cpu3/cpufreq/scaling_governor
</code></pre>

<p>步骤2:
<code>
    echo 你的gpu的最大频率 &gt; /sys/devices/platform/kgsl-3d0.0/kgsl/kgsl-3d0/max_gpuclk
    chmod 444 /sys/devices/platform/kgsl-3d0.0/kgsl/kgsl-3d0/max_gpuclk
</code></p>

<p>注意：gpu频率以hz为单位，比如400mhz应该在这里写为400000000</p>

<h4>4. 关于锁定频率的看法</h4>

<p>锁定频率对游戏性能很重要。根据我目前的结果来看，1.7g的krait 300似乎已经有点拖不动adreno 320了，而且随着频率降低，帧数跟着降低。但是对于日常使用来说，高频率只是一瞬间的事，并不需要多久，长期高频率对电池和发热的影响都会非常大。不推荐锁频，除非你要作性能测试</p>

<h3>三、在调节linux设置</h3>

<h4>1. governor</h4>

<p>(1) 什么是governor</p>

<p>governor大多数中文翻译为调速器，也叫调速策略。故名思议，根据cpu负载不同而如何决定提升或者降低频率靠的就是governor</p>

<p>(2) 为什么governor很重要</p>

<p>随着linux内核的更新，governor也会带来许多新功能来提升用户体验、响应速度、省电等。另外不同厂商对于不同governor的优化也是不同的。比如高通，对ondemand/msm-dcvs的优化非常好，然而对于小米用的interactive确实基本没怎么优化，在高通内核中的interactive非常之老旧，对于性能和省电都不利。在游戏中，htc的ondemand表现非常捉急，在需要提升频率的时候还按着不动，从而导致掉帧、顿卡等。切换到performance或者msm－dcvs会好不少。代表：riptide gp， asphalt 8，real racing 3</p>

<p>(3) 安卓上常见governor种类</p>

<h5>cpu：</h5>

<p>ondemand 故名思议，按需。ondemand根据cpu的负载来决定提升和降低频率，工作方式比较简单，也是最常见的一个governor</p>

<p>interactive 故名思议，交互。这个governor重点就是注重交互时的体验，它会比ondemand更快地提升到最高频率，而在降频时确实按照设定的时间慢慢地降。这么做会让系统很流畅，电量嘛，你懂的。</p>

<p>conservative 这个governor被开发者戏称为slow ondemand，它为了节电会限制cpu频率的提升，结果就是卡</p>

<p>performance 一直最高频</p>

<p>powersave 一直最低频</p>

<p>userspace 这个governor实质上就是让软件设定频率。比如在运行stability scaling test的时候，软件就会将其设为userspace</p>

<p>intellidemand intellidemand是faux123基于ondemand开发的一个governor，它和ondemand的主要区别就是在浏览网页的时候会限制频率，然后配合faux的热插拔驱动intelli-plug会获得比较好的省电效果</p>

<p>pegasusq 三星基于ondemand开发的热插拔governor</p>

<p>msm-dcvs msm（高通处理器前缀）－dcvs（dynamic clock &amp; voltage scaling 动态频率电压调整）
这个governor是高通给krait架构开发的，具体有什么魔力我也不清楚，只是用它玩游戏的时候感觉比ondemand流畅多了</p>

<h5>gpu：</h5>

<p>ondemand 这个和cpu的是一样的，按需调整，根据负载决定频率</p>

<p>performance 永远最大频率</p>

<p>simple 这个governor是faux123对adreno 3xx开发的一个governor，其中参数有laziness和thresholds。前者数值分布1-10，决定的是忽略多少降频请求，数字越大性能和耗电都越高；后者是提升频率的阀值，即gpu达到多少负载提升频率，数值分布0-100，数字越大性能和耗电都越低</p>

<p>(3) 如何切换</p>

<p>最简单的当然是在fauxclock，trickester mod等软件里面切换</p>

<p>cpu：</p>

<pre><code>    echo 你的governor &gt; /sys/devices/system/cpu/cpu0/cpufreq/scaling_governor
    echo 你的governor &gt; /sys/devices/system/cpu/cpu1/cpufreq/scaling_governor
    echo 你的governor &gt; /sys/devices/system/cpu/cpu2/cpufreq/scaling_governor
    echo 你的governor &gt; /sys/devices/system/cpu/cpu3/cpufreq/scaling_governor
</code></pre>

<p>gpu：</p>

<pre><code>echo 你的governor &gt; /sys/devices/platform/kgsl-3d0.0/kgsl/kgsl-3d0/pwrscale/trustzone/governor
</code></pre>

<h4>2. io scheduler</h4>

<p>中文名：输入输出 调度器/io 调度器</p>

<p>(1) 为什么io scheduler很重要</p>

<p>io scheduler完全决定了磁盘的读写性能，而这对于用户体验的影响是极大打</p>

<p>(2) 安卓上常见io scheduler</p>

<h5>cfq</h5>

<p>completely-fair-quening</p>

<p>完全公平队列，是anticipatory模式的替代品，没有过多的做预测性调度，而是根据给定的进程io优先级，直接来分配操作的顺序。这个模式在linux上表现良好，但也许并不是最适合android的io调度模式，太强调均衡，而降低了连续读写数据的性能。</p>

<p>高通默认的就是这个，强烈建议改掉，根本不适合移动设备</p>

<h5>noop</h5>

<p>这个调度模式会把所有的数据请求直接合并到一个简单的队列里。不适合有机械结构的存储器，因为没有优化顺序，会增加额外的寻道时间。属于最简单的一个调度模式，无视io操作优先级和复杂性，执行完一个再执行一个，如果读写操作繁多的话，就会造成效率降低。</p>

<p>nvidia默认，有时候会造成顿卡，但是听说这个scheduler对省电比较有帮助</p>

<h5>deadline</h5>

<p>顾名思义，用过期时间来排序io操作顺序，保证先出现的io请求有最短的延迟时间，相对于写操作，给读操作更优先的级别。是比较好的一个调度模式。</p>

<p>性能不错</p>

<h5>row</h5>

<p>read over write</p>

<p>顾名思义，这个scheduler会优先处理读的请求。在移动设备上读的请求远远多于并且重要于写的请求，并且随机读取速度很重要。这个governor允许单或者双线程的读写，在同时有读写的情况下优先保证读，比较适合移动设备。</p>

<h5>fiops</h5>

<p>fair-iops
这个调度器虽然和cfq一样追求平均的优先级，但是是根据闪存设备重新设计的一个governor，各方面表现良好，是我列出来的五个scheduler里面性能最好的一个</p>

<p>如果有，强烈推荐fiops</p>

<h5>sio</h5>

<p>simple－io
在安卓上其实调度器越简单效果越好。sio就是最简单的一个调度器。不过还是有缺点的，就是随即读写性能不太好。在fiops出来以后，这个scheduler基本就被冷落了</p>

<h4>3. read ahead buffer</h4>

<p>这个其实奇怪。按理说缓存应该是越大越好，但是在安卓上好像不是这样，是越大越省电，越小系统越流畅，具体原理我也不懂。只列下方法</p>

<p>依旧，fauxclock，trickester mod等可以修改</p>

<p>命令：</p>

<p>emmc内置闪存：
<code>
    echo 你想要的大小 &gt; /sys/block/mmcblk0/quene/read_ahead_kb
</code></p>

<p>sd卡：
<code>
    echo 你想要的大小 &gt; /sys/block/mmcblk1/quene/read_ahead_kb
</code></p>

<p>默认为128k，如果想省电可以设成2048k</p>

<h4>4. emmc entropy</h4>

<p>entropy是一个叫混乱度的东西，好像是物理化学里面的，根据faux123的解释，闪存设备根本不需要entropy，所以就把它关掉来提高性能</p>

<p>fauxclock里面可以关闭</p>

<p>命令
<code>
    echo 0 &gt; /sys/block/mmcblk0/quene/add_random
    echo 0 &gt; /sys/block/mmcblk1/quene/add_random
</code></p>

<h4>5. c-states</h4>

<p>高通从krait 200上引进，但是有bug，在krait 300上得到了修复</p>

<p>总共4个状态：</p>

<p>c0, wfi<br/>
c1, rentention<br/>
c2, standalone_power_collapse<br/>
c3, power_collapse</p>

<p>数字从低到高代表了睡眠程度的高低，数字越高的状态越省电</p>

<p>intel也有这个，haswell就是凭借着强大的c－states调整在tdp更高的情况下获得了更低的耗电和更长的续航。桌面上比如e3可以将c6状态打开，能在0.8v左右稳定在3.3g</p>

<p>高通的c－states和intel不一样，在平时工作的时候高通处理器进入c states的时间很少，主要集中在关屏深睡眠的时候</p>

<p>fauxclock可以打开，krait 300建议打开c0 c2 c3</p>

<p>命令：
<code>
    echo 1 &gt; /sys/module/pm_8x60/modes/cpu0/wfi/idle_enabled
    echo 1 &gt; /sys/module/pm_8x60/modes/cpu1/wfi/idle_enabled
    echo 1 &gt; /sys/module/pm_8x60/modes/cpu2/wfi/idle_enabled
    echo 1 &gt; /sys/module/pm_8x60/modes/cpu3/wfi/idle_enabled
    echo 0 &gt; /sys/module/pm_8x60/modes/cpu0/retention/idle_enabled
    echo 0 &gt; /sys/module/pm_8x60/modes/cpu1/retention/idle_enabled
    echo 0 &gt; /sys/module/pm_8x60/modes/cpu2/retention/idle_enabled
    echo 0 &gt; /sys/module/pm_8x60/modes/cpu3/retention/idle_enabled
    echo 1 &gt; /sys/module/pm_8x60/modes/cpu0/standalone_power_collapse/idle_enabled
    echo 1 &gt; /sys/module/pm_8x60/modes/cpu1/standalone_power_collapse/idle_enabled
    echo 1 &gt; /sys/module/pm_8x60/modes/cpu2/standalone_power_collapse/idle_enabled
    echo 1 &gt; /sys/module/pm_8x60/modes/cpu3/standalone_power_collapse/idle_enabled
    echo 1 &gt; /sys/module/pm_8x60/modes/cpu0/power_collapse/idle_enabled
    echo 1 &gt; /sys/module/pm_8x60/modes/cpu1/power_collapse/idle_enabled
    echo 1 &gt; /sys/module/pm_8x60/modes/cpu2/power_collapse/idle_enabled
    echo 1 &gt; /sys/module/pm_8x60/modes/cpu3/power_collapse/idle_enabled
</code></p>

<h4>6. 不同的构图方式</h4>

<p>从Android 4.0以后大家可以从build.prop里面发现这么几行：
<code>
    debug.sf.hw=1
    debug.composition.type=gpu
</code></p>

<p>在4.2以后还可以看到这一行
<code>
    persist.hwc.mdpcomp.enable=true
</code>
这就是构图方式</p>

<p>从谷歌4.2的build.prop的变化来看，谷歌已经开始强制使用mdp。性能更强但是耗电更低，何乐而不为</p>

<h5>(1) 构图方式种类</h5>

<p>cpu: 故名思议，cpu构图</p>

<p>gpu: gpu构图，在开发者选项中选择“关闭hw叠加层”和只设置debug.sf.hw=1都是让gpu构图</p>

<p>c2d: c2d构图，这个在2.x时代就已经被抛弃了，比gpu构图还烂</p>

<p>dyn: 这个似乎不错，但是所有高通机器的rom里面只有one的cm在用这个，而且开发者对这个构图方式的看法褒贬不一，就连这个选项是否生效都有争议。</p>

<p>mdp: 从firefox的开发者那里得知，新一点的机器都是有mdp管线的，比gpu构图性能更强、更省电。谷歌也因此强制使用这个构图方式</p>

<h5>(2) 构图方式的影响</h5>

<p>最常见的影响当然就是fps meter打开变卡了</p>

<p>firefox开发者的解释： <a href="https://bugzilla.mozilla.org/show_bug.cgi?id=911391">https://bugzilla.mozilla.org/show_bug.cgi?id=911391</a></p>

<p>当叠加层数量低于mdp管线数量的时候，所有的构图都用mdp完成，不仅性能比gpu构图更好，而且还更省电。但是一旦叠加层数量超过mdp管线的数量，系统就会自动使用“部分mdp构图”，实质上就是要mdp和gpu合作构一帧的图。那么这个时候，就会导致性能下降</p>

<p>为什么打开一些overlay软件就变卡了呢？这就说明打开这类软件以后，比如fps meter，整个图层的数量已经超过了mdp的管线数量，系统启用gpu构图，导致系统、游戏流畅度下降。为什么有些人开始还不觉得fps meter对性能有影响呢？原因可能有三个：1. 他们还在4.2以下，还没用过mdp，一直都在用gpu构图；2. 他们一直都关掉了hw叠加层，也是一直用gpu构图，所以无法感知gpu构图对系统流畅度的严重影响；3. 他们打开了一些overlay软件，但是没有超过mdp的管线数量，没有进入gpu构图</p>

<p>构图的影响还不止这些，如果有人有one，可以试试把这一行
<code>
    persist.hwc.mdpcomp.enable=true
</code></p>

<p>从build.prop里面删掉</p>

<p>重启以后，反复按app抽屉的图标，对比与没删之前的流畅度。另外在贴吧等软件中，mdp构图也会增加滑动的流畅度。至于视频：1. 我没有高速摄像机；2. 这是非常容易感知的问题，耍赖不承认我是没办法的</p>

<p>mdp的缺点：</p>

<p>对于一些老的应用，mdp会造成负面影响，对流畅度负加成：比如在使用老版re管理器的时候，转移到多任务界面会有卡顿，而新版则非常流畅。
在叠加层数量超过mdp管线数量的时候，会转为“部分mdp构图”，mdp管线和gpu合作构图</p>

<p>不过谷歌已经强制使用mdp，随着软件更新，更快更省电的mdp构图将会逐渐替代gpu构图</p>

<h3>四、关于作弊</h3>

<p>很多厂商被逮着了“作弊”，其实我觉得根据不同的app调整策略不是坏事，但是你不开放给用户那就有问题了。凭什么只能跑分得到这样的待遇？厂商真的应该好好反思</p>

<p>1.作弊文件位置：</p>

<p>三星： TwDVFSApp.apk</p>

<p>HTC: /system/bin/pnpmgr; /system/etc/pnp.xml</p>

<p>NVIDIA：/system/app/NvCPLSvc.apk/res/raw/tegraprof.txt</p>

<p>2.如何对待？</p>

<p>作弊固然可耻，但是干掉这些东西又不是明智的选择。虽然这些文件有对跑分的专门配置和优化，但是它们还对普通应用程序/游戏有着配置。比如pnpmgr，它管理者省电模式、touch_boost、60fps视频cpu提频等等非常有用的调整；比如tegraprof，这里面更是有不少针对游戏优化的配置文件。关掉它们只会给用户体验减分。我希望所有厂商能够开放配置，让用户自由定制，而不是现在的加密处理。</p>

<h3>五、关于测试的一些注意事项</h3>

<ol>
<li><p>注明机型，驱动版本，系统版本，内核类型（是官方还是第三方，编译器是什么。换一个编译器可以让某些性能差别达到20%）构图方式</p></li>
<li><p>不要在开启fps meter的同时打开其他悬窗监控软件。fps meter统计的是整个图层的平均帧数，开启其他悬窗监控软解无论刷新率调到多少都是不准的（除非overlay在fps meter上面）</p></li>
<li><p>测试的时候最好关掉温度进程，以防止意外降频</p></li>
<li><p>对比测试的时候注意变化量，在变化量超过一个的时候对比测试结果不可信</p></li>
<li><p>如果想反映整个游戏的帧数情况，用Adreno Profiler。在没有高速摄像机的情况下，这个比视频靠谱得多。<a href="https://developer.qualcomm.com/mobile-development/mobile-technologies/gaming-graphics-optimization-adreno/tools-and-resources">https://developer.qualcomm.com/mobile-development/mobile-technologies/gaming-graphics-optimization-adreno/tools-and-resources</a></p></li>
</ol>


<h3>一、温度控制</h3>

<p>很多人抱怨手机降频，其实这不是坏事，降频厉害，也是oem厂商所为，与soc厂商关系不是太大</p>

<p>可能抱怨最多的就是高通机器了，这里讲下高通机器的温度控制进程的基本调试</p>

<h4>1. 开启和关闭温控进程</h4>

<p>关闭：
<code>
    stop thermald
</code></p>

<p>开启：
<code>
    start thermald
</code></p>

<h5>注意事项：</h5>

<p>关闭温控以后，除非内核中也有温度保护，机器将不会降频，散热设计不好的机器很有可能因此烧毁。请谨慎考虑关闭温控进程</p>

<h4>2. 降频阀值的调整</h4>

<h5>（1）了解自己手机的传感器</h5>

<p>方法1：使用last_kmsg
<code>
    adb pull /proc/last_kmsg
</code>
在adb目录下，找到last_kmsg文件，用记事本（推荐用notepad++/notepad2）打开，搜索sensor</p>

<p>方法2: 使用cat命令逐个查看
<code>
    cat /sys/devices/virtual/thermald/thermald_zone*/temp
</code>
显示出的数值即该传感器的温度</p>

<p>毫无疑问，温度最高的那几个就是cpu温度传感器</p>

<h4>（2）了解thermald配置文件</h4>

<p>配置文件的路径在 /system/etc/thermald.conf，权限为644</p>

<h5>注意：</h5>

<p>对于大部分高通机器，打开即可编辑。对于HTC机器，这个文件是加密的，只能自己写。</p>

<p>对于三星的机器，这个文件会是一个软链，比如E330S软链到了thermald－8974.conf文件，那么你真正应该修改的文件则是thermald－8974.conf</p>

<h4>（3）获取频率表</h4>

<p>获取cpu频率表：
<code>
    cat /sys/devices/system/cpu/cpu0/cpufreq/scaling_available_frequencies
</code></p>

<p>获取gpu频率表：
<code>
    cat /sys/devices/platform/kgsl-3d0.0/kgsl/kgsl-3d0/gpu_available_frequencies
</code></p>

<p>注意：
部分三星机器，比如E330S无法查看gpu频率</p>

<h4>（4）自己改写thermald.conf</h4>

<p>步骤1: 了解thermald.conf的语言</p>

<pre><code>    sampling：采样时间
    [tsen_tz_sensor*]：对于＊号传感器的配置
    thresholds：降频阀值，达到这个温度即降频
    thresholds_clr：恢复阀值，达到这个温度即恢复到上一阶段配置的频率
    actions：降频所采取的行动
    cpu：降频cpu
    gpu：降频gpu
    shutdown：关机
    lcd：改变屏幕亮度，＋255最大
    battery：不懂，但可以知道的是＋1和＋2，能降低温度
    action_info：定义具体降频到多少
</code></pre>

<p>步骤2: 定义总采样时间
<code>
    sampling 5000
</code>
数值越低采样越勤，也越耗费资源。不建议修改</p>

<p>步骤3: 定义传感器
<code>
    [tsens_tz_sensor7]
    sampling 1500
    thresholds 54 57 64 70 75
    thresholds_clr 51 54 57 64 70
    actions gpu+cpu gpu+cpu cpu cpu cpu
    action_info 400000000+1728000 320000000+1134000 1026000 918000 702000
</code></p>

<p>步骤3.1：定义所需要的传感器</p>

<p>在你获得的传感器中，选择所需要的传感器。据我所知，绝大多数高通机器打sensor7, sensor8, sensor9都是cpu温度传感器，若要使用其他温度传感器，直接修改这个数字即可</p>

<p>步骤3.2：定义该传感器的采样时间</p>

<p>sampling 1500</p>

<p>数值越低，采样越勤，不建议修改</p>

<p>步骤3.3: 修改触发行为的温度阀值，即高于这个设定的温度就会采用当前定义的行为，比如降频</p>

<p>thresholds 54 57 64 70 75</p>

<p>步骤3.4: 修改回到上一行为的温度阀值，即低于这个设定温度就会回到上一个温度阀值所定义的行为（shutdown命令除外）</p>

<p>thresholds_clr 51 54 57 64 70</p>

<p>步骤3.5: 定义行为，最常见的就是cpu，gpu，shutdown，若要定义多个行为，则用加号相连</p>

<p>actions gpu+cpu gpu+cpu cpu cpu cpu</p>

<p>步骤3.6: 定义所采取的行为的具体数值，即降频降到多少。</p>

<p>action_info 400000000+1728000 320000000+1134000 1026000 918000 702000</p>

<p>注意： 其数值顺序必须与actions的顺序一模一样，最好与cpu和gpu频率表一致，否则容易出错。千万不要像三星官方一样敷衍了事。</p>

<h4>3. 关于降频的看法</h4>

<p>个人认为降频并不是一件坏事，在soc发热越来越大的今天，降频是厂商保证用户体验的一种方式之一：降低发热，降低耗电</p>

<p>但是我希望每个厂商都能像小米一样开发不同的模式，在需要降频省电的时候用一套温控配置，在需要性能的时候用另一套温控配置；而大多数国际厂商，比如三星，htc，nvidia，仅仅在跑分的时候使用了更高的温度配置，而且是用户无法选择的。这种行为应该表示抗议！强烈谴责！</p>
]]></content>
  </entry>
  
</feed>
