<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

  <title><![CDATA[Category: 2022~08 | kk Blog —— 通用基础]]></title>
  <link href="http://abcdxyzk.github.io/blog/cats/2022~08/atom.xml" rel="self"/>
  <link href="http://abcdxyzk.github.io/"/>
  <updated>2024-05-16T17:25:48+08:00</updated>
  <id>http://abcdxyzk.github.io/</id>
  <author>
    <name><![CDATA[kk]]></name>
    
  </author>
  <generator uri="http://octopress.org/">Octopress</generator>

  
  <entry>
    <title type="html"><![CDATA[JavaScript 图片弹窗]]></title>
    <link href="http://abcdxyzk.github.io/blog/2022/08/28/lang-web-img/"/>
    <updated>2022-08-28T20:59:00+08:00</updated>
    <id>http://abcdxyzk.github.io/blog/2022/08/28/lang-web-img</id>
    <content type="html"><![CDATA[<p><a href="https://c.runoob.com/codedemo/2266/">https://c.runoob.com/codedemo/2266/</a></p>

<h3>html</h3>

<pre><code>    &lt;!DOCTYPE html&gt;
    &lt;html&gt;
        &lt;head&gt;
            &lt;meta charset="utf-8"&gt;
            &lt;title&gt;图片弹窗&lt;/title&gt;
        &lt;/head&gt;
    &lt;body&gt;
        &lt;!-- 触发弹窗 - 图片改为你的图片地址 --&gt;
        &lt;img id="myImg" src="https://static.runoob.com/images/mix/69599048-B5F4-4F07-80F4-F73EC45C0054.png" alt="beautiful" width="300" height="200"&gt;

        &lt;!-- 弹窗 --&gt;
        &lt;div id="myModal" class="modal"&gt;

        &lt;!-- 关闭按钮 --&gt;
        &lt;span class="close" onclick="document.getElementById('myModal').style.display='none'"&gt;&amp;times;&lt;/span&gt;

        &lt;!-- 弹窗内容 --&gt;
        &lt;img class="modal-content" id="img01"&gt;

        &lt;!-- 文本描述 --&gt;
        &lt;div id="caption"&gt;&lt;/div&gt;
        &lt;/div&gt;
    &lt;/body&gt;
    &lt;/html&gt;
</code></pre>

<h3>js</h3>

<pre><code>    // 获取弹窗
    var modal = document.getElementById('myModal');
    //获取图片插入到弹窗
    var img = document.getElementById('myImg');
    var modalImg = document.getElementById('img01');
    var captionText = document.getElementById("caption");

    //获取&lt;span&gt;元素，设置关闭按钮
    var span = document.getElementsByClassName("close")[0];
    //当点击(x)，关闭弹窗
    span.onclick=function(){
        modal.style.display="none";
        modalImg.src="";
    }

    img.onclick=function(){
        modal.style.display="block";
        modalImg.src=this.src;
        captionText.innerHTML=this.alt;
    }

    modal.style.display="block";
    modalImg.src=img.src;
    captionText.innerHTML=img.alt;
</code></pre>

<h3>css</h3>

<pre><code>    /* 触发弹窗图片的样式*/
    #myImg {
        border-radius:5px;
        cursor:pointer;
        transition:0.3x;
    }
    #myImg:hover{
        opacity:0.7;
    }
    /*弹窗背景*/
    .modal{
        display:none;
        position:fixed;
        z-index:1;
        padding-top:100px;
        left:0;
        top:0;
        //width:90%;
        //height:90%;
        overflow:auto;
        background-color:rgb(0,0,0);
        background-color:rgba(0,0,0,0.9);
    }
    /*图片*/
    .modal-content{
        margin:auto;
        display:block;
        width:90%;
        max-width:900px;
    }
    /*文本内容*/
    #caption{
        margin:auto;
        display:block;
        width:90%;
        max-width:900px;
        text-align:center;
        color:#ccc;
        padding:10px 0;
        height:30px;
    }
    /*添加动画*/
    .modal-content, #caption{
        -webkit-animation-name:zoom;
        -webkit-animation-duration:0.2s;
        animation-name:zoom;
        animation-duration:0.2s;
    }
    @-webkit-keyframes zoom{
        from{-webkit-transform:scale(0)}
        to{-webkit-transform:scale(1)}
    }
    @keyframes zoom{
        from{transform:scale(0)}
        to{transform:scale(1)}
    }
    /*关闭按钮*/
    .close{
        position:absolute;
        top:1px;
        right:35px;
        color:#f1f1f1;
        font-size:50px;
        font-weight:bold;
        transition:0.3s;
    }
    .close:hover,
    .close:focus{
        color:#bbb;
        text-decoration:none;
        cursor:pointer;
    }
    /*小屏幕中图片宽度为100%*/
    @media only screen and (max-width:700px){
        .modal-content{
            width:100%;
        }
    }
</code></pre>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[ELO算法的原理及应用]]></title>
    <link href="http://abcdxyzk.github.io/blog/2022/08/28/game-elo/"/>
    <updated>2022-08-28T18:38:00+08:00</updated>
    <id>http://abcdxyzk.github.io/blog/2022/08/28/game-elo</id>
    <content type="html"><![CDATA[<p><a href="https://zhuanlan.zhihu.com/p/57480433">https://zhuanlan.zhihu.com/p/57480433</a></p>

<h2>ELO算法原理</h2>

<h4>预期胜率计算公式</h4>

<p>ELO算法基于这样一种假设：一名选手的当前实力受各种因素的影响会在一定范围内波动，某个时刻的用来描述其实力的函数应当符合正态分布：</p>

<p><img src="/images/alg/20220828-11.png" alt="" /></p>

<p>其中U代表选手的实力平均水平，δ代表实力的稳定性。</p>

<p>经过计算，可以得出两名选手进行对战时的预期胜率：</p>

<p><img src="/images/alg/20220828-12.png" alt="" /></p>

<p>D为两者的分差。</p>

<p>利用了最小二乘法，我们可以得到与它的函数图向相近的另外的一个函数，这也是我们实际运时更常用的函数：</p>

<p><img src="/images/alg/20220828-13.png" alt="" /></p>

<p>（里面的常数项都是曲线拟合的结果，是符合上述统计学规律的，别瞎改）</p>

<p>即当玩家A与玩家B的分差为D时，玩家A对玩家B的期望胜率为P(D)。</p>

<p><img src="/images/alg/20220828-14.jpg" alt="" /></p>

<p>玩家分数相同时，对战预期胜率为50%，分差越大，玩家之间的胜率差距也就越大，当分差大于400时，低分玩家的预期胜率将不足10%。</p>

<p>显然的，我们的玩家的游戏水平的分布也应当是一个正态分布，即大部分玩家的游戏水平都处于平均值附近，游戏水平顶尖或非常菜的人会是少数。</p>

<p>假如我们认为1200分是玩家的平均水平，则所有玩家的各分值分布情况将大致如下图：
各分段玩家比例分布示意图</p>

<p><img src="/images/alg/20220828-15.jpg" alt="" /></p>

<h4>分数迭代公式</h4>

<p>那我们会面临下一个问题：如何知道某个玩家到底是多少分的？</p>

<p>毕竟我们不能用某种机器直接插入玩家大脑测试他的游戏水平吧？</p>

<p>对此，我们的办法是，通过玩家与不同分数的玩家的大量比赛结果，对玩家的分数进行不断地加减修正，直到玩家的分数收敛到其相应的真实水平分数。</p>

<p>下面我们计算玩家在一场比赛后的加减分情况。</p>

<p>玩家在进行一场比赛后的新分数为：</p>

<p><img src="/images/alg/20220828-16.png" alt="" /></p>

<p>Rn是玩家比赛结束后的新的排位分值。</p>

<p>Ro是比赛前玩家的排位分。</p>

<p>K是一个加成系数，由玩家当前分值水平决定（分值越高K越小）。</p>

<p>W是玩家实际对局结果得分（赢=1，输=0）。</p>

<p>P（D）是预期胜率。</p>

<p><img src="/images/alg/20220828-17.jpg" alt="" /></p>

<p>取K=32时，玩家结束一场比赛后的实际得分数如图所示。可以看到玩家战胜比自己低800分的选手后（有近100%的胜率）基本不得分。（这让我想起了守望韩服的猪皇evermore，4950分后打完了一局只加了1分）</p>

<h2>ELO算法应用</h2>

<h3>匹配策略</h3>

<p>以1V1的匹配为例，一般来说遵循以下匹配原则</p>

<p>0~N1秒内，仅匹配分差在X1以内的队友</p>

<p>若N1秒内未找到满足条件对手，放宽匹配条件，N1~N2秒内，仅匹配分差在X2（X2＞X1）以内的对手</p>

<p>……</p>

<p>直到找到对手。</p>

<h3>收敛期快速收敛</h3>

<p>从上面的描述我们可以知道，玩家的一次又一次的比赛过程就是其游戏分数向其真实水平分数收敛的过程。</p>

<p>那么当玩家的游戏分数与真实水平分数相差过大时，其收敛期耗时也会增加，而这一时期参与游戏的玩家的游戏体验都会受到不同程度的影响。</p>

<p>所以我们需要一些特殊的机制来减少这段收敛期。接下来我们按照不同的情况进行讨论。</p>

<h4>1、定位赛阶段</h4>

<p>当一个新玩家加入游戏时，我们肯定无法得知其真实的游戏水平，只能默认他为1200分（平均值）。</p>

<p>为了缩短其收敛期，我们会加入定位赛的设计。</p>

<p>在定位赛局数内，计算玩家得分的K值将再被乘上一个系数。</p>

<h4>2、玩家（账号）实力大幅波动</h4>

<p>首先，我们会引入一个【连胜/连败分数加值】的变量。</p>

<p>当玩家连续获胜或者连续失败N次时，我们有理由相信玩家的游戏分数与真实水平分数相差过大，并按照连胜/连败局数去增加【连胜/连败分数加值】</p>

<p>于是在进行匹配索敌时，将按照【玩家游戏分数】+【连胜/连败分数加值】进行索敌。</p>

<p>（这就是守望一个3000玩家10连胜后到了3300分，但是开始匹配到3500+分玩家的原因）</p>

<p>最后进行分数结算时，按照【玩家游戏分数】进行。</p>

<h4>3、休眠期的分数衰减</h4>

<p>分数衰减的原因是：</p>

<p>（1）我们期望玩家的活跃参与。</p>

<p>（2）我们认为高分段玩家在长时间未进行游戏后，其真实水平也会下降。</p>

<p>所以，一般我们会设计1800分以上的玩家，X天未进行排位后其游戏分数会以Y分/天的速度衰减。</p>

<h3>多对多的拓展</h3>

<p>ELO积分初期是针对象棋选手而定的，所以考虑的都是象棋选手1V1的情况。但是在NVN的游戏排位赛中，需要进行一些特殊的处理。</p>

<p>在多人比赛中，最终得分为：</p>

<p><img src="/images/alg/20220828-18.png" alt="" /></p>

<p>其中，Rn、Ro、K、W的值都不用处理。</p>

<p>对P（D）处理如下：</p>

<pre><code>    D=自己分数-自己分数/己方总分*敌方总分
</code></pre>

<h4>低分段打破零和</h4>

<p>在之前的讨论中，我们可以很明显的发现：</p>

<p>对于同分段玩家来说，因为K值都是一样的，所以赢方加的分恰好等于输方扣的分。</p>

<p>（玩家能上分是因为把人家的分吃了，大鱼吃小鱼小鱼吃虾米，于是最后所有玩家的分数就成了正态分布）</p>

<p>即所有的分数是零和的。</p>

<p>现在的游戏中，一般会期望玩家玩得多了还是能出坑的，即就算你水平略低于平均线，你也可以玩很多局跳出低分段。</p>

<p>于是我们将在低分段（比如1000以下）将胜负方的K值分离。</p>

<p>即胜方的加分按照K1进行。</p>

<p>负方的扣分按照K2进行。</p>

<p>当K1＞K2时，零和将被打破，玩家的分数分布中1000分以下的玩家数量将显著减少。</p>

<h4>ELO积分的包装与隐藏</h4>

<p>ELO积分对玩家水平的精确指示会打击玩家的信心，分值收敛结束后，再进行更多的对局几乎不会有任何提高（除非找了代练或者自己不知道为啥突然打通任督二脉）。</p>

<p>所以我们将玩家真实水平隐藏，并用一些模糊柔和的方式去告诉玩家他当前的水平（按照ELO分数包装为青铜白银黄金白金钻石）。</p>

<p>但记得，ELO分不会消失，从显示变成了隐藏，我们的一切计算还是以ELO分数为依据。</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Dota自走棋段位MMR算法]]></title>
    <link href="http://abcdxyzk.github.io/blog/2022/08/28/game-score/"/>
    <updated>2022-08-28T17:46:00+08:00</updated>
    <id>http://abcdxyzk.github.io/blog/2022/08/28/game-score</id>
    <content type="html"><![CDATA[<p><a href="http://dota2.uuu9.com/201904/591872.shtml">http://dota2.uuu9.com/201904/591872.shtml</a></p>

<h2>MMR算法</h2>

<p>算法其实很简明。</p>

<pre><code>    MMR变化量 = （MMR均值 - 自己的MMR）*0.1725 + 排名对应的常数

    排名对应的常数表：
    第1名：+127
    第2名：+102
    第3名：+77
    第4名：+51
    第5名：-51
    第6名：-77
    第7名：-102
    第8名：-127

特例：第8名至少-15分，最低到0。
推测：第1名至少+15分。作者保留了疑问，不确定真假。
</code></pre>

<h2>注意事项</h2>

<p>自走棋早期是公开MMR的，后来隐藏了，没有发现获取途径。</p>

<p>因为隐藏了，不好判断MMR系统有没有大改。不过隐藏前后没有体感到变化。</p>

<p>皇后分数上限早期是3400，没多久就突破了上限。</p>

<p>80分一段。房间里所有人同一段位时，第1名+127分，就是1.588个段位。第2名1.275个段位，第3名0.96个段位。第1名和第4名相差76分，第4名和第5名相差102分，这就是吃烂分的理论依据。</p>

<p>（存疑）如果第1名至少+15分，段位会通货膨胀。从整体数据观测，实际情况是主教人数向骑士滑移，主要原因是新账号（新人玩家或者小号）。具体参见：数说自走棋。</p>

<p><img src="/images/alg/2022-08-28-1.png" alt="" /></p>

<h2>举例</h2>

<p>下面的例子是模拟结果，感兴趣可以访问GitHub。</p>

<p>8个人分数一样时的情况如下。8个骑士2段和8个皇后的情况是一样的。</p>

<p><img src="/images/alg/2022-08-28-2.png" alt="" /></p>

<p>1个主教2，6个主教1和1个骑士9开主教局的情况：骑士9小赚，主教2小亏。其他分段情况类似，开局时分数最低的最赚，不过前4还是加分，后4还是掉分，只是数值上有差别。</p>

<p><img src="/images/alg/2022-08-28-3.png" alt="" /></p>

<p>房间里7个人分数一样，1个高其他人5段的情况。分数最高第4名扣分。</p>

<p><img src="/images/alg/2022-08-28-4.png" alt="" /></p>

<p>房间里7个人分数一样，1个高其他人7段的情况。分数最高第3名扣分。</p>

<p><img src="/images/alg/2022-08-28-5.png" alt="" /></p>

<p>房间里7个人分数一样，1个高其他人9段的情况。分数最高第2名扣分。</p>

<p><img src="/images/alg/2022-08-28-6.png" alt="" /></p>

<p>房间里7个人分数一样，1个高其他人10段的情况。分数最高的人第1名只+15分。</p>

<p><img src="/images/alg/2022-08-28-7.png" alt="" /></p>

<p>如果没有吃鸡最低+15分的规则，吃鸡不扣分的临界点你比平均分高736分，或者说你比其他7人平均段位高10.5段。高得再多吃鸡也要扣分。</p>

<p>如果没有吃鸡最低+15分的规则，1个3400分皇后号和7个0分士兵号匹配，皇后吃鸡了要扣386分，变成堡垒6段，要是不行第8飞了，对不起，堡垒3段。</p>

<p><img src="/images/alg/2022-08-28-8.png" alt="" /></p>

<p>如果有吃鸡最低+15分的规则，-386变成+15，其他不变。</p>

<p>骑士1-8各1个的情况。骑士8段的玩家第4名只加2分，第1名加的分很少，比骑士1段的玩家吃鸡加的少很多。</p>

<p><img src="/images/alg/2022-08-28-9.png" alt="" /></p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[ssl 证书检查]]></title>
    <link href="http://abcdxyzk.github.io/blog/2022/08/25/ssl-check/"/>
    <updated>2022-08-25T21:59:00+08:00</updated>
    <id>http://abcdxyzk.github.io/blog/2022/08/25/ssl-check</id>
    <content type="html"><![CDATA[<p>企业微信https有时正常有时不正常, 但http都正常，检查一下证书配置</p>

<p><a href="https://www.geocerts.com/ssl-checker">https://www.geocerts.com/ssl-checker</a></p>

<p><a href="https://cloud.tencent.com/document/product/400/35243">https://cloud.tencent.com/document/product/400/35243</a></p>

<h4>apache 证书配置</h4>

<p>编辑 /etc/httpd/conf.d 目录下的 ssl.conf 配置文件。修改如下内容：</p>

<pre><code>    &lt;VirtualHost 0.0.0.0:443&gt;
        DocumentRoot "/var/www/html" 
        #填写证书名称
        ServerName cloud.tencent.com 
        #启用 SSL 功能
        SSLEngine on 
        #证书文件的路径
        SSLCertificateFile /etc/httpd/ssl/cloud.tencent.com.crt 
        #私钥文件的路径
        SSLCertificateKeyFile /etc/httpd/ssl/cloud.tencent.com.key 
        #证书链文件的路径
        SSLCertificateChainFile /etc/httpd/ssl/root_bundle.crt 
    &lt;/VirtualHost&gt;
</code></pre>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[git ssh带端口]]></title>
    <link href="http://abcdxyzk.github.io/blog/2022/08/25/git-ssh/"/>
    <updated>2022-08-25T21:55:00+08:00</updated>
    <id>http://abcdxyzk.github.io/blog/2022/08/25/git-ssh</id>
    <content type="html"><![CDATA[<p>git ssh url port</p>

<pre><code>    [core]
        repositoryformatversion = 0
        filemode = true
        bare = false
        logallrefupdates = true
    [remote "origin"]
        url = ssh://root@1.2.3.4:22/home/kk/sqlbak
        fetch = +refs/heads/*:refs/remotes/origin/*
    [branch "master"]
        remote = origin
        merge = refs/heads/master
</code></pre>
]]></content>
  </entry>
  
</feed>
