<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

  <title><![CDATA[Category: 2023 | kk Blog —— 通用基础]]></title>
  <link href="http://abcdxyzk.github.io/blog/cats/2023/atom.xml" rel="self"/>
  <link href="http://abcdxyzk.github.io/"/>
  <updated>2023-01-24T19:27:19+08:00</updated>
  <id>http://abcdxyzk.github.io/</id>
  <author>
    <name><![CDATA[kk]]></name>
    
  </author>
  <generator uri="http://octopress.org/">Octopress</generator>

  
  <entry>
    <title type="html"><![CDATA[邮件MIME格式分析]]></title>
    <link href="http://abcdxyzk.github.io/blog/2023/01/23/mail-mine/"/>
    <updated>2023-01-23T16:26:00+08:00</updated>
    <id>http://abcdxyzk.github.io/blog/2023/01/23/mail-mine</id>
    <content type="html"><![CDATA[<h3>base64 解码</h3>

<pre><code>    From: "=?gb2312?B?26zQocHB?=" &lt;gaoxl@legendsec.com&gt;

    26zQocHB 是 base64 编码, 解码方法：

    echo 26zQocHB | base64 -d &gt; /tmp/dd

    iconv -fgbk -tutf8 /tmp/dd
</code></pre>

<hr />

<p><a href="https://www.cnblogs.com/crystalray/atricles/3302427.html">https://www.cnblogs.com/crystalray/atricles/3302427.html</a></p>

<p>总体来说，MIME消息由消息头和消息体两大部分组成。这里，分别称为为邮件头、邮件体。</p>

<h2>邮件头</h2>

<p>邮件头包含了发件人、收件人、主题、时 间、MIME版本、邮件内容的类型等重要信息。每条信息称为一个域，由域名后加“: ”和信息内容构成，可以是一行，较长的也可以占用多行。域的首行必须“顶头”写，即左边不能有空白字符（空格和制表符）；续行则必须以空白字符打头，且第 一个空白字符不是信息本身固有的，解码时要过滤掉。</p>

<p>邮件头中不允许出现空行。有一些邮件不能被邮件客户端软件识别，显示的是原始码，就是因为首行是空行。</p>

<p>例如：</p>

<pre><code>    Date: Mon, 29 Jun 2009 18:39:03 +0800
    From: "=?gb2312?B?26zQocHB?=" &lt;gaoxl@legendsec.com&gt;
    To: "moreorless" &lt;moreorless@live.cn&gt;
    Cc: "gxl0620" &lt;gxl0620@163.com&gt;
    BCC: "=?gb2312?B?26zQocHB?=" &lt;venus.oso@gmail.com&gt;
    Subject: attach
    Message-ID: &lt;200906291839032504254@legendsec.com&gt;
    X-mailer: Foxmail 6, 15, 201, 21 [cn]
    Mime-Version: 1.0
</code></pre>

<p><img src="/images/system/20230123-1.jpg" alt="" /></p>

<h2>邮件体</h2>

<p>在邮件体中，大致有如下一些域:</p>

<p><img src="/images/system/20230123-2.jpg" alt="" /></p>

<p>有的域除了值之外，还带有参数。值与参数、参数与参数之间以“;”分隔。参数名与参数值之间以“=”分隔。</p>

<p>邮件体包含邮件的内容，它的类型由邮件头的“Content-Type”域指出。常见的简单类型有text/plain(纯文本)和text/html(超文本)。</p>

<p>multipart类型，是MIME邮件的精髓。邮件体被分为多个段，每个段又包含段头和段体两部分，这两部分之间也以空行分隔。常见的multipart类型有三种：multipart/mixed, multipart/related和multipart/alternative。从它们的名称，不难推知这些类型各自的含义和用处。它们之间的层次关系可归纳为下图所示：</p>

<p><img src="/images/system/20230123-3.jpg" alt="" /></p>

<p>可以看出，如果在邮件中要添加附件，必须定义multipart/mixed段；如果存在内嵌资源，至少要定义multipart/related段；如果纯文本与超文本共存，至少要定义multipart/alternative段。</p>

<p>示例：</p>

<p><img src="/images/system/20230123-4.jpg" alt="" />
 </p>

<h3>MIME编码</h3>

<p>参考rfc2047，MIME Part Three:Message Header Extensions for Non-ASCII Text</p>

<p><a href="http://tools.ietf.org/html/rfc2047">http://tools.ietf.org/html/rfc2047</a></p>

<p>MIME编码的两种方法：</p>

<p>  对邮件进行编码最初的原因是因为Internet上的很多网关不能正确传输8bit内码的字符，比如汉字等。编码的原理就是把8bit的内容转换成7bit的形式以能正确传输，在接收方收到之后，再将其还原成8bit的内容。   </p>

<p>  MIME是“多用途网际邮件扩充协议”的缩写，在MIME协议之前，邮件的编码曾经有过UUENCODE等编码方式，但是由于MIME协议算法简单，并且易于扩展，现在已经成为邮件编码方式的主流，不仅是用来传输8 bit的字符，也可以用来传送二进制的文件，如邮件附件中的图像、音频等信息，而且扩展了很多基于MIME的应用。</p>

<p>从编码方式来说，MIME 定义了两种编码方法Base64与QP(Quote-Printable)：</p>

<h4>Base64</h4>

<p>  Base64是一种通用的方法，其原理很简单，就是把三个Byte的数据用4个Byte表示，这样，这四个Byte中，实际用到的都只有前面6 bit，这样就不存在只能传输7bit的字符的问题了。Base64的缩写一般是“B”。</p>

<p>Base64将输入的字符串或一段数据编码成只含有{&lsquo;A&rsquo;-&lsquo;Z&rsquo;, &lsquo;a&rsquo;-&lsquo;z&rsquo;, &lsquo;0&rsquo;-&lsquo;9&rsquo;, &lsquo;+&rsquo;, &lsquo;/&rsquo;}这64个字符的串，'=&lsquo;用于填充。其编码的方法是，将输入数据流每次取6bit，用此6bit的值(0-63)作为索引去查表，输出相应字符。这样，每3个字节将编码为4个字符(3×8 → 4×6)；不满4个字符的以&rsquo;=&lsquo;填充。 Base64的算法很简单，它将字符流顺序放入一个24位的缓冲区，缺字符的地方补零。
然后将缓冲区截断成为4个部分，高位在先，每个部分6位，用64个字符重新表示。如果输入只有一个或两个字节，那么输出将用等号“=”补足。这可以隔断附加的信息造成编码的混乱。</p>

<h4>QP</h4>

<p>另一种方法是QP(Quote-Printable)方法，通常缩写为“Q”方法，其原理是把一个8 bit   的字符用两个16进制数值表示，然后在前面加“=”。所以我们看到经过QP编码后的文件通常是这个样子：=B3=C2=BF=A1=C7=E5=A3=AC=C4=FA=BA=C3=A3=A1。</p>

<p>QP编码要求编码后每行不能超过76个字符。当超过这个限制时，将使用软换行，用”=”表示编码行的断行，后接CRLF。（76的限制包括”=”）。</p>

<p>“=” 等号被编码为”=3D”。</p>

<p>tab和空格出现在行尾时，需要被编码为”=09”（tab）  “=20”(space)</p>

<p>编码格式：encoded-word = &ldquo;=?&rdquo; charset &ldquo;?&rdquo; encoding &ldquo;?&rdquo; encoded-text &ldquo;?=&rdquo;</p>

<p>编码信息有"=?&ldquo;和&rdquo;?=&ldquo;括起来，&rdquo;=?&ldquo;后是字符集名称，再一个&rdquo;?&ldquo;后是编码方式，再一个&rdquo;?&ldquo;后是编码后的字符串。字符集和编码方式都不区分大小写。</p>

<p>字符集可以是任意系统支持的字符集（iso-8859-1、utf-8、gb2312、gbk、gb18030&hellip;.）</p>

<p><img src="/images/system/20230123-5.jpg" alt="" /></p>

<p>编码方式有两种："B"或"b"代表base64编码；"Q"或"q"代表QP编码。</p>

<p>Generally, an &ldquo;encoded-word&rdquo; is a sequence of printable ASCII characters that begins with &ldquo;=?&rdquo;, ends with &ldquo;?=&rdquo;, and has two &ldquo;?"s in between. It specifies a character set and an encoding method, and also includes the original text encoded as graphic ASCII characters, according to the rules for that encoding method.</p>

<p> </p>

<h3>SMTP与MIME的关系</h3>

<p><img src="/images/system/20230123-6.jpg" alt="" /></p>

<p>从上图可以看出发件人、收件人地址都出现了两次，一次在smtp命令中（SMTP email address），一次在邮件正文中（MIME email address）。需要注意的是：</p>

<p>  邮件正文中可以包含发件人、收件人的别名，smtp命令中不可以</p>

<p>  密送人的地址不一定会出现在邮件正文中。不同客户端实现不同。</p>

<h4>参考：</h4>

<p>rfc4021，Registration of Mail and MIME Header Fields,</p>

<p><a href="http://www.apps.ietf.org/rfc/rfc4021.html,">http://www.apps.ietf.org/rfc/rfc4021.html,</a></p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[4个替代phpMyAdmin的工具]]></title>
    <link href="http://abcdxyzk.github.io/blog/2023/01/20/mysql-web/"/>
    <updated>2023-01-20T16:31:00+08:00</updated>
    <id>http://abcdxyzk.github.io/blog/2023/01/20/mysql-web</id>
    <content type="html"><![CDATA[<p><a href="https://blog.csdn.net/weixin_34392906/article/details/92377986">https://blog.csdn.net/weixin_34392906/article/details/92377986</a></p>

<p>phpMyAdmin是管理MySQL数据库最流行的Web界面。但也有许多其他的工具，我们可代替phpMyAdmin的使用。</p>

<h4>1. Adminer</h4>

<p>Adminer是我的第一选择使用的，而不是phpMyAdmin。 Adminer是单一的PHP脚本，它可以在文档根目录轻松上传，没有任何安装或配置，访问就可用。</p>

<p>Adminer还可以用来管理SQL服务器，Oracle，PostgreSQL等等。 <a href="http://www.adminer.org/">下载Adminer</a></p>

<h4>2. MyWebSQL</h4>

<p>MyWebSQL是一个最终的台式机替代品，他在Web上管理你的MySQL数据库。</p>

<p>它的界面像自己喜欢的桌面应用程序，你不需要不断切换网页，以简单的做好事情。</p>

<p>只需登录到您的数据库和管理数据库，如果你是在您的桌面上工作！ <a href="http://mywebsql.net/">下载MyWebSQL</a></p>

<h4>3. phpMiniAdmin</h4>

<p>phpMiniAdmin是快速和容易管理MySQL数据库，是phpMyAdmin轻量级的选择。</p>

<p>phpminiadmin是写在只有大小为10KB+，它可以轻松上传到Web服务器的文档根目录，并在Web浏览器访问PHP。 <a href="http://phpminiadmin.sourceforge.net/">下载phpMiniAdmin</a></p>

<h4>4. SQL Buddy</h4>

<p>SQL Buddy是用于MySQL管理的一个很棒的工具，phpMyAdmin的一个替代品。</p>

<p>它超级容易建立，还有一个漂亮的界面。 <a href="http://sqlbuddy.com/">下载SQL Buddy</a></p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[phpMyAdmin web管理mysql]]></title>
    <link href="http://abcdxyzk.github.io/blog/2023/01/20/mysql-phpMyAdmin/"/>
    <updated>2023-01-20T16:24:00+08:00</updated>
    <id>http://abcdxyzk.github.io/blog/2023/01/20/mysql-phpMyAdmin</id>
    <content type="html"><![CDATA[<p><a href="http://t.zoukankan.com/ioveNature-p-6477758.html">http://t.zoukankan.com/ioveNature-p-6477758.html</a></p>

<p>安装MySQL数据库后，用户即可在命令行提示符下进行创建数据库和数据表等各种操作，但这种方法非常麻烦，而且需要有专业的SQL语言知识。PHP官方开发了一个可视化图形管理工具phpMyAdmin，该工具可以运行在各种版本的PHP及MySQL下。通过phpMyAdmin完全可以对数据库进行各种操作，如建立，复制和删除数据等。</p>

<p>phpMyAdmin为初学者提供了图形化的操作界面，这样MySQL数据库的操作就不必再命令提示符下通过命令实现，从而大大提高了开发的效率。用户可以在官方网站 www.phpmyadmin.net 上免费下载到最新版本。</p>

<p><a href="https://github.com/abcdxyzk/abcdxyzk.github.io_files/raw/master/tools/phpMyAdmin-5.2.0-all-languages.zip">phpMyAdmin-5.2.0-all-languages.zip</a></p>

<h3>一、操作数据库</h3>

<p>打开 192.168.0.123/phpMyAdmin 输入数据库的用户名和密码，可成功登陆phpMyAdmin。</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[ASP 备份sqlserver]]></title>
    <link href="http://abcdxyzk.github.io/blog/2023/01/20/mssql-asp-dump-sqlserver/"/>
    <updated>2023-01-20T16:11:00+08:00</updated>
    <id>http://abcdxyzk.github.io/blog/2023/01/20/mssql-asp-dump-sqlserver</id>
    <content type="html"><![CDATA[<p><a href="https://www.cnblogs.com/yechuan/articles/84208.html">https://www.cnblogs.com/yechuan/articles/84208.html</a></p>

<h3>只有备份</h3>

<pre><code>    &lt;HTML&gt;
    &lt;HEAD&gt;
        &lt;TITLE&gt;SQL Server 数据库的备份&lt;/TITLE&gt;
        &lt;meta http-equiv="Content-Type" content="text/html; charset=gb2312"&gt;
    &lt;/HEAD&gt;
    &lt;BODY&gt;
    &lt;form method="post" name=myform&gt;
    选择操作：&lt;INPUT TYPE="radio" NAME="act" id="act_backup" value="backup"&gt;&lt;label for=act_backup&gt;备份&lt;/label&gt;　
    &lt;input type="submit" value="确定"&gt;
    &lt;/form&gt;

    &lt;%

    dim sqlserver,sqlname,sqlpassword,sqlLoginTimeout,databasename,bak_file,act

    sqlserver = "127.0.0.1"     'sql服务器
    sqlname = "dbname"      '用户名
    sqlpassword = "passwd"      '密码
    sqlLoginTimeout = 15        '登陆超时
    databasename = "dbname"
    bak_file = Server.MapPath(".") &amp; "\np.sql"

    act = lcase(request("act"))
    if databasename = "" then
        response.write "input database name"
    else
        if act = "backup" then
            Set srv=Server.CreateObject("SQLDMO.SQLServer")
            srv.LoginTimeout = sqlLoginTimeout
            srv.Connect sqlserver,sqlname, sqlpassword
            Set bak = Server.CreateObject("SQLDMO.Backup")
            bak.Database=databasename
            bak.Devices=Files
            bak.Files=bak_file
            bak.SQLBackup srv
            if err.number&gt;0 then
                response.write err.number&amp;"&lt;font color=red&gt;&lt;br&gt;"
                response.write err.description&amp;"&lt;/font&gt;"
            end if
            Response.write "&lt;font color=green&gt;备份成功!&lt;/font&gt;"
        else
            Response.write "&lt;font color=red&gt;没有选择操作&lt;/font&gt;"
        end if
    end if
    %&gt;
    &lt;/BODY&gt;
    &lt;/HTML&gt;
</code></pre>

<h3>all</h3>

<pre><code>    &lt;HTML&gt;
    &lt;HEAD&gt;
        &lt;TITLE&gt;SQL Server 数据库的备份与恢复&lt;/TITLE&gt;
        &lt;meta http-equiv="Content-Type" content="text/html; charset=gb2312"&gt;
    &lt;/HEAD&gt;
    &lt;BODY&gt;

    &lt;form method="post" name=myform&gt;
    选择操作：&lt;INPUT TYPE="radio" NAME="act" id="act_backup" value="backup"&gt;&lt;label for=act_backup&gt;备份&lt;/label&gt;　
    &lt;INPUT TYPE="radio" NAME="act" id="act_restore" value="restore"&gt;&lt;label for=act_restore&gt;恢复&lt;/label&gt;
    &lt;br&gt;数据库名：&lt;INPUT TYPE="text" NAME="databasename" value="&lt;%=request("databasename")%&gt;"&gt;
    &lt;br&gt;文件路径：&lt;INPUT TYPE="text" NAME="bak_file" value="c:\$1.bak"&gt;(备份或恢复的文件路径)&lt;br&gt;
    &lt;input type="submit" value="确定"&gt;
    &lt;/form&gt;

    &lt;%

    dim sqlserver,sqlname,sqlpassword,sqlLoginTimeout,databasename,bak_file,act

    sqlserver = "localhost"       'sql服务器
    sqlname = "sa"            '用户名
    sqlpassword = "sa"        '密码
    sqlLoginTimeout = 15      '登陆超时
    databasename = trim(request("databasename"))
    bak_file = trim(request("bak_file"))
    bak_file = replace(bak_file,"$1",databasename)
    act = lcase(request("act"))

    if databasename = "" then
        response.write "input database name"
    else
        if act = "backup" then
            Set srv=Server.CreateObject("SQLDMO.SQLServer")
            srv.LoginTimeout = sqlLoginTimeout
            srv.Connect sqlserver,sqlname, sqlpassword
            Set bak = Server.CreateObject("SQLDMO.Backup")
            bak.Database=databasename
            bak.Devices=Files
            bak.Files=bak_file
            bak.SQLBackup srv
            if err.number&gt;0 then
                response.write err.number&amp;"&lt;font color=red&gt;&lt;br&gt;"
                response.write err.description&amp;"&lt;/font&gt;"
            end if
            Response.write "&lt;font color=green&gt;备份成功!&lt;/font&gt;"
        elseif act = "restore" then
            '恢复时要在没有使用数据库时进行！
            Set srv=Server.CreateObject("SQLDMO.SQLServer")
            srv.LoginTimeout = sqlLoginTimeout
            srv.Connect sqlserver,sqlname, sqlpassword
            Set rest=Server.CreateObject("SQLDMO.Restore")
            rest.Action=0 ' full db restore
            rest.Database=databasename
            rest.Devices=Files
            rest.Files=bak_file
            rest.ReplaceDatabase=True 'Force restore over existing database
            if err.number&gt;0 then
                response.write err.number&amp;"&lt;font color=red&gt;&lt;br&gt;"
                response.write err.description&amp;"&lt;/font&gt;"
            end if
            rest.SQLRestore srv

            Response.write "&lt;font color=green&gt;恢复成功!&lt;/font&gt;"
        else
            Response.write "&lt;font color=red&gt;没有选择操作&lt;/font&gt;"
       end if
    end if

    %&gt;
    &lt;/BODY&gt;
    &lt;/HTML&gt;
</code></pre>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[ASPMyAdmin web管理sqlserver]]></title>
    <link href="http://abcdxyzk.github.io/blog/2023/01/20/mssql-aspmyadmin/"/>
    <updated>2023-01-20T16:06:00+08:00</updated>
    <id>http://abcdxyzk.github.io/blog/2023/01/20/mssql-aspmyadmin</id>
    <content type="html"><![CDATA[<p><a href="http://www.a1vbcode.com/app-3301.asp">http://www.a1vbcode.com/app-3301.asp</a></p>

<p><a href="/download/tools/ASPMyAdmin.zip">ASPMyAdmin.zip</a></p>

<p>备份数据库似乎会提示error</p>
]]></content>
  </entry>
  
</feed>
