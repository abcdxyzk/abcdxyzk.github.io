<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

  <title><![CDATA[Category: debug~mark | kk Blog —— 通用基础]]></title>
  <link href="http://abcdxyzk.github.io/blog/cats/debug~mark/atom.xml" rel="self"/>
  <link href="http://abcdxyzk.github.io/"/>
  <updated>2024-12-31T15:25:29+08:00</updated>
  <id>http://abcdxyzk.github.io/</id>
  <author>
    <name><![CDATA[kk]]></name>
    
  </author>
  <generator uri="http://octopress.org/">Octopress</generator>

  
  <entry>
    <title type="html"><![CDATA[拥塞控制模块无法卸载]]></title>
    <link href="http://abcdxyzk.github.io/blog/2018/01/03/debug-mark-cong-rmmod/"/>
    <updated>2018-01-03T00:04:00+08:00</updated>
    <id>http://abcdxyzk.github.io/blog/2018/01/03/debug-mark-cong-rmmod</id>
    <content type="html"><![CDATA[<p>如果listen的sk设置了icsk_ca_setsockopt，那么派生的child默认都是sk的cong，而不是系统默认的cong</p>

<hr />

<p>如果：自定义拥塞控制中维护了hash表，且在init时加入hash表，在release时删除或卸载清理hash表。</p>

<p>那么：有些情况会导致分配了拥塞控制模块给sk，但却没调init，导致卸载清理时就找不到模块被哪个sk引用，也就无法清理。</p>

<h3>可能原因：</h3>

<h4>1. 拥塞控制初始化时</h4>

<p>标准内核：socket()时分配拥塞控制，但在连接建立时才会调 icsk->icsk_ca_ops->init(sk)
如果只调了 socket(), bind(), listen() 那么就不会调 icsk->icsk_ca_ops->init(sk)（所以listen的sk就一定不调init）。</p>

<p>内核可行修改方案：socket -> tcp_init_sock -> tcp_assign_congestion_control 时先分配一个内核内部的拥塞控制，连接建立时再分配实际拥塞控制，然后初始化。
这么改还是有缺陷：先调 socket()，再调 setsockopt 设置拥塞控制模块，因为此时sk->sk_state = TCP_CLOSE，所以不会调init</p>

<h4>2. 拥塞控制切换时</h4>

<p>拥塞控制切换时：如果是TCP_CLOSE状态也不会调 icsk->icsk_ca_ops->init(sk) 初始化</p>

<h3>可行解决方法</h3>

<p>模仿 /proc/net/tcp 遍历hash表，修改拥塞控制</p>

<h3>特殊情况：</h3>

<p>调 socket 时 sk 不加入hash表，在 listen 或 connect 时才会加入到hash表，如果只调socket、bind然后不再使用该fd，那么sk不仅没调icsk->icsk_ca_ops->init(sk)，也没加入hash表。</p>

<p>此时 /proc/net/tcp 也找不到sk，只能遍历所有进程的所有fd，找出sk再修改</p>

<p><a href="/download/debug/conglist.tar.gz">conglist.tar.gz</a></p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[CentOS 5.x安装新内核之后时钟混乱问题]]></title>
    <link href="http://abcdxyzk.github.io/blog/2016/01/06/debug-mark-rtc/"/>
    <updated>2016-01-06T11:08:00+08:00</updated>
    <id>http://abcdxyzk.github.io/blog/2016/01/06/debug-mark-rtc</id>
    <content type="html"><![CDATA[<pre><code>    $ ll /etc/rc.sysinit
    /etc/rc.sysinit -&gt; rc.d/rc.sysinit
</code></pre>

<p>el5在调用mkinitrd命令时，会将/dev/rtc生成好，放到initrd- x.x.x.img文件中。而el6的系统在 /etc/rc.sysinit的/sbin/start_udev 之前是有这两个文件，也没找到el6的系统是在哪里加的这两句。</p>

<p>el5可选的一个做法是：修改/etc/rc.sysinit,在/sbin/start_udev这行之前加入两行：
<code>
    mv /dev/rtc /dev/rtc0
    ln -sf rtc0 /dev/rtc
</code>
在/sbin/start_udev这行之后加入一行
<code>
    [ -x /sbin/hwclock ] &amp;&amp; /sbin/hwclock $CLOCKFLAGS
</code>
这样el5系统用18、32内核都没问题了。</p>

<p>el5试着将这两句改在/sbin/mkinitrd里修改，但不知道为什么改完后在执行到 /etc/rc.sysinit 时 /dev/rtc 这个软连接不见了。</p>

<p>或者直接将/dev/rtc改成254，0
<code>``
    diff --git a/mkinitrd b/mkinitrd
    index 5ddb909..dcba61d 100755
    --- a/mkinitrd
    +++ b/mkinitrd
    @@ -1708,7 +1708,14 @@ done
     mknod $MNTIMAGE/dev/tty c 5 0
     mknod $MNTIMAGE/dev/console c 5 1
     mknod $MNTIMAGE/dev/ptmx c 5 2
    -mknod $MNTIMAGE/dev/rtc c 10 135
    +
    +kernelval=</code>echo $kernel | awk -F &ldquo;[-|.]&rdquo; &lsquo;{print $1<em>65536+$2</em>256+$3}&rsquo;`
    +#echo &ldquo;kernel=$kernel kernelval=$kernelval&rdquo;
    +if [ $kernelval -lt 132640 ]; then
    +   mknod $MNTIMAGE/dev/rtc c 10 135
    +else
    +   mknod $MNTIMAGE/dev/rtc c 254 0
    +fi</p>

<pre><code> if [ "$(uname -m)" == "ia64" ]; then
     mknod $MNTIMAGE/dev/efirtc c 10 136
@@ -1911,8 +1918,16 @@ mknod /dev/systty c 4 0
 mknod /dev/tty c 5 0
 mknod /dev/console c 5 1
 mknod /dev/ptmx c 5 2
-mknod /dev/rtc c 10 135
 EOF
+
+kernelval=`echo $kernel | awk -F "[-|.]" '{print $1*65536+$2*256+$3}'`
+#echo "kernel=$kernel kernelval=$kernelval"
+if [ $kernelval -lt 132640 ]; then
+   emit "mknod /dev/rtc c 10 135"
+else
+   emit "mknod /dev/rtc c 254 0"
+fi
+
 if [ "$(uname -m)" == "ia64" ]; then
     emit "mknod /dev/efirtc c 10 136"
 fi
</code></pre>

<pre><code>然后重建img
</code></pre>

<pre><code>/sbin/new-kernel-pkg --package kernel --mkinitrd --depmod --install 2.6.32-XXX
</code></pre>

<pre><code>
------------------

http://www.csdn123.com/html/mycsdn20140110/59/59dd8c5f069a09bf9dc1785e19eb329f.html

CentOS在安装完新内核之后，每次重启之后时钟总是会发生一些变化，使得系统时钟不准确。在多操作系统的情况下（例如windows和 linux双系统），还可能会出现时区的偏差，而且无论如何设置，在重启之后都会恢复原样。如何解决这个问题还得从操作系统的时钟原理开始。

#### 1. 操作系统中的时钟

操作系统为实现其功能，必须知道当前外部世界的时间（年月日时分秒等）。为实现这一目的，计算机设计者在主板上设置了一个硬件时钟，由主板上的一块纽扣电池（Cell）供电，这个硬件时钟无论计算机电源是否接通都会不停的数秒，来计算当前时间。

操作系统在启动的时候，会调用一段程序来读取主板上的硬件时钟，并记录在操作系统的一个（或一组）变量中。自此之后，操作系统的时钟便脱离主板的硬件时钟，开始单独运行（操作系统时钟的运行是由时钟中断来驱动的，不同于主板上的时钟）。

无论做工多么精细，主板硬件时钟和由时钟中断维护的操作系统内的时钟多多少少会有一些误差。所以，操作系统在每次关闭的时候会调用另一段程序，将操作系统 内的时钟写到主板硬件时钟里（这样设计是不是说明时钟中断比主板硬件时钟更准确一些呢？）。类似的，当用户在操作系统内修改时钟之后，也不会立即写入主板 时钟，而是在关机的时候写入硬件时钟。

#### 2. 旧汤和新药的冲突
主板上的硬件时钟在Linux操作系统中呈现为一个设备，设备名称为rtc（Real Time Clock）。

使用旧的系统（如CentOS的2.6.18内核）编译新内核时，在调用mkinitrd命令时，会将/dev/rtc生成好，放到initrd- x.x.x.img文件中;而新的内核是自己生成/dev/rtc文件的，当kernel生成/dev/rtc时，发现系统内已经有了这个设备，于是就会 创建/dev/rtc0设备。这时hwclock程序仍然会读取rtc设备，就会造成设备读写失败。运行`hwclock --debug`命令可以看到如下输出：
</code></pre>

<pre><code>[root@localhost ~]# hwclock --debug
hwclock from util-linux-2.13-pre7
hwclock: Open of /dev/rtc failed, errno=19: No such device.
No usable clock interface found.
Cannot access the Hardware Clock via any known method.
</code></pre>

<pre><code>但是有的能够直接读写I/O，这样虽然/dev/rtc是错的，但还能正常运行
</code></pre>

<pre><code>[root@localhost ~]# hwclock --debug
hwclock from util-linux-2.13-pre7
hwclock: Open of /dev/rtc failed, errno=19: No such device.
Using direct I/O instructions to ISA clock.
.....
</code></pre>

<pre><code>
其实，对应这个问题，新版的hwclock已经做出了调整。新的hwclock会主动去寻找/dev/rtc0设备，来操作主板硬件时钟。于是，解决方法就出现了。

#### 3. 新汤配新药
既然内核这剂药已经换成了新的，那我们就把外围应用程序hwclock也换成新的。

从这里可以下载比较新的（不用最新的是因为最新的源码在旧版的CentOS上编译会出现错误）程序源码：http://now-code.com/download/util-linux-ng-2.17.tar.bz2 

如果需要更多版本的程序源码，请到这里下载：ftp://ftp.kernel.org/pub/linux/utils/。

下载完成之后，编译该程序：
</code></pre>

<pre><code>tar xfv util-linux-ng-2.17.tar.bz2
cd util-linux-ng-2.17
./configure
make
</code></pre>

<pre><code>编译完成之后，将生成的hwclock文件拷贝到指定位置即可：
</code></pre>

<pre><code>cp hwclock/hwclock /sbin/
</code></pre>

<p>```</p>

<p>之后，操作系统和主板的硬件时钟就可以同步起来了。</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[ack loop]]></title>
    <link href="http://abcdxyzk.github.io/blog/2015/09/30/debug-loop_ack/"/>
    <updated>2015-09-30T15:32:00+08:00</updated>
    <id>http://abcdxyzk.github.io/blog/2015/09/30/debug-loop_ack</id>
    <content type="html"><![CDATA[<h4>patch</h4>

<pre><code>    commit 4fb17a6091674f469e8ac85dc770fbf9a9ba7cc8
    Author: Neal Cardwell &lt;ncardwell@google.com&gt;
    Date:   Fri Feb 6 16:04:41 2015 -0500

        tcp: mitigate ACK loops for connections as tcp_timewait_sock

        Ensure that in state FIN_WAIT2 or TIME_WAIT, where the connection is
        represented by a tcp_timewait_sock, we rate limit dupacks in response
        to incoming packets (a) with TCP timestamps that fail PAWS checks, or
        (b) with sequence numbers that are out of the acceptable window.

        We do not send a dupack in response to out-of-window packets if it has
        been less than sysctl_tcp_invalid_ratelimit (default 500ms) since we
        last sent a dupack in response to an out-of-window packet.

        Reported-by: Avery Fay &lt;avery@mixpanel.com&gt;
        Signed-off-by: Neal Cardwell &lt;ncardwell@google.com&gt;
        Signed-off-by: Yuchung Cheng &lt;ycheng@google.com&gt;
        Signed-off-by: Eric Dumazet &lt;edumazet@google.com&gt;
        Signed-off-by: David S. Miller &lt;davem@davemloft.net&gt;

    diff --git a/include/linux/tcp.h b/include/linux/tcp.h
    index 66d85a8..1a7adb4 100644
    --- a/include/linux/tcp.h
    +++ b/include/linux/tcp.h
    @@ -342,6 +342,10 @@ struct tcp_timewait_sock {
        u32           tw_rcv_wnd;
        u32           tw_ts_offset;
        u32           tw_ts_recent;
    +
    +   /* The time we sent the last out-of-window ACK: */
    +   u32           tw_last_oow_ack_time;
    +
        long              tw_ts_recent_stamp;
     #ifdef CONFIG_TCP_MD5SIG
        struct tcp_md5sig_key     *tw_md5_key;
    diff --git a/net/ipv4/tcp_minisocks.c b/net/ipv4/tcp_minisocks.c
    index 98a8405..dd11ac7 100644
    --- a/net/ipv4/tcp_minisocks.c
    +++ b/net/ipv4/tcp_minisocks.c
    @@ -58,6 +58,25 @@ static bool tcp_in_window(u32 seq, u32 end_seq, u32 s_win, u32 e_win)
        return seq == e_win &amp;&amp; seq == end_seq;
     }

    +static enum tcp_tw_status
    +tcp_timewait_check_oow_rate_limit(struct inet_timewait_sock *tw,
    +                 const struct sk_buff *skb, int mib_idx)
    +{
    +   struct tcp_timewait_sock *tcptw = tcp_twsk((struct sock *)tw);
    +
    +   if (!tcp_oow_rate_limited(twsk_net(tw), skb, mib_idx,
    +                 &amp;tcptw-&gt;tw_last_oow_ack_time)) {
    +       /* Send ACK. Note, we do not put the bucket,
    +        * it will be released by caller.
    +        */
    +       return TCP_TW_ACK;
    +   }
    +
    +   /* We are rate-limiting, so just release the tw sock and drop skb. */
    +   inet_twsk_put(tw);
    +   return TCP_TW_SUCCESS;
    +}
    +
     /*
      * * Main purpose of TIME-WAIT state is to close connection gracefully,
      *   when one of ends sits in LAST-ACK or CLOSING retransmitting FIN
    @@ -116,7 +135,8 @@ tcp_timewait_state_process(struct inet_timewait_sock *tw, struct sk_buff *skb,
                !tcp_in_window(TCP_SKB_CB(skb)-&gt;seq, TCP_SKB_CB(skb)-&gt;end_seq,
                       tcptw-&gt;tw_rcv_nxt,
                       tcptw-&gt;tw_rcv_nxt + tcptw-&gt;tw_rcv_wnd))
    -           return TCP_TW_ACK;
    +           return tcp_timewait_check_oow_rate_limit(
    +               tw, skb, LINUX_MIB_TCPACKSKIPPEDFINWAIT2);

            if (th-&gt;rst)
                goto kill;
    @@ -250,10 +270,8 @@ kill:
                inet_twsk_schedule(tw, &amp;tcp_death_row, TCP_TIMEWAIT_LEN,
                           TCP_TIMEWAIT_LEN);

    -       /* Send ACK. Note, we do not put the bucket,
    -        * it will be released by caller.
    -        */
    -       return TCP_TW_ACK;
    +       return tcp_timewait_check_oow_rate_limit(
    +           tw, skb, LINUX_MIB_TCPACKSKIPPEDTIMEWAIT);
        }
        inet_twsk_put(tw);
        return TCP_TW_SUCCESS;
    @@ -289,6 +307,7 @@ void tcp_time_wait(struct sock *sk, int state, int timeo)
            tcptw-&gt;tw_ts_recent = tp-&gt;rx_opt.ts_recent;
            tcptw-&gt;tw_ts_recent_stamp = tp-&gt;rx_opt.ts_recent_stamp;
            tcptw-&gt;tw_ts_offset = tp-&gt;tsoffset;
    +       tcptw-&gt;tw_last_oow_ack_time = 0;

     #if IS_ENABLED(CONFIG_IPV6)
            if (tw-&gt;tw_family == PF_INET6) {

    commit f2b2c582e82429270d5818fbabe653f4359d7024
    Author: Neal Cardwell &lt;ncardwell@google.com&gt;
    Date:   Fri Feb 6 16:04:40 2015 -0500

        tcp: mitigate ACK loops for connections as tcp_sock

        Ensure that in state ESTABLISHED, where the connection is represented
        by a tcp_sock, we rate limit dupacks in response to incoming packets
        (a) with TCP timestamps that fail PAWS checks, or (b) with sequence
        numbers or ACK numbers that are out of the acceptable window.

        We do not send a dupack in response to out-of-window packets if it has
        been less than sysctl_tcp_invalid_ratelimit (default 500ms) since we
        last sent a dupack in response to an out-of-window packet.

        There is already a similar (although global) rate-limiting mechanism
        for "challenge ACKs". When deciding whether to send a challence ACK,
        we first consult the new per-connection rate limit, and then the
        global rate limit.

        Reported-by: Avery Fay &lt;avery@mixpanel.com&gt;
        Signed-off-by: Neal Cardwell &lt;ncardwell@google.com&gt;
        Signed-off-by: Yuchung Cheng &lt;ycheng@google.com&gt;
        Signed-off-by: Eric Dumazet &lt;edumazet@google.com&gt;
        Signed-off-by: David S. Miller &lt;davem@davemloft.net&gt;

    diff --git a/include/linux/tcp.h b/include/linux/tcp.h
    index bcc828d..66d85a8 100644
    --- a/include/linux/tcp.h
    +++ b/include/linux/tcp.h
    @@ -153,6 +153,7 @@ struct tcp_sock {
        u32 snd_sml;    /* Last byte of the most recently transmitted small packet */
        u32 rcv_tstamp; /* timestamp of last received ACK (for keepalives) */
        u32 lsndtime;   /* timestamp of last sent data packet (for restart window) */
    +   u32 last_oow_ack_time;  /* timestamp of last out-of-window ACK */

        u32 tsoffset;   /* timestamp offset */

    diff --git a/net/ipv4/tcp_input.c b/net/ipv4/tcp_input.c
    index 9401aa43..8fdd27b 100644
    --- a/net/ipv4/tcp_input.c
    +++ b/net/ipv4/tcp_input.c
    @@ -3322,13 +3322,22 @@ static int tcp_ack_update_window(struct sock *sk, const struct sk_buff *skb, u32
     }

     /* RFC 5961 7 [ACK Throttling] */
    -static void tcp_send_challenge_ack(struct sock *sk)
    +static void tcp_send_challenge_ack(struct sock *sk, const struct sk_buff *skb)
     {
        /* unprotected vars, we dont care of overwrites */
        static u32 challenge_timestamp;
        static unsigned int challenge_count;
    -   u32 now = jiffies / HZ;
    +   struct tcp_sock *tp = tcp_sk(sk);
    +   u32 now;
    +
    +   /* First check our per-socket dupack rate limit. */
    +   if (tcp_oow_rate_limited(sock_net(sk), skb,
    +                LINUX_MIB_TCPACKSKIPPEDCHALLENGE,
    +                &amp;tp-&gt;last_oow_ack_time))
    +       return;

    +   /* Then check the check host-wide RFC 5961 rate limit. */
    +   now = jiffies / HZ;
        if (now != challenge_timestamp) {
            challenge_timestamp = now;
            challenge_count = 0;
    @@ -3424,7 +3433,7 @@ static int tcp_ack(struct sock *sk, const struct sk_buff *skb, int flag)
        if (before(ack, prior_snd_una)) {
            /* RFC 5961 5.2 [Blind Data Injection Attack].[Mitigation] */
            if (before(ack, prior_snd_una - tp-&gt;max_window)) {
    -           tcp_send_challenge_ack(sk);
    +           tcp_send_challenge_ack(sk, skb);
                return -1;
            }
            goto old_ack;
    @@ -4993,7 +5002,10 @@ static bool tcp_validate_incoming(struct sock *sk, struct sk_buff *skb,
            tcp_paws_discard(sk, skb)) {
            if (!th-&gt;rst) {
                NET_INC_STATS_BH(sock_net(sk), LINUX_MIB_PAWSESTABREJECTED);
    -           tcp_send_dupack(sk, skb);
    +           if (!tcp_oow_rate_limited(sock_net(sk), skb,
    +                         LINUX_MIB_TCPACKSKIPPEDPAWS,
    +                         &amp;tp-&gt;last_oow_ack_time))
    +               tcp_send_dupack(sk, skb);
                goto discard;
            }
            /* Reset is accepted even if it did not pass PAWS. */
    @@ -5010,7 +5022,10 @@ static bool tcp_validate_incoming(struct sock *sk, struct sk_buff *skb,
            if (!th-&gt;rst) {
                if (th-&gt;syn)
                    goto syn_challenge;
    -           tcp_send_dupack(sk, skb);
    +           if (!tcp_oow_rate_limited(sock_net(sk), skb,
    +                         LINUX_MIB_TCPACKSKIPPEDSEQ,
    +                         &amp;tp-&gt;last_oow_ack_time))
    +               tcp_send_dupack(sk, skb);
            }
            goto discard;
        }
    @@ -5026,7 +5041,7 @@ static bool tcp_validate_incoming(struct sock *sk, struct sk_buff *skb,
            if (TCP_SKB_CB(skb)-&gt;seq == tp-&gt;rcv_nxt)
                tcp_reset(sk);
            else
    -           tcp_send_challenge_ack(sk);
    +           tcp_send_challenge_ack(sk, skb);
            goto discard;
        }

    @@ -5040,7 +5055,7 @@ syn_challenge:
            if (syn_inerr)
                TCP_INC_STATS_BH(sock_net(sk), TCP_MIB_INERRS);
            NET_INC_STATS_BH(sock_net(sk), LINUX_MIB_TCPSYNCHALLENGE);
    -       tcp_send_challenge_ack(sk);
    +       tcp_send_challenge_ack(sk, skb);
            goto discard;
        }

    diff --git a/net/ipv4/tcp_minisocks.c b/net/ipv4/tcp_minisocks.c
    index 131aa49..98a8405 100644
    --- a/net/ipv4/tcp_minisocks.c
    +++ b/net/ipv4/tcp_minisocks.c
    @@ -467,6 +467,7 @@ struct sock *tcp_create_openreq_child(struct sock *sk, struct request_sock *req,
            tcp_enable_early_retrans(newtp);
            newtp-&gt;tlp_high_seq = 0;
            newtp-&gt;lsndtime = treq-&gt;snt_synack;
    +       newtp-&gt;last_oow_ack_time = 0;
            newtp-&gt;total_retrans = req-&gt;num_retrans;

            /* So many TCP implementations out there (incorrectly) count the

    commit a9b2c06dbef48ed31cff1764c5ce824829106f4f
    Author: Neal Cardwell &lt;ncardwell@google.com&gt;
    Date:   Fri Feb 6 16:04:39 2015 -0500

        tcp: mitigate ACK loops for connections as tcp_request_sock

        In the SYN_RECV state, where the TCP connection is represented by
        tcp_request_sock, we now rate-limit SYNACKs in response to a client's
        retransmitted SYNs: we do not send a SYNACK in response to client SYN
        if it has been less than sysctl_tcp_invalid_ratelimit (default 500ms)
        since we last sent a SYNACK in response to a client's retransmitted
        SYN.

        This allows the vast majority of legitimate client connections to
        proceed unimpeded, even for the most aggressive platforms, iOS and
        MacOS, which actually retransmit SYNs 1-second intervals for several
        times in a row. They use SYN RTO timeouts following the progression:
        1,1,1,1,1,2,4,8,16,32.

        Reported-by: Avery Fay &lt;avery@mixpanel.com&gt;
        Signed-off-by: Neal Cardwell &lt;ncardwell@google.com&gt;
        Signed-off-by: Yuchung Cheng &lt;ycheng@google.com&gt;
        Signed-off-by: Eric Dumazet &lt;edumazet@google.com&gt;
        Signed-off-by: David S. Miller &lt;davem@davemloft.net&gt;

    diff --git a/include/linux/tcp.h b/include/linux/tcp.h
    index 67309ec..bcc828d 100644
    --- a/include/linux/tcp.h
    +++ b/include/linux/tcp.h
    @@ -115,6 +115,7 @@ struct tcp_request_sock {
        u32             rcv_isn;
        u32             snt_isn;
        u32             snt_synack; /* synack sent time */
    +   u32             last_oow_ack_time; /* last SYNACK */
        u32             rcv_nxt; /* the ack # by SYNACK. For
                              * FastOpen it's the seq#
                              * after data-in-SYN.
    diff --git a/include/net/tcp.h b/include/net/tcp.h
    index b81f45c..da4196fb 100644
    --- a/include/net/tcp.h
    +++ b/include/net/tcp.h
    @@ -1145,6 +1145,7 @@ static inline void tcp_openreq_init(struct request_sock *req,
        tcp_rsk(req)-&gt;rcv_isn = TCP_SKB_CB(skb)-&gt;seq;
        tcp_rsk(req)-&gt;rcv_nxt = TCP_SKB_CB(skb)-&gt;seq + 1;
        tcp_rsk(req)-&gt;snt_synack = tcp_time_stamp;
    +   tcp_rsk(req)-&gt;last_oow_ack_time = 0;
        req-&gt;mss = rx_opt-&gt;mss_clamp;
        req-&gt;ts_recent = rx_opt-&gt;saw_tstamp ? rx_opt-&gt;rcv_tsval : 0;
        ireq-&gt;tstamp_ok = rx_opt-&gt;tstamp_ok;
    diff --git a/net/ipv4/tcp_minisocks.c b/net/ipv4/tcp_minisocks.c
    index bc9216d..131aa49 100644
    --- a/net/ipv4/tcp_minisocks.c
    +++ b/net/ipv4/tcp_minisocks.c
    @@ -605,7 +605,11 @@ struct sock *tcp_check_req(struct sock *sk, struct sk_buff *skb,
             * Reset timer after retransmitting SYNACK, similar to
             * the idea of fast retransmit in recovery.
             */
    -       if (!inet_rtx_syn_ack(sk, req))
    +       if (!tcp_oow_rate_limited(sock_net(sk), skb,
    +                     LINUX_MIB_TCPACKSKIPPEDSYNRECV,
    +                     &amp;tcp_rsk(req)-&gt;last_oow_ack_time) &amp;&amp;
    +
    +           !inet_rtx_syn_ack(sk, req))
                req-&gt;expires = min(TCP_TIMEOUT_INIT &lt;&lt; req-&gt;num_timeout,
                           TCP_RTO_MAX) + jiffies;
            return NULL;

    commit 032ee4236954eb214651cb9bfc1b38ffa8fd7a01
    Author: Neal Cardwell &lt;ncardwell@google.com&gt;
    Date:   Fri Feb 6 16:04:38 2015 -0500

        tcp: helpers to mitigate ACK loops by rate-limiting out-of-window dupacks

        Helpers for mitigating ACK loops by rate-limiting dupacks sent in
        response to incoming out-of-window packets.

        This patch includes:

        - rate-limiting logic
        - sysctl to control how often we allow dupacks to out-of-window packets
        - SNMP counter for cases where we rate-limited our dupack sending

        The rate-limiting logic in this patch decides to not send dupacks in
        response to out-of-window segments if (a) they are SYNs or pure ACKs
        and (b) the remote endpoint is sending them faster than the configured
        rate limit.

        We rate-limit our responses rather than blocking them entirely or
        resetting the connection, because legitimate connections can rely on
        dupacks in response to some out-of-window segments. For example, zero
        window probes are typically sent with a sequence number that is below
        the current window, and ZWPs thus expect to thus elicit a dupack in
        response.

        We allow dupacks in response to TCP segments with data, because these
        may be spurious retransmissions for which the remote endpoint wants to
        receive DSACKs. This is safe because segments with data can't
        realistically be part of ACK loops, which by their nature consist of
        each side sending pure/data-less ACKs to each other.

        The dupack interval is controlled by a new sysctl knob,
        tcp_invalid_ratelimit, given in milliseconds, in case an administrator
        needs to dial this upward in the face of a high-rate DoS attack. The
        name and units are chosen to be analogous to the existing analogous
        knob for ICMP, icmp_ratelimit.

        The default value for tcp_invalid_ratelimit is 500ms, which allows at
        most one such dupack per 500ms. This is chosen to be 2x faster than
        the 1-second minimum RTO interval allowed by RFC 6298 (section 2, rule
        2.4). We allow the extra 2x factor because network delay variations
        can cause packets sent at 1 second intervals to be compressed and
        arrive much closer.

        Reported-by: Avery Fay &lt;avery@mixpanel.com&gt;
        Signed-off-by: Neal Cardwell &lt;ncardwell@google.com&gt;
        Signed-off-by: Yuchung Cheng &lt;ycheng@google.com&gt;
        Signed-off-by: Eric Dumazet &lt;edumazet@google.com&gt;
        Signed-off-by: David S. Miller &lt;davem@davemloft.net&gt;

    diff --git a/Documentation/networking/ip-sysctl.txt b/Documentation/networking/ip-sysctl.txt
    index a5e4c81..1b8c964 100644
    --- a/Documentation/networking/ip-sysctl.txt
    +++ b/Documentation/networking/ip-sysctl.txt
    @@ -290,6 +290,28 @@ tcp_frto - INTEGER

        By default it's enabled with a non-zero value. 0 disables F-RTO.

    +tcp_invalid_ratelimit - INTEGER
    +   Limit the maximal rate for sending duplicate acknowledgments
    +   in response to incoming TCP packets that are for an existing
    +   connection but that are invalid due to any of these reasons:
    +
    +     (a) out-of-window sequence number,
    +     (b) out-of-window acknowledgment number, or
    +     (c) PAWS (Protection Against Wrapped Sequence numbers) check failure
    +
    +   This can help mitigate simple "ack loop" DoS attacks, wherein
    +   a buggy or malicious middlebox or man-in-the-middle can
    +   rewrite TCP header fields in manner that causes each endpoint
    +   to think that the other is sending invalid TCP segments, thus
    +   causing each side to send an unterminating stream of duplicate
    +   acknowledgments for invalid segments.
    +
    +   Using 0 disables rate-limiting of dupacks in response to
    +   invalid segments; otherwise this value specifies the minimal
    +   space between sending such dupacks, in milliseconds.
    +
    +   Default: 500 (milliseconds).
    +
     tcp_keepalive_time - INTEGER
        How often TCP sends out keepalive messages when keepalive is enabled.
        Default: 2hours.
    diff --git a/include/net/tcp.h b/include/net/tcp.h
    index 28e9bd3..b81f45c 100644
    --- a/include/net/tcp.h
    +++ b/include/net/tcp.h
    @@ -274,6 +274,7 @@ extern int sysctl_tcp_challenge_ack_limit;
     extern unsigned int sysctl_tcp_notsent_lowat;
     extern int sysctl_tcp_min_tso_segs;
     extern int sysctl_tcp_autocorking;
    +extern int sysctl_tcp_invalid_ratelimit;

     extern atomic_long_t tcp_memory_allocated;
     extern struct percpu_counter tcp_sockets_allocated;
    @@ -1236,6 +1237,37 @@ static inline bool tcp_paws_reject(const struct tcp_options_received *rx_opt,
        return true;
     }

    +/* Return true if we're currently rate-limiting out-of-window ACKs and
    + * thus shouldn't send a dupack right now. We rate-limit dupacks in
    + * response to out-of-window SYNs or ACKs to mitigate ACK loops or DoS
    + * attacks that send repeated SYNs or ACKs for the same connection. To
    + * do this, we do not send a duplicate SYNACK or ACK if the remote
    + * endpoint is sending out-of-window SYNs or pure ACKs at a high rate.
    + */
    +static inline bool tcp_oow_rate_limited(struct net *net,
    +                   const struct sk_buff *skb,
    +                   int mib_idx, u32 *last_oow_ack_time)
    +{
    +   /* Data packets without SYNs are not likely part of an ACK loop. */
    +   if ((TCP_SKB_CB(skb)-&gt;seq != TCP_SKB_CB(skb)-&gt;end_seq) &amp;&amp;
    +       !tcp_hdr(skb)-&gt;syn)
    +       goto not_rate_limited;
    +
    +   if (*last_oow_ack_time) {
    +       s32 elapsed = (s32)(tcp_time_stamp - *last_oow_ack_time);
    +
    +       if (0 &lt;= elapsed &amp;&amp; elapsed &lt; sysctl_tcp_invalid_ratelimit) {
    +           NET_INC_STATS_BH(net, mib_idx);
    +           return true;    /* rate-limited: don't send yet! */
    +       }
    +   }
    +
    +   *last_oow_ack_time = tcp_time_stamp;
    +
    +not_rate_limited:
    +   return false;   /* not rate-limited: go ahead, send dupack now! */
    +}
    +
     static inline void tcp_mib_init(struct net *net)
     {
        /* See RFC 2012 */
    diff --git a/include/uapi/linux/snmp.h b/include/uapi/linux/snmp.h
    index b222241..6a6fb74 100644
    --- a/include/uapi/linux/snmp.h
    +++ b/include/uapi/linux/snmp.h
    @@ -270,6 +270,12 @@ enum
        LINUX_MIB_TCPHYSTARTTRAINCWND,      /* TCPHystartTrainCwnd */
        LINUX_MIB_TCPHYSTARTDELAYDETECT,    /* TCPHystartDelayDetect */
        LINUX_MIB_TCPHYSTARTDELAYCWND,      /* TCPHystartDelayCwnd */
    +   LINUX_MIB_TCPACKSKIPPEDSYNRECV,     /* TCPACKSkippedSynRecv */
    +   LINUX_MIB_TCPACKSKIPPEDPAWS,        /* TCPACKSkippedPAWS */
    +   LINUX_MIB_TCPACKSKIPPEDSEQ,     /* TCPACKSkippedSeq */
    +   LINUX_MIB_TCPACKSKIPPEDFINWAIT2,    /* TCPACKSkippedFinWait2 */
    +   LINUX_MIB_TCPACKSKIPPEDTIMEWAIT,    /* TCPACKSkippedTimeWait */
    +   LINUX_MIB_TCPACKSKIPPEDCHALLENGE,   /* TCPACKSkippedChallenge */
        __LINUX_MIB_MAX
     };

    diff --git a/net/ipv4/proc.c b/net/ipv4/proc.c
    index 8f9cd20..d8953ef 100644
    --- a/net/ipv4/proc.c
    +++ b/net/ipv4/proc.c
    @@ -292,6 +292,12 @@ static const struct snmp_mib snmp4_net_list[] = {
        SNMP_MIB_ITEM("TCPHystartTrainCwnd", LINUX_MIB_TCPHYSTARTTRAINCWND),
        SNMP_MIB_ITEM("TCPHystartDelayDetect", LINUX_MIB_TCPHYSTARTDELAYDETECT),
        SNMP_MIB_ITEM("TCPHystartDelayCwnd", LINUX_MIB_TCPHYSTARTDELAYCWND),
    +   SNMP_MIB_ITEM("TCPACKSkippedSynRecv", LINUX_MIB_TCPACKSKIPPEDSYNRECV),
    +   SNMP_MIB_ITEM("TCPACKSkippedPAWS", LINUX_MIB_TCPACKSKIPPEDPAWS),
    +   SNMP_MIB_ITEM("TCPACKSkippedSeq", LINUX_MIB_TCPACKSKIPPEDSEQ),
    +   SNMP_MIB_ITEM("TCPACKSkippedFinWait2", LINUX_MIB_TCPACKSKIPPEDFINWAIT2),
    +   SNMP_MIB_ITEM("TCPACKSkippedTimeWait", LINUX_MIB_TCPACKSKIPPEDTIMEWAIT),
    +   SNMP_MIB_ITEM("TCPACKSkippedChallenge", LINUX_MIB_TCPACKSKIPPEDCHALLENGE),
        SNMP_MIB_SENTINEL
     };

    diff --git a/net/ipv4/sysctl_net_ipv4.c b/net/ipv4/sysctl_net_ipv4.c
    index e0ee384..82601a6 100644
    --- a/net/ipv4/sysctl_net_ipv4.c
    +++ b/net/ipv4/sysctl_net_ipv4.c
    @@ -729,6 +729,13 @@ static struct ctl_table ipv4_table[] = {
            .extra2     = &amp;one,
        },
        {
    +       .procname   = "tcp_invalid_ratelimit",
    +       .data       = &amp;sysctl_tcp_invalid_ratelimit,
    +       .maxlen     = sizeof(int),
    +       .mode       = 0644,
    +       .proc_handler   = proc_dointvec_ms_jiffies,
    +   },
    +   {
            .procname   = "icmp_msgs_per_sec",
            .data       = &amp;sysctl_icmp_msgs_per_sec,
            .maxlen     = sizeof(int),
    diff --git a/net/ipv4/tcp_input.c b/net/ipv4/tcp_input.c
    index d3dfff7..9401aa43 100644
    --- a/net/ipv4/tcp_input.c
    +++ b/net/ipv4/tcp_input.c
    @@ -100,6 +100,7 @@ int sysctl_tcp_thin_dupack __read_mostly;

     int sysctl_tcp_moderate_rcvbuf __read_mostly = 1;
     int sysctl_tcp_early_retrans __read_mostly = 3;
    +int sysctl_tcp_invalid_ratelimit __read_mostly = HZ/2;

     #define FLAG_DATA      0x01 /* Incoming frame contained data.      */
     #define FLAG_WIN_UPDATE        0x02 /* Incoming ACK was a window update.   */
</code></pre>

<hr />

<h4>sample</h4>

<pre><code>    #define KMSG_COMPONENT "synflood"
    #define pr_fmt(fmt) KMSG_COMPONENT ": " fmt

    #include &lt;linux/module.h&gt;
    #include &lt;linux/kernel.h&gt;
    #include &lt;linux/ip.h&gt;
    #include &lt;linux/tcp.h&gt;
    #include &lt;linux/icmp.h&gt;
    #include &lt;linux/netfilter.h&gt;
    #include &lt;linux/netfilter_ipv4.h&gt;
    #include &lt;linux/netdevice.h&gt;

    #include &lt;net/ip.h&gt;
    #include &lt;net/tcp.h&gt;
    #include &lt;net/udp.h&gt;
    #include &lt;net/icmp.h&gt;

    __be16 cport = 80;
    char *selfip = NULL;

    module_param(cport, short, S_IRUGO);
    module_param(selfip, charp, S_IRUGO);

    void skbcsum(struct sk_buff *skb)
    {
        struct tcphdr *tcph;
        struct iphdr *iph;
        int iphl;
        int tcphl;
        int tcplen;

        iph = (struct iphdr *)skb-&gt;data;
        iphl = iph-&gt;ihl &lt;&lt; 2;
        tcph = (struct tcphdr *)(skb-&gt;data + iphl);
        tcphl = tcph-&gt;doff &lt;&lt; 2;

        iph-&gt;check = 0;
        iph-&gt;check = ip_fast_csum((unsigned char *)iph, iph-&gt;ihl);

        tcph-&gt;check    = 0;
        tcplen        = skb-&gt;len - (iph-&gt;ihl &lt;&lt; 2);
        if (skb-&gt;ip_summed == CHECKSUM_PARTIAL) {
            tcph-&gt;check = ~csum_tcpudp_magic(iph-&gt;saddr, iph-&gt;daddr,
                    tcplen, IPPROTO_TCP, 0);
            skb-&gt;csum_start    = skb_transport_header(skb) - skb-&gt;head;
            skb-&gt;csum_offset = offsetof(struct tcphdr, check);
        }
        else {
            skb-&gt;csum = 0;
            skb-&gt;csum = skb_checksum(skb, iph-&gt;ihl &lt;&lt; 2, tcplen, 0);
            tcph-&gt;check = csum_tcpudp_magic(iph-&gt;saddr, iph-&gt;daddr,
                    tcplen, IPPROTO_TCP, skb-&gt;csum);

        }
    }

    int pktcome = 0;
    int fincome = 0;
    static int check(__be32 ip, __be16 port, int syn, int fin)
    {
        if ((selfip == NULL || ip == in_aton(selfip)) &amp;&amp; ntohs(port) == cport) {
            if (syn) {
                pktcome = 0;
                fincome = 0;
            }
            pktcome ++;
            if (pktcome &gt; 30 || fincome == 3)
                return 1;
            fincome |= fin;
        }
        return 0;
    }

    static unsigned int local_in(unsigned int hooknum, 
        struct sk_buff *skb, const struct net_device *in, 
        const struct net_device *out, int (*okfn) (struct sk_buff *))
    {
        struct iphdr *iph;
        struct tcphdr *th;

        if (unlikely(skb-&gt;pkt_type != PACKET_HOST))
            goto exit;
        if (unlikely(skb-&gt;protocol != __constant_htons(ETH_P_IP)))
            goto exit;
        iph = (struct iphdr *)skb_network_header(skb);
        if (iph-&gt;protocol != IPPROTO_TCP)
            goto exit;
        if (unlikely(!pskb_may_pull(skb, iph-&gt;ihl * 4 + sizeof(struct tcphdr))))
            goto drop_out;
        skb_set_transport_header(skb, iph-&gt;ihl * 4);
        th = tcp_hdr(skb);
        if (check(iph-&gt;daddr, th-&gt;dest, th-&gt;syn, th-&gt;fin)) {
            skb-&gt;ip_summed = CHECKSUM_UNNECESSARY;
            th-&gt;seq = htonl(ntohl(th-&gt;seq) + 10000000);
        }
    exit:
        return NF_ACCEPT;
    drop_out:
        return NF_DROP;
    }

    static unsigned int local_out(unsigned int hooknum, 
        struct sk_buff *skb, const struct net_device *in, 
        const struct net_device *out, int (*okfn) (struct sk_buff *))
    {
        struct iphdr *iph;
        struct tcphdr *th;

        iph = (struct iphdr *)skb_network_header(skb);
        if (iph-&gt;protocol != IPPROTO_TCP)
            goto exit;
        if (unlikely(!pskb_may_pull(skb, iph-&gt;ihl * 4 + sizeof(struct tcphdr))))
            goto drop_out;
        skb_set_transport_header(skb, iph-&gt;ihl * 4);
        th = tcp_hdr(skb);
        if (check(iph-&gt;saddr, th-&gt;source, 0, (th-&gt;fin) &lt;&lt; 1)) {
            th-&gt;seq = htonl(ntohl(th-&gt;seq) + 10000000);
            skbcsum(skb);
        }
    exit:
        return NF_ACCEPT;
    drop_out:
        return NF_DROP;
    }

    static struct nf_hook_ops syndef_ops[] __read_mostly = {
        {
            .hook = local_in,
            .owner = THIS_MODULE,
            .pf = PF_INET,
            .hooknum = NF_INET_LOCAL_IN,
            .priority = 100,
        },
        {
            .hook = local_out,
            .owner = THIS_MODULE,
            .pf = PF_INET,
            .hooknum = NF_INET_LOCAL_OUT,
            .priority = 100,
        },

    };

    int __init loopack_init(void)
    {
        int ret;

        ret = nf_register_hooks(syndef_ops, ARRAY_SIZE(syndef_ops));
        if (ret &lt; 0) {
            pr_err("can't register hooks.\n");
            goto hooks_err;
        }

        pr_err("init success.\n");

    hooks_err:
        return ret;
    }

    void __exit loopack_exit(void)
    {
        nf_unregister_hooks(syndef_ops, ARRAY_SIZE(syndef_ops));

        pr_err("unload success.\n");
    }

    module_init(loopack_init);
    module_exit(loopack_exit);
    MODULE_AUTHOR("kk");
    MODULE_VERSION("1.0.0");
    MODULE_LICENSE("GPL");
</code></pre>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Machine Check Exception]]></title>
    <link href="http://abcdxyzk.github.io/blog/2015/09/02/debug-mce/"/>
    <updated>2015-09-02T16:53:00+08:00</updated>
    <id>http://abcdxyzk.github.io/blog/2015/09/02/debug-mce</id>
    <content type="html"><![CDATA[<p>dmesg显示
```
    &hellip;</p>

<pre><code>sbridge: HANDLING MCE MEMORY ERROR
CPU 0: Machine Check Exception: 0 Bank 5: 8c00004000010093
TSC 0 ADDR 67081b300 MISC 2140040486 PROCESSOR 0:206d7 TIME 1441181676 SOCKET 0 APIC 0
EDAC MC0: CE row 2, channel 0, label "CPU_SrcID#0_Channel#3_DIMM#0": 1 Unknown error(s): memory read on FATAL area : cpu=0 Err=0001:0093 (ch=3), addr= 0x67081b300 =&gt; socket=0, Channel=3(mask=8), rank=0

...
</code></pre>

<pre><code>
保存4行log为mlog
</code></pre>

<pre><code># mcelog --ascii &lt; /tmp/mlog
WARNING: with --dmi mcelog --ascii must run on the same machine with the
     same BIOS/memory configuration as where the machine check occurred.
sbridge: HANDLING MCE MEMORY ERROR
CPU 0: Machine Check Exception: 0 Bank 5: 8c00004000010093
HARDWARE ERROR. This is *NOT* a software problem!
Please contact your hardware vendor
Wed Sep  2 16:14:36 2015
CPU 0 BANK 5 MISC 2140040486 ADDR 67081b300
STATUS 8c00004000010093 MCGSTATUS 0
CPUID Vendor Intel Family 6 Model 45
WARNING: SMBIOS data is often unreliable. Take with a grain of salt!
&lt;24&gt; DIMM 1333 Mhz Res13 Width 72 Data Width 64 Size 16 GB
Device Locator: Node0_Channel2_Dimm0
Bank Locator: Node0_Bank0
Manufacturer: Hynix Semiconducto
Serial Number: 40743B5A
Asset Tag: Dimm2_AssetTag
Part Number: HMT42GR7BFR4A-PB
TSC 0 ADDR 67081b300 MISC 2140040486 PROCESSOR 0:206d7 TIME 1441181676 SOCKET 0 APIC 0
EDAC MC0: CE row 2, channel 0, label "CPU_SrcID#0_Channel#3_DIMM#0": 1 Unknown error(s): memory read on FATAL area : cpu=0 Err=0001:0093 (ch=3), addr = 0x67081b300 =&gt; socket=0, Channel=3(mask=8), rank=0
</code></pre>

<pre><code>
根据  
Part Number: HMT42GR7BFR4A-PB  
Serial Number: 40743B5A  

在lshw中找相应硬件
</code></pre>

<pre><code>...

     *-memory:0
          description: System Memory
          physical id: 2d
          slot: System board or motherboard
        *-bank:0
             description: DIMM 1333 MHz (0.8 ns)
             product: HMT42GR7BFR4A-PB
             vendor: Hynix Semiconducto
             physical id: 0
             serial: 905D21AE
             slot: Node0_Channel1_Dimm0
             size: 16GiB
             width: 64 bits
             clock: 1333MHz (0.8ns)
        *-bank:1
             description: DIMM Synchronous [empty]
             product: A1_Dimm1_PartNumber
             vendor: Dimm1_Manufacturer
             physical id: 1
             serial: Dimm1_SerNum
             slot: Node0_Channel1_Dimm1
             width: 64 bits
        *-bank:2
             description: DIMM 1333 MHz (0.8 ns)
             product: HMT42GR7BFR4A-PB
             vendor: Hynix Semiconducto
             physical id: 2
             serial: 40743B5A
             slot: Node0_Channel2_Dimm0
             size: 16GiB
             width: 64 bits
             clock: 1333MHz (0.8ns)

        ...
</code></pre>

<p>```</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[ixgbe两个合并包功能]]></title>
    <link href="http://abcdxyzk.github.io/blog/2015/08/21/debug-ixgbe/"/>
    <updated>2015-08-21T15:29:00+08:00</updated>
    <id>http://abcdxyzk.github.io/blog/2015/08/21/debug-ixgbe</id>
    <content type="html"><![CDATA[<p><a href="http://downloadmirror.intel.com/22919/eng/README.txt">http://downloadmirror.intel.com/22919/eng/README.txt</a></p>

<p><a href="http://www.360doc.com/content/12/1101/17/9008018_245137867.shtml">http://www.360doc.com/content/12/1101/17/9008018_245137867.shtml</a></p>

<pre><code>      LRO
      ---
      Large Receive Offload (LRO) is a technique for increasing inbound throughput
      of high-bandwidth network connections by reducing CPU overhead. It works by
      aggregating multiple incoming packets from a single stream into a larger 
      buffer before they are passed higher up the networking stack, thus reducing
      the number of packets that have to be processed. LRO combines multiple 
      Ethernet frames into a single receive in the stack, thereby potentially 
      decreasing CPU utilization for receives. 

      IXGBE_NO_LRO is a compile time flag. The user can enable it at compile
      time to remove support for LRO from the driver. The flag is used by adding 
      CFLAGS_EXTRA="-DIXGBE_NO_LRO" to the make file when it's being compiled. 

         make CFLAGS_EXTRA="-DIXGBE_NO_LRO" install

      You can verify that the driver is using LRO by looking at these counters in 
      ethtool:

      lro_flushed - the total number of receives using LRO.
      lro_aggregated - counts the total number of Ethernet packets that were combined.

      NOTE: IPv6 and UDP are not supported by LRO.

      HW RSC
      ------
      82599 and X540-based adapters support HW based receive side coalescing (RSC) 
      which can merge multiple frames from the same IPv4 TCP/IP flow into a single
      structure that can span one or more descriptors. It works similarly to SW
      Large receive offload technique. By default HW RSC is enabled and SW LRO 
      cannot be used for 82599 or X540-based adapters unless HW RSC is disabled.

      IXGBE_NO_HW_RSC is a compile time flag. The user can enable it at compile 
      time to remove support for HW RSC from the driver. The flag is used by adding 
      CFLAGS_EXTRA="-DIXGBE_NO_HW_RSC" to the make file when it's being compiled.

         make CFLAGS_EXTRA="-DIXGBE_NO_HW_RSC" install

      You can verify that the driver is using HW RSC by looking at the counter in 
      ethtool:

         hw_rsc_count - counts the total number of Ethernet packets that were being
         combined.

        ...

    max_vfs
    -------
    Valid Range:   1-63
    Default Value: 0

      If the value is greater than 0 it will also force the VMDq parameter to be 1
      or more.

      This parameter adds support for SR-IOV.  It causes the driver to spawn up to 
      max_vfs worth of virtual function.  

      NOTE: When either SR-IOV mode or VMDq mode is enabled, hardware VLAN 
      filtering and VLAN tag stripping/insertion will remain enabled.
      Please remove the old VLAN filter before the new VLAN filter is added.
      For example, 

        ip link set eth0 vf 0 vlan 100     // set vlan 100 for VF 0
        ip link set eth0 vf 0 vlan 0       // Delete vlan 100 
        ip link set eth0 vf 0 vlan 200     // set a new vlan 200 for VF 0

    The parameters for the driver are referenced by position.  So, if you have a 
    dual port 82599 or X540-based adapter and you want N virtual functions per 
    port, you must specify a number for each port with each parameter separated by
    a comma.

    For example:
      modprobe ixgbe max_vfs=63,63

    NOTE: If both 82598 and 82599 or X540-based adapters are installed on the same 
    machine, you must be careful in loading the driver with the parameters. 
    Depending on system configuration, number of slots, etc. it's impossible to 
    predict in all cases where the positions would be on the command line and the 
    user will have to specify zero in those positions occupied by an 82598 port.

    With kernel 3.6, the driver supports the simultaneous usage of max_vfs and DCB 
    features, subject to the constraints described below. Prior to kernel 3.6, the 
    driver did not support the simultaneous operation of max_vfs &gt; 0 and the DCB 
    features (multiple traffic classes utilizing Priority Flow Control and Extended 
    Transmission Selection).

    When DCB is enabled, network traffic is transmitted and received through multiple 
    traffic classes (packet buffers in the NIC). The traffic is associated with a 
    specific class based on priority, which has a value of 0 through 7 used in the 
    VLAN tag. When SR-IOV is not enabled, each traffic class is associated with a set 
    of RX/TX descriptor queue pairs. The number of queue pairs for a given traffic 
    class depends on the hardware configuration. When SR-IOV is enabled, the descriptor 
    queue pairs are grouped into pools. The Physical Function (PF) and each Virtual 
    Function (VF) is allocated a pool of RX/TX descriptor queue pairs. When multiple 
    traffic classes are configured (for example, DCB is enabled), each pool contains a 
    queue pair from each traffic class. When a single traffic class is configured in 
    the hardware, the pools contain multiple queue pairs from the single traffic class.

    The number of VFs that can be allocated depends on the number of traffic classes 
    that can be enabled. The configurable number of traffic classes for each enabled 
    VF is as follows:

      0 - 15 VFs = Up to 8 traffic classes, depending on device support

      16 - 31 VFs = Up to 4 traffic classes

      32 - 63 = 1 traffic class 

    When VFs are configured, the PF is allocated one pool as well. The PF supports 
    the DCB features with the constraint that each traffic class will only use a 
    single queue pair. When zero VFs are configured, the PF can support multiple 
    queue pairs per traffic class.
</code></pre>

<hr />

<p>如果编译时disable了LRO，但没有disable RSC，可以用 ethtool -C eth2 rx-usecs 0 临时解决，或用 max_vfs=1 ？？？</p>

<p><a href="https://bugzilla.redhat.com/show_bug.cgi?id=680998">https://bugzilla.redhat.com/show_bug.cgi?id=680998</a></p>

<pre><code>
    Chris Wright has this board in hands, here the comment from him:
    &gt; OK, disabling hw RSC with 'ethtool -C eth2 rx-usecs 0' (thanks
    &gt; Herbert!) is bringing this back for me (something like ~1800 Mb/s).
    &gt; This is roughly what booting with max_vfs=1 should have done, so I'm not
    &gt; sure why that didn't work.

    Note that disabling coalescing with ethtool results in better, 
    though still poor performance as would be expected since we're disabling coalescing. 
    The "max_vfs=1" parameter disables RSC as a side-effect and 
    doesn't have the performance hit that disabling interrupt coalescing on the NIC does. 
    In internal testing, "max_vfs=1" results in ~2.5x better performance than using ethtool.
</code></pre>
]]></content>
  </entry>
  
</feed>
