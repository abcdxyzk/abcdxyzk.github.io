<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

  <title><![CDATA[Category: kernel~proc | kk Blog —— 通用基础]]></title>
  <link href="http://abcdxyzk.github.io/blog/cats/kernel~proc/atom.xml" rel="self"/>
  <link href="http://abcdxyzk.github.io/"/>
  <updated>2024-07-31T15:24:28+08:00</updated>
  <id>http://abcdxyzk.github.io/</id>
  <author>
    <name><![CDATA[kk]]></name>
    
  </author>
  <generator uri="http://octopress.org/">Octopress</generator>

  
  <entry>
    <title type="html"><![CDATA[数据交换 genlink, 使用nl库]]></title>
    <link href="http://abcdxyzk.github.io/blog/2020/08/10/kernel-genlink-nl/"/>
    <updated>2020-08-10T23:13:00+08:00</updated>
    <id>http://abcdxyzk.github.io/blog/2020/08/10/kernel-genlink-nl</id>
    <content type="html"><![CDATA[<p>3.x 内核</p>

<h3>kernel</h3>

<pre><code>    #include &lt;linux/module.h&gt;
    #include &lt;net/netlink.h&gt;
    #include &lt;net/genetlink.h&gt;
    #include &lt;linux/version.h&gt;

    #define MSG_KER "Hello from kernel space!!!"

    struct family_hdr {
        int ff;
    };

    struct data_hdr {
        int len;
        int kk;
        char str[0];
    };

    /* netlink attributes */
    enum {
        DOC_EXMPL_A_UNSPEC,
        DOC_EXMPL_A_MSG,
        DOC_EXMPL_A_MSG2,
        __DOC_EXMPL_A_MAX,
    };
    #define DOC_EXMPL_A_MAX (__DOC_EXMPL_A_MAX - 1)

    /* commands 定义命令类型，用户空间以此来表明需要执行的命令 */
    enum {
        DOC_EXMPL_C_UNSPEC,
        DOC_EXMPL_C_ECHO,
        __DOC_EXMPL_C_MAX,
    };
    #define DOC_EXMPL_C_MAX (__DOC_EXMPL_C_MAX - 1)

    static int nl_pre_doit(struct genl_ops*  ops, struct sk_buff* skb, struct genl_info* info)
    {
        return 0;
    }
    static void nl_post_doit(struct genl_ops*  ops, struct sk_buff* skb, struct genl_info* info)
    {
        return;
    }

    /* family definition */
    static struct genl_family nl_family = {
        .id = GENL_ID_GENERATE,   //这里不指定family ID，由内核进行分配
        .hdrsize = sizeof(struct family_hdr),             //自定义的头部长度，参考genl数据包结构
        .name = "DOC_EXMPL",      //这里定义family的名称，user program需要根据这个名字来找到对应的family ID。
        .version = 1,
        .maxattr = DOC_EXMPL_A_MAX,
        .pre_doit  = nl_pre_doit,
        .post_doit = nl_post_doit,
    };

    static int rcv_handler(struct genl_info *info)
    {
        struct nlattr *tb[DOC_EXMPL_A_MAX + 1] = {0};
        struct family_hdr *fhdr = (struct family_hdr *)info-&gt;userhdr;
        struct data_hdr *hdr;
        int rc, i;
        int rcvlen;

        //printk("kernel recv: %d %d %d %s\n", fhdr-&gt;ff, hdr-&gt;len, hdr-&gt;kk, hdr-&gt;str);
        //printk("gg %d\n", info-&gt;nlhdr-&gt;nlmsg_len - ((u64)info-&gt;userhdr - (u64)info-&gt;nlhdr) - sizeof(struct family_hdr));
        rc = nla_parse(tb, DOC_EXMPL_A_MAX,
                info-&gt;userhdr + sizeof(struct family_hdr),
                info-&gt;nlhdr-&gt;nlmsg_len - ((u64)info-&gt;userhdr - (u64)info-&gt;nlhdr) - sizeof(struct family_hdr),
                NULL);
        if (rc) {
            printk("nla_parse err\n");
            return -1;
        }

        for (i = 1; i &lt;= DOC_EXMPL_A_MAX; i ++) {
            if (!tb[i])
                continue;
            rcvlen = nla_len(tb[i]);
            hdr = (struct data_hdr*)nla_data(tb[i]);
            printk("ker-rcv: %d %d %d %d rcvlen=%d %s\n", i, fhdr-&gt;ff, hdr-&gt;len, hdr-&gt;kk, rcvlen, hdr-&gt;str);
        }
        return 0;
    }


    static int snd_handler(struct genl_info *info)
    {
        struct sk_buff *reply = NULL;
        char sss[123];
        struct family_hdr *snd_fhdr;
        struct data_hdr *snd_hdr = (struct data_hdr *)sss;
        int err;

        reply = genlmsg_new(NLMSG_ALIGN(sizeof(struct family_hdr)) + NLMSG_ALIGN(sizeof(struct data_hdr)) + nla_total_size(strlen(MSG_KER)), GFP_KERNEL);
        if (!reply) {
            printk("genlmsg_new err\n");
            return -1;
        }

        snd_fhdr = (struct family_hdr *)genlmsg_put(reply, info-&gt;snd_portid, info-&gt;snd_seq, &amp;nl_family, 0, DOC_EXMPL_C_ECHO);
        snd_fhdr-&gt;ff = 222;
        snd_hdr-&gt;len = 321;
        snd_hdr-&gt;kk = 654;
        strcpy(snd_hdr-&gt;str, MSG_KER);
        err = nla_put(reply, DOC_EXMPL_A_MSG, sizeof(struct data_hdr) + strlen(snd_hdr-&gt;str), snd_hdr);
        if (err) {
            printk("nla_put err\n");
            genlmsg_cancel(reply, snd_fhdr);
            return -2;
        }

        snd_hdr-&gt;len = 987;
        snd_hdr-&gt;kk = 789;
        err = nla_put(reply, DOC_EXMPL_A_MSG2, sizeof(struct data_hdr) + strlen(snd_hdr-&gt;str), snd_hdr);
        if (err) {
            printk("nla_put err2\n");
            genlmsg_cancel(reply, snd_fhdr);
            return -2;
        }

        genlmsg_end(reply, snd_fhdr);

        err = genlmsg_reply(reply, info);
        if (err)
            printk("genlmsg_reply err\n");

        return 0;
    }

    static int nl_echo(struct sk_buff *skb, struct genl_info *info)
    {
        rcv_handler(info);
        snd_handler(info);
        return 0;
    }

    static struct genl_ops nl_ops[] = {
        {
            .cmd    = DOC_EXMPL_C_ECHO,
            .doit   = nl_echo,
            .flags  = GENL_ADMIN_PERM,
        },
    };

    int genetlink_init(void)
    {
        return genl_register_family_with_ops(&amp;nl_family, nl_ops, ARRAY_SIZE(nl_ops));
    }

    void genetlink_exit(void)
    {
        genl_unregister_family(&amp;nl_family);
        printk("Generic Netlink_nl Example Module unloaded.\n");
    }

    module_init(genetlink_init);
    module_exit(genetlink_exit);
    MODULE_LICENSE("GPL");
</code></pre>

<pre><code>    obj-m += genlink_nl.o

    KDIR := /usr/src/kernels/`uname -r`/

    PWD := `pwd`

    default:
        make -C $(KDIR) M=$(PWD) modules

    clean:
        rm -rf *.ko *.o *.mod.c .*.cmd .tmp_versions Module.symvers modules.order
</code></pre>

<h3>user</h3>

<p>gcc user_nl.c -lnl</p>

<pre><code>    // gcc user_nl.c -lnl
    //
    #include &lt;stdio.h&gt;
    #include &lt;stdlib.h&gt;
    #include &lt;errno.h&gt;
    #include &lt;unistd.h&gt;
    #include &lt;poll.h&gt;
    #include &lt;string.h&gt;
    #include &lt;fcntl.h&gt;
    #include &lt;sys/types.h&gt;
    #include &lt;sys/stat.h&gt;
    #include &lt;sys/socket.h&gt;
    #include &lt;sys/types.h&gt;
    #include &lt;signal.h&gt;
    #include &lt;asm/types.h&gt;

    //#include &lt;linux/genetlink.h&gt;
    #include &lt;netlink/socket.h&gt;
    #include &lt;netlink/genl/genl.h&gt;
    #include &lt;netlink/genl/family.h&gt;
    #include &lt;netlink/genl/ctrl.h&gt;
    #include &lt;netlink/msg.h&gt;

    #define MESSAGE_TO_KERNEL   "Hello World from user space!!"

    struct family_hdr {
        int ff;
    };

    struct data_hdr {
        int len;
        int kk;
        char str[0];
    };

    /* netlink attributes */
    enum {
        DOC_EXMPL_A_UNSPEC,
        DOC_EXMPL_A_MSG,
        DOC_EXMPL_A_MSG2,
        __DOC_EXMPL_A_MAX,
    };
    #define DOC_EXMPL_A_MAX (__DOC_EXMPL_A_MAX - 1)

    //copy from kernel driver genl_ops's cmd
    enum {
        DOC_EXMPL_C_UNSPEC,
        DOC_EXMPL_C_ECHO,
        __DOC_EXMPL_C_MAX,
    };
    #define DOC_EXMPL_C_MAX (__DOC_EXMPL_C_MAX - 1)

    static int error_handler(struct sockaddr_nl *nla, struct nlmsgerr *err, void *arg)
    {
        int *ret = arg;
        fprintf(stderr, "error\n");
        *ret = err-&gt;error;
        return NL_STOP;
    }

    static int finish_handler(struct nl_msg *msg, void *arg)
    {
        int *ret = arg;
        *ret = 0;
        fprintf(stderr, "finish\n");
        return NL_SKIP;
    }

    static int ack_handler(struct nl_msg *msg, void *arg)
    {
        int *ret = arg;
        *ret = 0;
        fprintf(stderr, "ack\n");
        return NL_STOP;
    }

    static int reply_handler(struct nl_msg *msg, void *arg)
    {
        struct nlattr *tb[DOC_EXMPL_A_MAX + 1] = {0};
        struct genlmsghdr *gnlh = nlmsg_data(nlmsg_hdr(msg));
        struct family_hdr *fhdr = genlmsg_attrdata(gnlh, 0);
        struct data_hdr *hdr;
        int rc, i;
        int rcvlen;

        rc = nla_parse(tb, DOC_EXMPL_A_MAX,
                genlmsg_attrdata(gnlh, sizeof(struct family_hdr)),
                genlmsg_attrlen(gnlh, sizeof(struct family_hdr)), NULL);
        if (rc) {
            printf("nla_parse err\n");
            return NL_STOP;
        }

        for (i = 1; i &lt;= DOC_EXMPL_A_MAX; i ++) {
            rcvlen = nla_len(tb[i]);
            hdr = (struct data_hdr*)nla_data(tb[i]);
            printf("rcv: %d %d %d %d rcvlen=%d %s\n", i, fhdr-&gt;ff, hdr-&gt;len, hdr-&gt;kk, rcvlen, hdr-&gt;str);
        }
        return NL_OK;
    }

    static int test_genlink_nl(void)
    {
        struct nl_handle *nlsk;
        int nlid, err, ret;

        struct nl_msg *msg = NULL;
        struct nl_cb *cb = NULL;

        char cbdata[123], sss[123];
        struct family_hdr *fhdr;
        struct data_hdr *hdr = (struct data_hdr *)sss;

        nlsk = nl_handle_alloc();
        if (!nlsk) {
            printf("nl_socket_alloc err\n");
            return -1;
        }

        nl_set_buffer_size(nlsk, 8192, 8192);

        if (genl_connect(nlsk)) {
            printf("genl_connect err\n");
            goto free_nlsk;
        }

        nlid = genl_ctrl_resolve(nlsk, "DOC_EXMPL");
        if (nlid &lt; 0) {
            printf("genl_ctrl_resolve err\n");
            goto free_nlsk;
        }

        msg = nlmsg_alloc();
        if (!msg) {
            printf("nlmsg_alloc err\n");
            goto free_nlsk;
        }

        cb = nl_cb_alloc(NL_CB_DEFAULT);
        if (!cb) {
            printf("nl_cb_alloc err\n");
            goto free_msg;
        }
        nl_socket_set_cb(nlsk, cb);

        fhdr = (struct family_hdr *)genlmsg_put(msg, 0, 0, nlid, sizeof(struct family_hdr), 0, DOC_EXMPL_C_ECHO, 0);
        if (!fhdr) {
            printf("genlmsg_put err\n");
            goto free_cb;
        }
        fhdr-&gt;ff = 111;

        hdr-&gt;len = 123;
        hdr-&gt;kk = 456;
        strcpy(hdr-&gt;str, MESSAGE_TO_KERNEL);
        ret = nla_put(msg, DOC_EXMPL_A_MSG, sizeof(struct data_hdr)+strlen(MESSAGE_TO_KERNEL), hdr);
        if (ret &lt; 0) {
            printf("nla_put err\n");
            goto free_cb;
        }

        hdr-&gt;len = 700;
        hdr-&gt;kk = 800;
        ret = nla_put(msg, DOC_EXMPL_A_MSG2, sizeof(struct data_hdr)+strlen(MESSAGE_TO_KERNEL), hdr);
        if (ret &lt; 0) {
            printf("nla_put err2\n");
            goto free_cb;
        }

        ret = nl_send_auto_complete(nlsk, msg);
        if (ret &lt; 0) {
            printf("nl_send_auto_complete err\n");
            goto free_cb;
        }

        err = 1;
        nl_cb_err(cb, NL_CB_CUSTOM, error_handler, &amp;err);
        nl_cb_set(cb, NL_CB_FINISH, NL_CB_CUSTOM, finish_handler, &amp;err);
        nl_cb_set(cb, NL_CB_ACK, NL_CB_CUSTOM, ack_handler, &amp;err);
        nl_cb_set(cb, NL_CB_VALID, NL_CB_CUSTOM, reply_handler, &amp;cbdata);

        ret = nl_recvmsgs(nlsk, cb);
        if (ret) {
            printf("nl_recvmsgs err\n");
        }

        return err;

    free_cb:
        nl_cb_put(cb);
    free_msg:
        nlmsg_free(msg);
    free_nlsk:
        nl_handle_destroy(nlsk);
        return -2;
    }

    int main(int argc, char *argv[])
    {
        return test_genlink_nl();
    }
</code></pre>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[数据交换 genlink]]></title>
    <link href="http://abcdxyzk.github.io/blog/2020/08/10/kernel-genlink/"/>
    <updated>2020-08-10T23:09:00+08:00</updated>
    <id>http://abcdxyzk.github.io/blog/2020/08/10/kernel-genlink</id>
    <content type="html"><![CDATA[<p>3.x 内核</p>

<h3>kernel</h3>

<pre><code>    #include &lt;linux/module.h&gt;
    #include &lt;net/netlink.h&gt;
    #include &lt;net/genetlink.h&gt;
    #include &lt;linux/version.h&gt;

    #define TEST_GENL_MSG_FROM_KERNEL   "Hello from kernel space!!!"

    /* handler 
     * message handling code goes here; return 0 on success, negative 
     * values on failure 
     */  
    static int doc_exmpl_echo(struct sk_buff *skb, struct genl_info *info);

    /* netlink attributes */
    enum {
        DOC_EXMPL_A_UNSPEC,
        DOC_EXMPL_A_MSG,
        __DOC_EXMPL_A_MAX,
    };
    #define DOC_EXMPL_A_MAX (__DOC_EXMPL_A_MAX - 1)

    /* attribute policy */
    static struct nla_policy doc_exmpl_genl_policy[DOC_EXMPL_A_MAX + 1] = {
        [DOC_EXMPL_A_MSG] = { .type = NLA_NUL_STRING },
    };

    /* commands 定义命令类型，用户空间以此来表明需要执行的命令 */
    enum {
        DOC_EXMPL_C_UNSPEC,
        DOC_EXMPL_C_ECHO,
        __DOC_EXMPL_C_MAX,
    };
    #define DOC_EXMPL_C_MAX (__DOC_EXMPL_C_MAX - 1)

    /* family definition */
    static struct genl_family doc_exmpl_genl_family = {
        .id = GENL_ID_GENERATE,   //这里不指定family ID，由内核进行分配
        .hdrsize = 0,             //自定义的头部长度，参考genl数据包结构
        .name = "DOC_EXMPL",      //这里定义family的名称，user program需要根据这个名字来找到对应的family ID。
        .version = 1,
        .maxattr = DOC_EXMPL_A_MAX,
    };

    /* operation definition 将命令command echo和具体的handler对应起来 */
    static struct genl_ops doc_exmpl_genl_ops_echo = {
        .cmd = DOC_EXMPL_C_ECHO,
        .flags = 0,
        .policy = doc_exmpl_genl_policy,
        .doit = doc_exmpl_echo,
        .dumpit = NULL,
    };

    static struct genl_multicast_group doc_exmpl_genl_mcgrp = {
        .name = "DOC_EXMPL_GRP",
    };

    static inline int genl_msg_prepare_usr_msg(u8 cmd, size_t size, pid_t pid, struct sk_buff **skbp)
    {
        struct sk_buff *skb;

        /* create a new netlink msg */
        skb = genlmsg_new(size, GFP_KERNEL);
        if (skb == NULL) {
            return -ENOMEM;
        }

        /* Add a new netlink message to an skb */
        genlmsg_put(skb, pid, 0, &amp;doc_exmpl_genl_family, 0, cmd);

        *skbp = skb;
        return 0;
    }

    static inline int genl_msg_mk_usr_msg(struct sk_buff *skb, int type, void *data, int len)
    {
        int rc;

        /* add a netlink attribute to a socket buffer */
        if ((rc = nla_put(skb, type, len, data)) != 0) {
            return rc;
        }
        return 0;
    }

    /**
    * genl_msg_send_to_user - 通过generic netlink发送数据到netlink
    *
    * @data: 发送数据缓存
    * @len:  数据长度 单位：byte
    * @pid:  发送到的客户端pid
    *
    * return:
    *  0: 成功
    * -1: 失败
    */
    int genl_msg_send_to_user(void *data, int len, pid_t pid)
    {
        struct sk_buff *skb;
        size_t size;
        void *head;
        int rc;

        size = nla_total_size(len); /* total length of attribute including padding */

        rc = genl_msg_prepare_usr_msg(DOC_EXMPL_C_ECHO, size, pid, &amp;skb);
        if (rc) {
            return rc;
        }

        rc = genl_msg_mk_usr_msg(skb, DOC_EXMPL_A_MSG, data, len);
        if (rc) {
            kfree_skb(skb);
            return rc;
        }

        head = genlmsg_data(nlmsg_data(nlmsg_hdr(skb)));

        rc = genlmsg_end(skb, head);
        if (rc &lt; 0) {
            kfree_skb(skb);
            return rc;
        }

        rc = genlmsg_unicast(&amp;init_net, skb, pid);
        if (rc &lt; 0) {
            return rc;
        }

        return 0;
    }

    //echo command handler, 命令处理函数，当接收到user program发出的命令后，这个函数会被内核调用
    static int doc_exmpl_echo(struct sk_buff *skb, struct genl_info *info)
    {
        /* message handling code goes here; return 0 on success, negative values on failure */
        struct nlmsghdr *nlhdr;
        struct genlmsghdr *genlhdr;
        struct nlattr *nlh;
        char *str;
        int ret;

        nlhdr = nlmsg_hdr(skb);
        genlhdr = nlmsg_data(nlhdr);
        nlh = genlmsg_data(genlhdr);
        str = nla_data(nlh);
        printk("doc_exmpl_echo get: nla_len=%d, nla_type=%d, %s\n", nlh-&gt;nla_len, nlh-&gt;nla_type, str);

        ret = genl_msg_send_to_user(TEST_GENL_MSG_FROM_KERNEL,
                strlen(TEST_GENL_MSG_FROM_KERNEL) + 1,  nlhdr-&gt;nlmsg_pid);

        return ret;
    }

    int genetlink_init(void)
    {
        int rc;

        /**
         * 1. Registering A Family
         * This function doesn't exist past linux 3.12
         */
        rc = genl_register_family(&amp;doc_exmpl_genl_family);
        if (rc != 0)
            goto err_out1;

        rc = genl_register_ops(&amp;doc_exmpl_genl_family, &amp;doc_exmpl_genl_ops_echo);
        if (rc != 0)
            goto err_out2;

        /*
         * for multicast
         */
        rc = genl_register_mc_group(&amp;doc_exmpl_genl_family, &amp;doc_exmpl_genl_mcgrp);
        if (rc != 0)
            goto err_out3;

        printk("doc_exmpl_genl_mcgrp.id=%d", doc_exmpl_genl_mcgrp.id);
        printk("genetlink_init OK");
        return 0;

    err_out3:
        genl_unregister_ops(&amp;doc_exmpl_genl_family, &amp;doc_exmpl_genl_ops_echo);
    err_out2:
        genl_unregister_family(&amp;doc_exmpl_genl_family);
    err_out1:
        printk("Error occured while inserting generic netlink example module\n");
        return rc;
    }

    void genetlink_exit(void)
    {
        printk("Generic Netlink Example Module unloaded.");

        genl_unregister_mc_group(&amp;doc_exmpl_genl_family, &amp;doc_exmpl_genl_mcgrp);
        genl_unregister_ops(&amp;doc_exmpl_genl_family, &amp;doc_exmpl_genl_ops_echo);
        genl_unregister_family(&amp;doc_exmpl_genl_family);
    }

    module_init(genetlink_init);
    module_exit(genetlink_exit);
    MODULE_LICENSE("GPL");
</code></pre>

<pre><code>    obj-m += genlink.o

    KDIR := /usr/src/kernels/`uname -r`/

    PWD := `pwd`

    default:
        make -C $(KDIR) M=$(PWD) modules

    clean:
        rm -rf *.ko *.o *.mod.c .*.cmd .tmp_versions Module.symvers modules.order
</code></pre>

<h3>user</h3>

<pre><code>    #include &lt;stdio.h&gt;
    #include &lt;stdlib.h&gt;
    #include &lt;errno.h&gt;
    #include &lt;unistd.h&gt;
    #include &lt;poll.h&gt;
    #include &lt;string.h&gt;
    #include &lt;fcntl.h&gt;
    #include &lt;sys/types.h&gt;
    #include &lt;sys/stat.h&gt;
    #include &lt;sys/socket.h&gt;
    #include &lt;sys/types.h&gt;
    #include &lt;signal.h&gt;

    #include &lt;linux/genetlink.h&gt;

    #define GENLMSG_DATA(glh)   ((void*)(((char*)glh) + GENL_HDRLEN))
    #define NLA_DATA(nla)       ((void *)((char*)(nla) + NLA_HDRLEN))
    #define NLA_NEXT(nla,len)   ((len) -= NLA_ALIGN((nla)-&gt;nla_len), \
                    (struct nlattr*)(((char*)(nla)) + NLA_ALIGN((nla)-&gt;nla_len)))
    #define NLA_OK(nla,len)     ((len) &gt;= (int)sizeof(struct nlattr) &amp;&amp; \
                    (nla)-&gt;nla_len &gt;= sizeof(struct nlattr) &amp;&amp; \
                    (nla)-&gt;nla_len &lt;= (len))

    //copy from kernel driver genl_ops's cmd
    enum {
        DOC_EXMPL_C_UNSPEC,
        DOC_EXMPL_C_ECHO,
        __DOC_EXMPL_C_MAX,
    };

    //copy from kernel driver netlink attribute
    enum {
        DOC_EXMPL_A_UNSPEC,
        DOC_EXMPL_A_MSG,
        __DOC_EXMPL_A_MAX,
    };

    #define MESSAGE_TO_KERNEL   "Hello World from user space!"


    /**
     * nla_attr_size - length of attribute size, NOT including padding
     * @param payload   length of payload
     * @return
     */
    static inline int nla_attr_size(int payload)
    {
        return NLA_HDRLEN + payload;
    }

    /**
     * nla_total_size - total length of attribute including padding
     * @param payload   length of payload, NOT including NLA_HDR
     */
    static inline int nla_total_size(int payload)
    {
        return NLA_ALIGN(nla_attr_size(payload));
    }

    static int genlmsg_open(void)
    {
        int sockfd;
        struct sockaddr_nl nladdr;
        int ret;

        sockfd = socket(AF_NETLINK, SOCK_RAW, NETLINK_GENERIC);
        if (sockfd &lt; 0) {
            printf("socket: %m\n");
            return -1;
        }

        memset(&amp;nladdr, 0, sizeof(nladdr));
        nladdr.nl_family = AF_NETLINK;
        nladdr.nl_pid = getpid();
        nladdr.nl_groups = 0xffffffff; //这个是mask值，如果family ID &amp; nl_groups为0，
                   //则这个family的广播就接收不到，所以这里设为0xffffffff就可以接收所有的family消息

        ret = bind(sockfd, (struct sockaddr *)&amp;nladdr, sizeof(nladdr));
        if (ret &lt; 0) {
            printf("bind: %m\n");
            ret = -1;
            goto err_out;
        }
        return sockfd;

    err_out:
        close(sockfd);
        return ret;
    }

    static void *genlmsg_alloc(int *size)
    {
        unsigned char *buf;
        int len;

        /*
         * attribute len
         * attr len = (nla_hdr + pad) + (payload(user data) + pad)
         */
        len = nla_total_size(*size);
        /*
         * family msg len,
         * but actually we have NOT custom family header
         * family msg len = family_hdr + payload(attribute)
         */
        len += 0;
        /*
         * generic netlink msg len
         * genlmsg len = (genlhdr + pad) + payload(family msg)
         */
        len += GENL_HDRLEN;
        /*
         * netlink msg len
         * nlmsg len = (nlmsghdr + pad) + (payload(genlmsg) + pad)
         */
        len = NLMSG_SPACE(len);

        buf = malloc(len);
        if (!buf)
            return NULL;

        memset(buf, 0, len);
        *size = len;
        return buf;
    }

    static void genlmsg_free(void *buf)
    {
        if (buf)
            free(buf);
    }

    static int genlmsg_send(int sockfd, unsigned short nlmsg_type, unsigned int nlmsg_pid,
            unsigned char genl_cmd, unsigned char genl_version,
            unsigned short nla_type, const void *nla_data, unsigned int nla_len)
    {
        struct nlmsghdr *nlh;      //netlink message header
        struct genlmsghdr *glh;    //generic netlink message header
        struct nlattr *nla;    //netlink attribute header
        struct sockaddr_nl nladdr;
        unsigned char *buf;
        int len;
        int count;
        int ret;

        if ((nlmsg_type == 0) || (!nla_data) || (nla_len &lt;= 0))
            return -1;

        len = nla_len;
        buf = genlmsg_alloc(&amp;len);
        if (!buf)
            return -1;

        nlh = (struct nlmsghdr *)buf;
        nlh-&gt;nlmsg_len = len;
        nlh-&gt;nlmsg_type = nlmsg_type;
        nlh-&gt;nlmsg_flags = NLM_F_REQUEST;
        nlh-&gt;nlmsg_seq = 0;
        nlh-&gt;nlmsg_pid = nlmsg_pid;

        glh = (struct genlmsghdr *)NLMSG_DATA(nlh);
        glh-&gt;cmd = genl_cmd;
        glh-&gt;version = genl_version;


        nla = (struct nlattr *)GENLMSG_DATA(glh);
        nla-&gt;nla_type = nla_type;
        nla-&gt;nla_len = nla_attr_size(nla_len);
        memcpy(NLA_DATA(nla), nla_data, nla_len);

        memset(&amp;nladdr, 0, sizeof(nladdr));
        nladdr.nl_family = AF_NETLINK;

        count = 0;
        ret = 0;
        do {
            ret = sendto(sockfd, &amp;buf[count], len - count, 0,
                (struct sockaddr *)&amp;nladdr, sizeof(nladdr));
            if (ret &lt; 0) {
                if (errno != EAGAIN) {
                    count = -1;
                    goto out;
                }
            } else {
                count += ret;
            }
        } while (count &lt; len);

    out:
        genlmsg_free(buf);

        printf("send len %d\n", count);
        return count;
    }

    /**
     *
     * @param sockfd    generic netlink socket fd
     * @param buf      the 'buf' is including the struct nlmsghdr,
     *                struct genlmsghdr and struct nlattr
     * @param len      size of 'buf'
     * @return  &gt;0    size of genlmsg
     *        &lt;0      error occur
     */
    static int genlmsg_recv(int sockfd, unsigned char *buf, unsigned int len)
    {
        struct sockaddr_nl nladdr;
        struct msghdr msg;
        struct iovec iov;
        int ret;

        nladdr.nl_family = AF_NETLINK;
        nladdr.nl_pid = getpid();
        nladdr.nl_groups = 0xffffffff;

        iov.iov_base = buf;
        iov.iov_len = len;

        msg.msg_name = (void *)&amp;nladdr;
        msg.msg_namelen = sizeof(nladdr);
        msg.msg_iov = &amp;iov;
        msg.msg_iovlen = 1;
        msg.msg_control = NULL;
        msg.msg_controllen = 0;
        msg.msg_flags = 0;
        ret = recvmsg(sockfd, &amp;msg, 0);
        ret = ret &gt; 0 ? ret : -1;
        printf("recv len %d\n", ret);
        return ret;
    }

    static int genlmsg_dispatch(struct nlmsghdr *nlmsghdr, unsigned int nlh_len,
                int nlmsg_type, int nla_type, unsigned char *buf, int *len)
    {
        struct nlmsghdr *nlh;
        struct genlmsghdr *glh;
        struct nlattr *nla;
        int nla_len;

        int l;
        int i;
        int ret = -1;

        if (!nlmsghdr || !buf || !len)
            return -1;

        printf("nlmsg_type = %d\n", nlmsghdr-&gt;nlmsg_type);
        if (nlmsg_type &amp;&amp; (nlmsghdr-&gt;nlmsg_type != nlmsg_type))
            return -1;

        //读取到的数据流里面，可能会包含多条nlmsg
        for (nlh = nlmsghdr; NLMSG_OK(nlh, nlh_len); nlh = NLMSG_NEXT(nlh, nlh_len))
        {
            /* The end of multipart message. */
            if (nlh-&gt;nlmsg_type == NLMSG_DONE) {
                printf("get NLMSG_DONE\n");
                ret = 0;
                break;
            }

            if (nlh-&gt;nlmsg_type == NLMSG_ERROR) {
                printf("get NLMSG_ERROR\n");
                ret = -1;
                break;
            }

            glh = (struct genlmsghdr *)NLMSG_DATA(nlh);
            nla = (struct nlattr *)GENLMSG_DATA(glh);   //the first attribute
            nla_len = nlh-&gt;nlmsg_len - GENL_HDRLEN;        //len of attributes
            for (i = 0; NLA_OK(nla, nla_len); nla = NLA_NEXT(nla, nla_len), ++i) {
                //一条nlmsg里面，可能会包含多个attr
                printf("%d. nla-&gt;nla_type = %d\n", i, nla-&gt;nla_type);
                /* Match the family ID, copy the data to user */
                if (nla_type == nla-&gt;nla_type) {
                    l = nla-&gt;nla_len - NLA_HDRLEN;  //attribute里的payload就是内核返回给用户的实际数据
                    *len = *len &gt; l ? l : *len;
                    memcpy(buf, NLA_DATA(nla), *len);
                    ret = 0;
                    break;
                }
            }
        }
        return ret;
    }

    static int genlmsg_get_family_id(int sockfd, const char *family_name)
    {
        void *buf;
        int len;
        __u16 id;
        int l;
        int ret;

        ret = genlmsg_send(sockfd, GENL_ID_CTRL, 0, CTRL_CMD_GETFAMILY, 1,
                CTRL_ATTR_FAMILY_NAME, family_name, strlen(family_name) + 1);
        if (ret &lt; 0)
            return -1;

        len = 256;
        buf = genlmsg_alloc(&amp;len);
        if (!buf)
            return -1;

        len = genlmsg_recv(sockfd, buf, len);
        if (len &lt; 0)
            return len;

        id = 0;
        l = sizeof(id);
        genlmsg_dispatch((struct nlmsghdr *)buf, len, 0, CTRL_ATTR_FAMILY_ID, (unsigned char *)&amp;id, &amp;l);
        genlmsg_free(buf);

        return id &gt; 0 ? id : -1;
    }


    #define BUF_SIZE    256
    static int test_netlink_unicast(void)
    {
        struct nlmsghdr *nlh = NULL;
        int sockfd = -1;
        unsigned char buf[BUF_SIZE];
        int len;
        int id;
        pid_t pid;
        int ret;

        len = BUF_SIZE;
        nlh = genlmsg_alloc(&amp;len);
        if (!nlh)
            return -1;

        sockfd = genlmsg_open();
        if (sockfd &lt; 0)
            return -1;

        id = genlmsg_get_family_id(sockfd, "DOC_EXMPL");  //这里必须先通过family的名字获取到family ID，名字需要与驱动里的一致
        printf("get family ID[%d]\n", id);
        if (id &lt;= 0) {
            ret = -1;
            goto out;
        }

        pid = getpid();
        ret = genlmsg_send(sockfd, id, pid, DOC_EXMPL_C_ECHO, 1,
                DOC_EXMPL_A_MSG, MESSAGE_TO_KERNEL, strlen(MESSAGE_TO_KERNEL) + 1); //向内核发送genl消息
        if (ret &lt; 0)
            goto out;

        ret = genlmsg_recv(sockfd, (unsigned char *)nlh, len); //等待内核的回复
        if (ret &gt; 0) {
            memset(buf, 0, sizeof(buf));
            len = sizeof(buf);
            ret = genlmsg_dispatch(nlh, ret, id, DOC_EXMPL_A_MSG, buf, &amp;len);
            if (ret == 0) {
                printf("get: %s\n", buf);
            }
        }

    out:
        close(sockfd);
        genlmsg_free(nlh);
        return ret;
    }

    int main(int argc, char *argv[])
    {
        test_netlink_unicast();
        return 0;
    }
</code></pre>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[数据交换 netlink]]></title>
    <link href="http://abcdxyzk.github.io/blog/2020/08/10/kernel-netlink/"/>
    <updated>2020-08-10T23:02:00+08:00</updated>
    <id>http://abcdxyzk.github.io/blog/2020/08/10/kernel-netlink</id>
    <content type="html"><![CDATA[<p>3.x 内核</p>

<h3>kernel</h3>

<pre><code>    #include &lt;linux/kernel.h&gt;
    #include &lt;linux/module.h&gt;
    #include &lt;linux/types.h&gt;
    #include &lt;linux/sched.h&gt;
    #include &lt;net/sock.h&gt;
    #include &lt;net/netlink.h&gt;

    #define NETLINK_TEST 29

    struct sock *nl_sk = NULL;

    void nl_data_ready(struct sk_buff *__skb)
    {
        struct sk_buff *skb;
        struct nlmsghdr *nlh;
        u32 pid;
        int rc;
        int len = NLMSG_SPACE(1200);
        char str[100];

        printk("net_link: data is ready to read.\n");
        skb = skb_get(__skb);

        if (skb-&gt;len &gt;= NLMSG_SPACE(0)) {
            nlh = nlmsg_hdr(skb);
            printk("net_link: recv %s.\n", (char *)NLMSG_DATA(nlh));
            memcpy(str, NLMSG_DATA(nlh), sizeof(str));
            pid = nlh-&gt;nlmsg_pid; /*pid of sending process */
            printk("net_link: pid is %d\n", pid);
            kfree_skb(skb);

            skb = alloc_skb(len, GFP_ATOMIC);
            if (!skb) {
                printk(KERN_ERR "net_link: allocate failed.\n");
                return;
            }
            nlh = nlmsg_put(skb, 0, 0, 0, 1200, 0);
            NETLINK_CB(skb).portid = 0; /* from kernel */

            memcpy(NLMSG_DATA(nlh), str, sizeof(str));
            strcpy(NLMSG_DATA(nlh) + 10, " from kernel");
            printk("net_link: going to send.\n");
            rc = netlink_unicast(nl_sk, skb, pid, MSG_DONTWAIT);
            if (rc &lt; 0) {
                printk(KERN_ERR "net_link: can not unicast skb (%d)\n", rc);
            }
            printk("net_link: send is ok.\n");
        }
        return;
    }

    static int test_netlink(void)
    {
        struct netlink_kernel_cfg cfg = {
            .groups     = 0,
            .input      = nl_data_ready,
            .cb_mutex   = NULL,
            .flags      = 0,
            .bind       = NULL,
        };
        nl_sk = netlink_kernel_create(&amp;init_net, NETLINK_TEST, &amp;cfg);

        if (!nl_sk) {
            printk(KERN_ERR "net_link: Cannot create netlink socket.\n");
            return -EIO;
        }
        printk("net_link: create socket ok.\n");
        return 0;
    }

    int netlink_init(void)
    {
        test_netlink();
        return 0;
    }

    void netlink_exit(void)
    {
        if (nl_sk != NULL) {
            sock_release(nl_sk-&gt;sk_socket);
        }
        printk("net_link: remove ok.\n");
    }

    module_init(netlink_init);
    module_exit(netlink_exit);
    MODULE_LICENSE("GPL");
</code></pre>

<pre><code>    obj-m += netlink.o

    KDIR := /usr/src/kernels/`uname -r`/

    PWD := `pwd`

    default:
        make -C $(KDIR) M=$(PWD) modules

    clean:
        rm -rf *.ko *.o *.mod.c .*.cmd .tmp_versions Module.symvers modules.order
</code></pre>

<h3>user</h3>

<pre><code>    #include &lt;sys/stat.h&gt;
    #include &lt;unistd.h&gt;
    #include &lt;stdio.h&gt;
    #include &lt;stdlib.h&gt;
    #include &lt;sys/socket.h&gt;
    #include &lt;sys/types.h&gt;
    #include &lt;string.h&gt;
    #include &lt;asm/types.h&gt;
    #include &lt;linux/netlink.h&gt;
    #include &lt;linux/socket.h&gt;

    #define NETLINK_TEST 29

    #define MAX_PAYLOAD 1024 

    struct sockaddr_nl src_addr, dest_addr;
    struct nlmsghdr *nlh = NULL;
    struct iovec iov;
    int sock_fd;
    struct msghdr msg;

    int main(int argc, char* argv[])
    {
        sock_fd = socket(PF_NETLINK, SOCK_RAW, NETLINK_TEST);

        memset(&amp;msg, 0, sizeof(msg));
        memset(&amp;src_addr, 0, sizeof(src_addr));
        src_addr.nl_family = AF_NETLINK;
        src_addr.nl_pid = getpid(); 
        src_addr.nl_groups = 0; 
        bind(sock_fd, (struct sockaddr*)&amp;src_addr, sizeof(src_addr));

        memset(&amp;dest_addr, 0, sizeof(dest_addr));
        dest_addr.nl_family = AF_NETLINK;
        dest_addr.nl_pid = 0; 
        dest_addr.nl_groups = 0; 

        nlh = (struct nlmsghdr *)malloc(NLMSG_SPACE(MAX_PAYLOAD));
        nlh-&gt;nlmsg_len = NLMSG_SPACE(MAX_PAYLOAD);
        nlh-&gt;nlmsg_pid = getpid(); 
        nlh-&gt;nlmsg_flags = 0;
        strcpy(NLMSG_DATA(nlh), "Hello you!");

        iov.iov_base = (void *)nlh;
        iov.iov_len = nlh-&gt;nlmsg_len;
        msg.msg_name = (void *)&amp;dest_addr;
        msg.msg_namelen = sizeof(dest_addr);
        msg.msg_iov = &amp;iov;
        msg.msg_iovlen = 1;

        printf(" Sending message. ...\n");
        sendmsg(sock_fd, &amp;msg, 0);

        memset(nlh, 0, NLMSG_SPACE(MAX_PAYLOAD));
        printf(" Waiting message. ...\n");
        recvmsg(sock_fd, &amp;msg, 0);
        printf(" Received message payload: len=%d, data=%s\n", nlh-&gt;nlmsg_len, NLMSG_DATA(nlh));

        close(sock_fd);
        return 0;
    }
</code></pre>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[nf_socket]]></title>
    <link href="http://abcdxyzk.github.io/blog/2018/06/12/kernel-nf_socket/"/>
    <updated>2018-06-12T02:04:00+08:00</updated>
    <id>http://abcdxyzk.github.io/blog/2018/06/12/kernel-nf_socket</id>
    <content type="html"><![CDATA[<p><a href="https://blog.csdn.net/jk110333/article/details/8642261">https://blog.csdn.net/jk110333/article/details/8642261</a></p>

<p>用户态与内核态交互通信的方法不止一种，sockopt是比较方便的一个，写法也简单. ipvsadm的两种通信方式之一</p>

<p>缺点就是使用 copy_from_user()/copy_to_user()完成内核和用户的通信， 效率其实不高， 多用在传递控制 选项 信息，不适合做大量的数据传输</p>

<h4>用户态函数：</h4>

<p>发送：int setsockopt( int sockfd, int proto, int cmd, void *data, int datelen);</p>

<p>接收：int getsockopt(int sockfd, int proto, int cmd, void *data, int datalen);</p>

<p>第一个参数是socket描述符；</p>

<p>第二个参数proto是sock协议，IP RAW的就用SOL_SOCKET/SOL_IP等，TCP/UDP socket的可用SOL_SOCKET/SOL_IP/SOL_TCP/SOL_UDP等，即高层的socket是都可以使用低层socket的命令字 的，IPPROTO_IP；</p>

<p>第三个参数cmd是操作命令字，由自己定义；</p>

<p>第四个参数是数据缓冲区起始位置指针，set操作时是将缓冲区数据写入内核，get的时候是将内核中的数 据读入该缓冲区；</p>

<p>第五个参数数据长度</p>

<h4>内核态函数</h4>

<p>注册：nf_register_sockopt(struct nf_sockopt_ops *sockops);</p>

<p>注销：nf_unregister_sockopt(struct nf_sockopt_ops *sockops);</p>

<p>结构体 nf_sockopt_ops test_sockops
<code>
    static struct nf_sockopt_ops nso = {
        .pf  = PF_INET,     // 协议族
        .set_optmin = 常数,   // 定义最小set命令字
        .set_optmax = 常数+N, // 定义最大set命令字
        .set  = recv_msg,   // 定义set处理函数
        .get_optmin = 常数,   // 定义最小get命令字
        .get_optmax = 常数+N, // 定义最大get命令字
        .get  = send_msg,   // 定义set处理函数
    };
</code></p>

<p>其中命令字不能和内核已有的重复，宜大不宜小。命令字很重要，是用来做标识符的。而且用户态和内核态要定义的相同，
<code>
    #define SOCKET_OPS_BASE     128
    #define SOCKET_OPS_SET      (SOCKET_OPS_BASE)
    #define SOCKET_OPS_GET      (SOCKET_OPS_BASE)
    #define SOCKET_OPS_MAX      (SOCKET_OPS_BASE + 1)
</code></p>

<p>set/get处理函数是直接由用户空间的 set/getsockopt函数调用的。 setsockopt函数向内核写数据，用getsockopt向内核读数据。
另外set和get的处理函数的参数应该是这样的</p>

<pre><code>    int recv_msg(struct sock *sk, int cmd, void __user *user, unsigned int len);
    int send_msg(struct sock *sk, int cmd, void __user *user, unsigned int *len);
</code></pre>

<h4>用户态 setsockopt/getsockopt 调内核态 ipv4_specific.get/setsockopt -> ip_setsockopt -> nf_setsockopt -> nf_sockopt</h4>

<p>内核态的module.c</p>

<pre><code>    #include &lt;linux/module.h&gt;
    #include &lt;linux/kernel.h&gt;
    #include &lt;linux/types.h&gt;
    #include &lt;linux/string.h&gt;
    #include &lt;linux/netfilter_ipv4.h&gt;
    #include &lt;linux/init.h&gt;
    #include &lt;asm/uaccess.h&gt;

    #define SOCKET_OPS_BASE     (128+10000)
    #define SOCKET_OPS_SET      (SOCKET_OPS_BASE)
    #define SOCKET_OPS_GET      (SOCKET_OPS_BASE)
    #define SOCKET_OPS_MAX      (SOCKET_OPS_BASE + 1)

    #define KMSG            "--------kernel---------"
    #define KMSG_LEN        sizeof("--------kernel---------")


    static int recv_msg(struct sock *sk, int cmd, void __user *user, unsigned int len)
    {
        int ret = 0;
        printk(KERN_INFO "sockopt: recv_msg()\n");

        if (cmd == SOCKET_OPS_SET) {
            char umsg[64];
            int len = sizeof(char)*64;
            memset(umsg, 0, len);
            ret = copy_from_user(umsg, user, len);
            printk("recv_msg: umsg = %s. ret = %d\n", umsg, ret);
        }
        return 0;
    }

    static int send_msg(struct sock *sk, int cmd, void __user *user, int *len)
    {
        int ret = 0;
        printk(KERN_INFO "sockopt: send_msg()\n");
        if (cmd == SOCKET_OPS_GET) {
            ret = copy_to_user(user, KMSG, KMSG_LEN);
            printk("send_msg: umsg = %s. ret = %d. success\n", KMSG, ret);
        }
        return 0;

    }

    static struct nf_sockopt_ops test_sockops =
    {
        .pf = PF_INET,
        .set_optmin = SOCKET_OPS_SET,
        .set_optmax = SOCKET_OPS_MAX,
        .set = recv_msg,
        .get_optmin = SOCKET_OPS_GET,
        .get_optmax = SOCKET_OPS_MAX,
        .get = send_msg,
        .owner = THIS_MODULE,
    };

    static int __init init_sockopt(void)
    {
        printk(KERN_INFO "sockopt: init_sockopt()\n");
        return nf_register_sockopt(&amp;test_sockops);
    }

    static void __exit exit_sockopt(void)
    {
        printk(KERN_INFO "sockopt: fini_sockopt()\n");
        nf_unregister_sockopt(&amp;test_sockops);
    }

    module_init(init_sockopt);
    module_exit(exit_sockopt);
    MODULE_LICENSE("GPL");
</code></pre>

<p>用户态的user.c</p>

<pre><code>    #include &lt;unistd.h&gt;
    #include &lt;stdio.h&gt;
    #include &lt;sys/socket.h&gt;
    #include &lt;linux/in.h&gt;
    #include &lt;string.h&gt;
    #include &lt;errno.h&gt;

    #define SOCKET_OPS_BASE     (128+10000)
    #define SOCKET_OPS_SET      (SOCKET_OPS_BASE)
    #define SOCKET_OPS_GET      (SOCKET_OPS_BASE)
    #define SOCKET_OPS_MAX      (SOCKET_OPS_BASE + 1)

    #define UMSG            "----------user------------"
    #define UMSG_LEN        sizeof("----------user------------")

    char kmsg[64];

    int main(void)
    {
        int sockfd;
        int len;
        int ret;

        sockfd = socket(AF_INET, SOCK_RAW, IPPROTO_RAW);
        if (sockfd &lt; 0) {
            printf("can not create a socket\n");
            return -1;
        }

        /*call function recv_msg()*/
        ret = setsockopt(sockfd, IPPROTO_IP, SOCKET_OPS_SET, UMSG, UMSG_LEN);
        printf("setsockopt: ret = %d, msg = %s\n", ret, UMSG);
        len = sizeof(char)*64;

        /*call function send_msg()*/
        ret = getsockopt(sockfd, IPPROTO_IP, SOCKET_OPS_GET, kmsg, &amp;len);
        printf("getsockopt: ret = %d, msg = %s\n", ret, kmsg);
        if (ret != 0) {
            printf("getsockopt error: errno = %d, errstr = %s\n", errno, strerror(errno));
        }

        close(sockfd);
        return 0;
    }
</code></pre>

<p>Makefile
<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
<span class='line-number'>16</span>
<span class='line-number'>17</span>
<span class='line-number'>18</span>
<span class='line-number'>19</span>
<span class='line-number'>20</span>
<span class='line-number'>21</span>
<span class='line-number'>22</span>
<span class='line-number'>23</span>
<span class='line-number'>24</span>
<span class='line-number'>25</span>
<span class='line-number'>26</span>
<span class='line-number'>27</span>
<span class='line-number'>28</span>
<span class='line-number'>29</span>
<span class='line-number'>30</span>
<span class='line-number'>31</span>
<span class='line-number'>32</span>
<span class='line-number'>33</span>
<span class='line-number'>34</span>
<span class='line-number'>35</span>
<span class='line-number'>36</span>
<span class='line-number'>37</span>
<span class='line-number'>38</span>
<span class='line-number'>39</span>
<span class='line-number'>40</span>
<span class='line-number'>41</span>
<span class='line-number'>42</span>
<span class='line-number'>43</span>
<span class='line-number'>44</span>
<span class='line-number'>45</span>
<span class='line-number'>46</span>
<span class='line-number'>47</span>
<span class='line-number'>48</span>
<span class='line-number'>49</span>
<span class='line-number'>50</span>
<span class='line-number'>51</span>
<span class='line-number'>52</span>
<span class='line-number'>53</span>
<span class='line-number'>54</span>
<span class='line-number'>55</span>
<span class='line-number'>56</span>
<span class='line-number'>57</span>
<span class='line-number'>58</span>
<span class='line-number'>59</span>
<span class='line-number'>60</span>
<span class='line-number'>61</span>
<span class='line-number'>62</span>
<span class='line-number'>63</span>
<span class='line-number'>64</span>
<span class='line-number'>65</span>
<span class='line-number'>66</span>
<span class='line-number'>67</span>
<span class='line-number'>68</span>
<span class='line-number'>69</span>
<span class='line-number'>70</span>
<span class='line-number'>71</span>
<span class='line-number'>72</span>
<span class='line-number'>73</span>
<span class='line-number'>74</span>
<span class='line-number'>75</span>
<span class='line-number'>76</span>
<span class='line-number'>77</span>
<span class='line-number'>78</span>
<span class='line-number'>79</span>
<span class='line-number'>80</span>
<span class='line-number'>81</span>
<span class='line-number'>82</span>
<span class='line-number'>83</span>
<span class='line-number'>84</span>
<span class='line-number'>85</span>
<span class='line-number'>86</span>
<span class='line-number'>87</span>
<span class='line-number'>88</span>
<span class='line-number'>89</span>
<span class='line-number'>90</span>
<span class='line-number'>91</span>
<span class='line-number'>92</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>TARGET = socketopt
</span><span class='line'>OBJS = module.o&lt;/p&gt;
</span><span class='line'>
</span><span class='line'>&lt;pre&gt;&lt;code&gt;KDIR = /lib/modules/`uname -r`/build
</span><span class='line'>PWD = $(shell pwd)
</span><span class='line'>
</span><span class='line'>obj-m := $(TARGET).o
</span><span class='line'>
</span><span class='line'>$(TARGET)-objs := $(OBJS)
</span><span class='line'>
</span><span class='line'>default:
</span><span class='line'>make -C $(KDIR) SUBDIRS=$(PWD) modules
</span><span class='line'>clean:
</span><span class='line'>-rm -rf *.o *.ko .$(TARGET).ko.cmd .*.flags *.mod.c modules.order  Module.symvers .tmp_versions
</span><span class='line'>&lt;/code&gt;&lt;/pre&gt;
</span><span class='line'>
</span><span class='line'>&lt;p&gt;```&lt;/p&gt;
</span><span class='line'>]]&gt;&lt;/content&gt;
</span><span class='line'>  &lt;/entry&gt;
</span><span class='line'>  
</span><span class='line'>  &lt;entry&gt;
</span><span class='line'>&lt;title type="html"&gt;&lt;![CDATA[relay 数据传输]]&gt;&lt;/title&gt;
</span><span class='line'>&lt;link href="http://abcdxyzk.github.io/blog/2015/08/03/kernel-base-relay/"/&gt;
</span><span class='line'>&lt;updated&gt;2015-08-03T16:39:00+08:00&lt;/updated&gt;
</span><span class='line'>&lt;id&gt;http://abcdxyzk.github.io/blog/2015/08/03/kernel-base-relay&lt;/id&gt;
</span><span class='line'>&lt;content type="html"&gt;&lt;![CDATA[&lt;p&gt;&lt;a href="https://www.ibm.com/developerworks/cn/linux/l-cn-relay/"&gt;https://www.ibm.com/developerworks/cn/linux/l-cn-relay/&lt;/a&gt;&lt;/p&gt;
</span><span class='line'>
</span><span class='line'>&lt;h4&gt;Relay 要解决的问题&lt;/h4&gt;
</span><span class='line'>
</span><span class='line'>&lt;p&gt;对于任何在内核工作的程序而言，如何把大量的调试信息从内核空间传输到用户空间都是一个大麻烦，对于运行中的内核更是如此。特别是对于哪些用于调试内核性能的工具，更是如此。&lt;/p&gt;
</span><span class='line'>
</span><span class='line'>&lt;p&gt;对于这种大量数据需要在内核中缓存并传输到用户空间需求，很多传统的方法都已到达了极限，例如内核程序员很熟悉的 printk() 调用。此外，如果不同的内核子系统都开发自己的缓存和传输代码，造成很大的代码冗余，而且也带来维护上的困难。&lt;/p&gt;
</span><span class='line'>
</span><span class='line'>&lt;p&gt;这些，都要求开发一套能够高效可靠地将数据从内核空间转发到用户空间的系统，而且这个系统应该独立于各个调试子系统。&lt;/p&gt;
</span><span class='line'>
</span><span class='line'>&lt;p&gt;这样就诞生了 RelayFS。&lt;/p&gt;
</span><span class='line'>
</span><span class='line'>&lt;h4&gt;Relay的发展历史&lt;/h4&gt;
</span><span class='line'>
</span><span class='line'>&lt;p&gt;Relay 的前身是 RelayFS，即作为 Linux 的一个新型文件系统。2003年3月，RelayFS的第一个版本的代码被开发出来，在7月14日，第一个针对2.6内核的版本也开始提供下载。经过广泛的试用和改进，直到2005年9月，RelayFS才被加入mainline内核(2.6.14)。同时，RelayFS也被移植到2.4内核中。在2006年2月，从2.6.17开始，RelayFS不再作为单独的文件系统存在，而是成为内核的一部分。它的源码也从fs/目录下转移到kernel/relay.c中，名称中也从RelayFS改成了Relay。&lt;/p&gt;
</span><span class='line'>
</span><span class='line'>&lt;p&gt;RelayFS目前已经被越来越多的内核工具使用，包括内核调试工具SystemTap、LTT，以及一些特殊的文件系统例如DebugFS。&lt;/p&gt;
</span><span class='line'>
</span><span class='line'>&lt;h4&gt;Relay的基本原理&lt;/h4&gt;
</span><span class='line'>
</span><span class='line'>&lt;p&gt;总的说来，Relay提供了一种机制，使得内核空间的程序能够通过用户定义的relay通道(channel)将大量数据高效的传输到用户空间。&lt;/p&gt;
</span><span class='line'>
</span><span class='line'>&lt;p&gt;一个relay通道由一组和CPU一一对应的内核缓冲区组成。这些缓冲区又被称为relay缓冲区(buffer)，其中的每一个在用户空间都用一个常规文件来表示，这被叫做relay文件(file)。内核空间的用户可以利用relay提供的API接口来写入数据，这些数据会被自动的写入当前的CPU id对应的那个relay缓冲区；同时，这些缓冲区从用户空间看来，是一组普通文件，可以直接使用read()进行读取，也可以使用mmap()进行映射。Relay并不关心数据的格式和内容，这些完全依赖于使用relay的用户程序。Relay的目的是提供一个足够简单的接口，从而使得基本操作尽可能的高效。&lt;/p&gt;
</span><span class='line'>
</span><span class='line'>&lt;p&gt;Relay将数据的读和写分离，使得突发性大量数据写入的时候，不需要受限于用户空间相对较慢的读取速度，从而大大提高了效率。Relay作为写入和读取的桥梁，也就是将内核用户写入的数据缓存并转发给用户空间的程序。这种转发机制也正是Relay这个名称的由来。&lt;/p&gt;
</span><span class='line'>
</span><span class='line'>&lt;p&gt;下面这个图给出了Relay的基本结构和典型操作：&lt;/p&gt;
</span><span class='line'>
</span><span class='line'>&lt;p&gt;&lt;img src="/images/kernel/2015-08-03.png" alt="" /&gt;&lt;/p&gt;
</span><span class='line'>
</span><span class='line'>&lt;p&gt;Relay的基本结构和典型操作&lt;/p&gt;
</span><span class='line'>
</span><span class='line'>&lt;p&gt;可以看到，这里的relay通道由四个relay缓冲区(kbuf0到kbuf3)组成，分别对应于系统中的cpu0到cpu1。每个CPU上的代码调用relay_write()的时候将数据写入自己对应的relay缓冲区内。每个relay缓冲区称一个relay文件，即/cpu0到/cpu3。当文件系统被mount到/mnt/以后，这个relay文件就被映射成映射到用户空间的地址空间。一旦数据可用，用户程序就可以把它的数据读出来写入到硬盘上的文件中，即cpu0.out到cpu3.out。&lt;/p&gt;
</span><span class='line'>
</span><span class='line'>&lt;h4&gt;Relay的主要API&lt;/h4&gt;
</span><span class='line'>
</span><span class='line'>&lt;p&gt;前面提到的 relay_write() 就是 relay API 之一。除此以外，Relay 还提供了更多的 API来支持用户程序完整的使用 relay。这些 API，主要按照面向用户空间和面向内核空间分为两大类，下面我们来分别进行介绍。&lt;/p&gt;
</span><span class='line'>
</span><span class='line'>&lt;h5&gt;面向用户空间的 API&lt;/h5&gt;
</span><span class='line'>
</span><span class='line'>&lt;p&gt;这些 Relay 编程接口向用户空间程序提供了访问 relay 通道缓冲区数据的基本操作的入口，包括：
</span><span class='line'>&lt;code&gt;
</span><span class='line'>open() - 允许用户打开一个已经存在的通道缓冲区
</span><span class='line'>mmap() - 使通道缓冲区被映射到位于用户空间的调用者的地址空间。要特别注意的是，我们不能仅对局部区域进行映射。也就是说，必须映射整个缓冲区文件，其大小是 CPU的个数和单个 CPU 缓冲区大小的乘积
</span><span class='line'>read() - 读取通道缓冲区的内容。这些数据一旦被读出，就意味着他们被用户空间的程序消费掉了，也就不能被之后的读操作看到
</span><span class='line'>sendfile() - 将数据从通道缓冲区传输到一个输出文件描述符。其中可能的填充字符会被自动去掉，不会被用户看到
</span><span class='line'>poll() - 支持 POLLIN/POLLRDNORM/POLLERR 信号。每次子缓冲区的边界被越过时，等待着的用户空间程序会得到通知
</span><span class='line'>close() - 将通道缓冲区的引用数减1。当引用数减为0时，表明没有进程或者内核用户需要打开它，从而这个通道缓冲区被释放。
</span><span class='line'>&lt;/code&gt;&lt;/p&gt;
</span><span class='line'>
</span><span class='line'>&lt;h5&gt;面向内核空间的 API&lt;/h5&gt;
</span><span class='line'>
</span><span class='line'>&lt;p&gt;这些API接口向位于内核空间的用户提供了管理relay通道、数据写入等功能。下面介绍其中主要的部分，完整的API接口列表请参见这里。
</span><span class='line'>&lt;code&gt;
</span><span class='line'>relay_open() - 创建一个relay通道，包括创建每个CPU对应的relay缓冲区。
</span><span class='line'>relay_close() - 关闭一个relay通道，包括释放所有的relay缓冲区，在此之前会调用relay_switch()来处理这些relay缓冲区以保证已读取但是未满的数据不会丢失
</span><span class='line'>relay_write() - 将数据写入到当前CPU对应的relay缓冲区内。由于它使用了local_irqsave()保护，因此也可以在中断上下文中使用。
</span><span class='line'>relay_reserve() - 在relay通道中保留一块连续的区域来留给未来的写入操作。这通常用于那些希望直接写入到relay缓冲区的用户。考虑到性能或者其它因素，这些用户不希望先把数据写到一个临时缓冲区中，然后再通过relay_write()进行写入。
</span><span class='line'>&lt;/code&gt;&lt;/p&gt;
</span><span class='line'>
</span><span class='line'>&lt;h4&gt;Relay的例子&lt;/h4&gt;
</span><span class='line'>
</span><span class='line'>&lt;p&gt;我们用一个最简单的例子来介绍怎么使用Relay。这个例子由两部分组成：一部分是位于内核空间将数据写入relay文件的程序，使用时需要作为一个内核模块被加载；另一部分是位于用户空间从relay文件中读取数据的程序，使用时作为普通用户态程序运行。&lt;/p&gt;
</span><span class='line'>
</span><span class='line'>&lt;p&gt;内核空间的程序主要操作是：&lt;br/&gt;
</span><span class='line'>  加载模块时，打开一个relay通道，并且往打开的relay通道中写入消息；&lt;br/&gt;
</span><span class='line'>  卸载模块时，关闭relay通道。</span></code></pre></td></tr></table></div></figure>
    #include &lt;linux/module.h>
    #include &lt;linux/relay.h>
    #include &lt;linux/debugfs.h></p>

<pre><code>static struct dentry *create_buf_file_handler(const char *filename, struct dentry *parent, int mode, struct rchan_buf *buf, int *is_global)
{
    return debugfs_create_file(filename, mode, parent, buf, &amp;relay_file_operations);
}

static int remove_buf_file_handler(struct dentry *dentry)
{
    debugfs_remove(dentry);
    return 0;
}

static struct rchan_callbacks relay_callbacks =
{
    .create_buf_file = create_buf_file_handler,
    .remove_buf_file = remove_buf_file_handler,
};

static struct rchan *hello_rchan;
struct dentry *dir;

int init_module(void)
{
    const char *msg="Hello world\n";
    dir = debugfs_create_dir("test", NULL);
#if (LINUX_VERSION_CODE &gt;= KERNEL_VERSION(2,6,32))
    hello_rchan = relay_open("cpu", dir, 8192, 2, &amp;relay_callbacks, NULL);
#else   
    hello_rchan = relay_open("cpu", dir, 8192, 2, &amp;relay_callbacks);
#endif  
    if(!hello_rchan){
        printk("relay_open() failed.\n");
        return -ENOMEM;
    }
    relay_write(hello_rchan, msg, strlen(msg));
    return 0;
}
</code></pre>

<pre><code>
查看输出
</code></pre>

<pre><code>mount -t debugfs debugfs /media
cat /media/test/cpu*
</code></pre>

<pre><code>
---------------
---------------

http://www.cnblogs.com/hoys/archive/2011/04/10/2011270.html

### 用户空间与内核空间数据交换的方式(4)------relayfs

relayfs是一个快速的转发（relay）数据的文件系统，它以其功能而得名。它为那些需要从内核空间转发大量数据到用户空间的工具和应用提供了快速有效的转发机制。

Channel是relayfs文件系统定义的一个主要概念，每一个channel由一组内核缓存组成，每一个CPU有一个对应于该channel 的内核缓存，每一个内核缓存用一个在relayfs文件系统中的文件文件表示，内核使用relayfs提供的写函数把需要转发给用户空间的数据快速地写入当前CPU上的channel内核缓存，用户空间应用通过标准的文件I/O函数在对应的channel文件中可以快速地取得这些被转发出的数据mmap 来。写入到channel中的数据的格式完全取决于内核中创建channel的模块或子系统。

#### relayfs的用户空间API：

relayfs实现了四个标准的文件I/O函数，open、mmap、poll和close.

open()，打开一个channel在某一个CPU上的缓存对应的文件。

mmap()，把打开的channel缓存映射到调用者进程的内存空间。

read ()，读取channel缓存，随后的读操作将看不到被该函数消耗的字节，如果channel的操作模式为非覆盖写，那么用户空间应用在有内核模块写时仍 可以读取，但是如果channel的操作模式为覆盖式，那么在读操作期间如果有内核模块进行写，结果将无法预知，因此对于覆盖式写的channel，用户 应当在确认在channel的写完全结束后再进行读。

poll()，用于通知用户空间应用转发数据跨越了子缓存的边界，支持的轮询标志有POLLIN、POLLRDNORM和POLLERR。

close()，关闭open函数返回的文件描述符，如果没有进程或内核模块打开该channel缓存，close函数将释放该channel缓存。

注意：用户态应用在使用上述API时必须保证已经挂载了relayfs文件系统，但内核在创建和使用channel时不需要relayfs已经挂载。下面命令将把relayfs文件系统挂载到/mnt/relay。
</code></pre>

<pre><code>mount -t relayfs relayfs /mnt/relay
</code></pre>

<pre><code>
#### relayfs内核API：

relayfs提供给内核的API包括四类：channel管理、写函数、回调函数和辅助函数。

Channel管理函数包括：
</code></pre>

<pre><code>relay_open(base_filename, parent, subbuf_size, n_subbufs, overwrite, callbacks)
relay_close(chan)
relay_flush(chan)
relay_reset(chan)
relayfs_create_dir(name, parent)
relayfs_remove_dir(dentry)
relay_commit(buf, reserved, count)
relay_subbufs_consumed(chan, cpu, subbufs_consumed)
</code></pre>

<pre><code>写函数包括：
</code></pre>

<pre><code>relay_write(chan, data, length)
__relay_write(chan, data, length)
relay_reserve(chan, length)
</code></pre>

<pre><code>
回调函数包括：
</code></pre>

<pre><code>subbuf_start(buf, subbuf, prev_subbuf_idx, prev_subbuf)
buf_mapped(buf, filp)
buf_unmapped(buf, filp)
</code></pre>

<pre><code>
辅助函数包括：
</code></pre>

<pre><code>relay_buf_full(buf)
subbuf_start_reserve(buf, length)
</code></pre>

<pre><code>
前面已经讲过，每一个channel由一组channel缓存组成，每个CPU对应一个该channel的缓存，每一个缓存又由一个或多个子缓存组成，每一个缓存是子缓存组成的一个环型缓存。

函数relay_open用于创建一个channel并分配对应于每一个CPU的缓存，用户空间应用通过在relayfs文件系统中对应的文件可以 访问channel缓存，参数base_filename用于指定channel的文件名，relay_open函数将在relayfs文件系统中创建 base_filename0..base_filenameN-1，即每一个CPU对应一个channel文件，其中N为CPU数，缺省情况下，这些文件将建立在relayfs文件系统的根目录下，但如果参数parent非空，该函数将把channel文件创建于parent目录下，parent目录使 用函数relay_create_dir创建，函数relay_remove_dir用于删除由函数relay_create_dir创建的目录，谁创建的目录，谁就负责在不用时负责删除。参数subbuf_size用于指定channel缓存中每一个子缓存的大小，参数n_subbufs用于指定 channel缓存包含的子缓存数，因此实际的channel缓存大小为(subbuf_size x n_subbufs)，参数overwrite用于指定该channel的操作模式，relayfs提供了两种写模式，一种是覆盖式写，另一种是非覆盖式 写。使用哪一种模式完全取决于函数subbuf_start的实现，覆盖写将在缓存已满的情况下无条件地继续从缓存的开始写数据，而不管这些数据是否已经 被用户应用读取，因此写操作决不失败。在非覆盖写模式下，如果缓存满了，写将失败，但内核将在用户空间应用读取缓存数据时通过函数 relay_subbufs_consumed()通知relayfs。如果用户空间应用没来得及消耗缓存中的数据或缓存已满，两种模式都将导致数据丢失，唯一的区别是，前者丢失数据在缓存开头，而后者丢失数据在缓存末尾。一旦内核再次调用函数relay_subbufs_consumed()，已满的缓存将不再满，因而可以继续写该缓存。当缓存满了以后，relayfs将调用回调函数buf_full()来通知内核模块或子系统。当新的数据太大无法写 入当前子缓存剩余的空间时，relayfs将调用回调函数subbuf_start()来通知内核模块或子系统将需要使用新的子缓存。内核模块需要在该回调函数中实现下述功能：

初始化新的子缓存；

如果1正确，完成当前子缓存；

如果2正确，返回是否正确完成子缓存切换；

在非覆盖写模式下，回调函数subbuf_start()应该如下实现：
</code></pre>

<pre><code>static int subbuf_start(struct rchan_buf *buf, void *subbuf, void *prev_subbuf, unsigned intprev_padding)
{
    if (prev_subbuf)
        *((unsigned *)prev_subbuf) = prev_padding;

    if (relay_buf_full(buf))
        return 0;

    subbuf_start_reserve(buf, sizeof(unsigned int));
    return 1;
}
</code></pre>

<pre><code>
如果当前缓存满，即所有的子缓存都没读取，该函数返回0，指示子缓存切换没有成功。当子缓存通过函数relay_subbufs_consumed ()被读取后，读取者将负责通知relayfs，函数relay_buf_full()在已经有读者读取子缓存数据后返回0，在这种情况下，子缓存切换成 功进行。

在覆盖写模式下， subbuf_start()的实现与非覆盖模式类似：
</code></pre>

<pre><code>static int subbuf_start(struct rchan_buf *buf, void *subbuf, void *prev_subbuf, unsigned int prev_padding)
{
    if (prev_subbuf)
        *((unsigned *)prev_subbuf) = prev_padding;

    subbuf_start_reserve(buf, sizeof(unsigned int));

    return 1;
}
</code></pre>

<pre><code>
只是不做relay_buf_full()检查，因为此模式下，缓存是环行的，可以无条件地写。因此在此模式下，子缓存切换必定成功，函数 relay_subbufs_consumed() 也无须调用。如果channel写者没有定义subbuf_start()，缺省的实现将被使用。 可以通过在回调函数subbuf_start()中调用辅助函数subbuf_start_reserve()在子缓存中预留头空间，预留空间可以保存任 何需要的信息，如上面例子中，预留空间用于保存子缓存填充字节数，在subbuf_start()实现中，前一个子缓存的填充值被设置。前一个子缓存的填 充值和指向前一个子缓存的指针一道作为subbuf_start()的参数传递给subbuf_start()，只有在子缓存完成后，才能知道填充值。 subbuf_start()也被在channel创建时分配每一个channel缓存的第一个子缓存时调用，以便预留头空间，但在这种情况下，前一个子 缓存指针为NULL。

内核模块使用函数relay_write()或__relay_write()往channel缓存中写需要转发的数据，它们的区别是前者失效了本 地中断，而后者只抢占失效，因此前者可以在任何内核上下文安全使用，而后者应当在没有任何中断上下文将写channel缓存的情况下使用。这两个函数没有 返回值，因此用户不能直接确定写操作是否失败，在缓存满且写模式为非覆盖模式时，relayfs将通过回调函数buf_full来通知内核模块。

函数relay_reserve()用于在channel缓存中预留一段空间以便以后写入，在那些没有临时缓存而直接写入channel缓存的内核 模块可能需要该函数，使用该函数的内核模块在实际写这段预留的空间时可以通过调用relay_commit()来通知relayfs。当所有预留的空间全 部写完并通过relay_commit通知relayfs后，relayfs将调用回调函数deliver()通知内核模块一个完整的子缓存已经填满。由于预留空间的操作并不在写channel的内核模块完全控制之下，因此relay_reserve()不能很好地保护缓存，因此当内核模块调用 relay_reserve()时必须采取恰当的同步机制。

当内核模块结束对channel的使用后需要调用relay_close() 来关闭channel，如果没有任何用户在引用该channel，它将和对应的缓存全部被释放。

函数relay_flush()强制在所有的channel缓存上做一个子缓存切换，它在channel被关闭前使用来终止和处理最后的子缓存。

函数relay_reset()用于将一个channel恢复到初始状态，因而不必释放现存的内存映射并重新分配新的channel缓存就可以使用channel，但是该调用只有在该channel没有任何用户在写的情况下才可以安全使用。

回调函数buf_mapped() 在channel缓存被映射到用户空间时被调用。

回调函数buf_unmapped()在释放该映射时被调用。内核模块可以通过它们触发一些内核操作，如开始或结束channel写操作。

在源代码包中给出了一个使用relayfs的示例程序relayfs_exam.c，它只包含一个内核模块，对于复杂的使用，需要应用程序配合。该模块实现了类似于文章中seq_file示例实现的功能。

当然为了使用relayfs，用户必须让内核支持relayfs，并且要mount它，下面是作者系统上的使用该模块的输出信息：
</code></pre>

<pre><code>$ mkdir -p /relayfs
$ insmod ./relayfs-exam.ko
$ mount -t relayfs relayfs /relayfs
$ cat /relayfs/example0
…
$
</code></pre>

<pre><code>
relayfs是一种比较复杂的内核态与用户态的数据交换方式，本例子程序只提供了一个较简单的使用方式，对于复杂的使用，请参考relayfs用例页面http://relayfs.sourceforge.net/examples.html。
</code></pre>

<pre><code>//kernel module: relayfs-exam.c
#include &lt;linux/module.h&gt;
#include &lt;linux/relayfs_fs.h&gt;
#include &lt;linux/string.h&gt;
#include &lt;linux/sched.h&gt;

#define WRITE_PERIOD (HZ * 60)
static struct rchan * chan;
static size_t subbuf_size = 65536;
static size_t n_subbufs = 4;
static char buffer[256];

void relayfs_exam_write(unsigned long data);

static DEFINE_TIMER(relayfs_exam_timer, relayfs_exam_write, 0, 0);

void relayfs_exam_write(unsigned long data)
{
    int len;
    task_t * p = NULL;

    len = sprintf(buffer, "Current all the processes:\n");
    len += sprintf(buffer + len, "process name\t\tpid\n");
    relay_write(chan, buffer, len);

    for_each_process(p) {
        len = sprintf(buffer, "%s\t\t%d\n", p-&gt;comm, p-&gt;pid);
        relay_write(chan, buffer, len);
    }
    len = sprintf(buffer, "\n\n");
    relay_write(chan, buffer, len);

    relayfs_exam_timer.expires = jiffies + WRITE_PERIOD;
    add_timer(&amp;relayfs_exam_timer);
}


/*
* subbuf_start() relayfs callback.
*
* Defined so that we can 1) reserve padding counts in the sub-buffers, and
* 2) keep a count of events dropped due to the buffer-full condition.
*/
static int subbuf_start(struct rchan_buf *buf,
                void *subbuf,
                void *prev_subbuf,
                unsigned int prev_padding)
{
    if (prev_subbuf)
        *((unsigned *)prev_subbuf) = prev_padding;

    if (relay_buf_full(buf))
        return 0;

    subbuf_start_reserve(buf, sizeof(unsigned int));

    return 1;
}

/*
* relayfs callbacks
*/
static struct rchan_callbacks relayfs_callbacks =
{
    .subbuf_start = subbuf_start,
};

/**
* module init - creates channel management control files
*
* Returns 0 on success, negative otherwise.
*/
static int init(void)
{

    chan = relay_open("example", NULL, subbuf_size,
    n_subbufs, &amp;relayfs_callbacks);

    if (!chan) {
        printk("relay channel creation failed.\n");
        return 1;
    }
    relayfs_exam_timer.expires = jiffies + WRITE_PERIOD;
    add_timer(&amp;relayfs_exam_timer);

    return 0;
}

static void cleanup(void)
{
    del_timer_sync(&amp;relayfs_exam_timer);
    if (chan) {
        relay_close(chan);
        chan = NULL;
    }
}

module_init(init);
module_exit(cleanup);
MODULE_LICENSE("GPL");
</code></pre>

<p>```</p>
]]></content>
  </entry>
  
</feed>
