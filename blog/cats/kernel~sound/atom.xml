<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

  <title><![CDATA[Category: kernel~sound | kk Blog —— 通用基础]]></title>
  <link href="http://abcdxyzk.github.io/blog/cats/kernel~sound/atom.xml" rel="self"/>
  <link href="http://abcdxyzk.github.io/"/>
  <updated>2025-07-21T17:22:06+08:00</updated>
  <id>http://abcdxyzk.github.io/</id>
  <author>
    <name><![CDATA[kk]]></name>
    
  </author>
  <generator uri="http://octopress.org/">Octopress</generator>

  
  <entry>
    <title type="html"><![CDATA[截获alsa-pcm音频]]></title>
    <link href="http://abcdxyzk.github.io/blog/2018/03/03/kernel-alsa-4/"/>
    <updated>2018-03-03T19:25:00+08:00</updated>
    <id>http://abcdxyzk.github.io/blog/2018/03/03/kernel-alsa-4</id>
    <content type="html"><![CDATA[<p><a href="http://blog.csdn.net/killmice/article/details/51777205">http://blog.csdn.net/killmice/article/details/51777205</a></p>

<p><a href="https://www.linuxidc.com/Linux/2014-11/109948.htm">https://www.linuxidc.com/Linux/2014-11/109948.htm</a></p>

<p><a href="http://www.ituring.com.cn/article/201363">http://www.ituring.com.cn/article/201363</a></p>

<h4>avconv 命令录制</h4>

<p>arecord -l</p>

<p>avconv -f alsa -i hw:0 output.wav</p>

<hr />

<h4>截获 alsa 框架中 pcm 缓冲区</h4>

<p>sound/core/pcm_native.c
<code>
    const struct file_operations snd_pcm_f_ops[2] = {
        {
            .owner =                THIS_MODULE,
            .write =                snd_pcm_write,
            .aio_write =            snd_pcm_aio_write,
            .open =                 snd_pcm_playback_open,
            .release =              snd_pcm_release,
            .llseek =               no_llseek,
            .poll =                 snd_pcm_playback_poll,
            .unlocked_ioctl =       snd_pcm_playback_ioctl,
            .compat_ioctl =         snd_pcm_ioctl_compat,
            .mmap =                 snd_pcm_mmap,
            .fasync =               snd_pcm_fasync,
            .get_unmapped_area =    snd_pcm_get_unmapped_area,
        },   
        {
            .owner =                THIS_MODULE,
            .read =                 snd_pcm_read,
            .aio_read =             snd_pcm_aio_read,
            .open =                 snd_pcm_capture_open,
            .release =              snd_pcm_release,
            .llseek =               no_llseek,
            .poll =                 snd_pcm_capture_poll,
            .unlocked_ioctl =       snd_pcm_capture_ioctl,
            .compat_ioctl =         snd_pcm_ioctl_compat,
            .mmap =                 snd_pcm_mmap,
            .fasync =               snd_pcm_fasync,
            .get_unmapped_area =    snd_pcm_get_unmapped_area,
        }
    };
</code></p>

<p>在进入 snd_pcm_playback_ioctl 时 cmd=SNDRV_PCM_IOCTL_HWSYNC 时 copy 出 runtime->dma_area 对应数据</p>

<pre><code>    struct snd_pcm_substream *substream = (struct snd_pcm_substream *)regs-&gt;si;
    struct snd_pcm_runtime *runtime = substream-&gt;runtime;
    struct snd_pcm_mmap_status *status = runtime-&gt;status;
    struct snd_pcm_mmap_control *control = runtime-&gt;control;

    if (substream_now == substream) {
        unsigned int i, bytes = runtime-&gt;dma_bytes;
        unsigned char *ch = runtime-&gt;dma_area;

        /*
        printk("ioctl1: size=%d hw_ptr=%d appl_ptr=%d avail_min=%d audio_tstamp=%d\n",
            (int)runtime-&gt;dma_bytes, (int)status-&gt;hw_ptr, (int)control-&gt;appl_ptr,
            (int)control-&gt;avail_min, (int)status-&gt;audio_tstamp.tv_sec);
        */

        if (status-&gt;hw_ptr &gt; hw_ptr) {
            hw_ptr = status-&gt;hw_ptr;
            hw_ptr_err ++; 
        }

        for (i = hw_ptr * 4; before(i, control-&gt;appl_ptr * 4) &amp;&amp; len &lt; LEN; i ++, len ++)
            dest[len] = ch[i % bytes];

        hw_ptr = control-&gt;appl_ptr;
    }
</code></pre>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Alsa之pcm]]></title>
    <link href="http://abcdxyzk.github.io/blog/2018/03/03/kernel-alsa-3/"/>
    <updated>2018-03-03T18:45:00+08:00</updated>
    <id>http://abcdxyzk.github.io/blog/2018/03/03/kernel-alsa-3</id>
    <content type="html"><![CDATA[<p><a href="http://www.alivepea.me/kernel/alsa-pcm/">http://www.alivepea.me/kernel/alsa-pcm/</a></p>

<p>pcm用来描述alsa中数字音频流。Alsa音频的播放/录制就是通过pcm来实现 的。</p>

<h4>名词解释</h4>

<p>声音是连续模拟量，计算机将它离散化之后用数字表示，就有了以下几个名词术语。
<code>
    Frame. 帧是音频流中最小的单位，一段音频数据就是由苦干帧组成的。
    Channel. 通道表示每帧数据中包含的通道数。单声道音频Mono含有 1个通道，立体声Stereo音频通常为2个通道。
    Bit Depth. 位深，也叫采样精度，计算机对每个通道采样量化时数字比特位数，通常有16/24/32位。
    Frames Per Second. 采样率表示每秒的采样帧数。常用的采样率如8KHz的人声， 44.1KHz的mp3音乐, 96Khz的蓝光音频。
    Bits Per Second. 比特率表示每秒的比特数。
</code></p>

<h4>数据结构</h4>

<p>snd_pcm结构用于表征一个PCM类型的snd_device.
<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
<span class='line-number'>16</span>
<span class='line-number'>17</span>
<span class='line-number'>18</span>
<span class='line-number'>19</span>
<span class='line-number'>20</span>
<span class='line-number'>21</span>
<span class='line-number'>22</span>
<span class='line-number'>23</span>
<span class='line-number'>24</span>
<span class='line-number'>25</span>
<span class='line-number'>26</span>
<span class='line-number'>27</span>
<span class='line-number'>28</span>
<span class='line-number'>29</span>
<span class='line-number'>30</span>
<span class='line-number'>31</span>
<span class='line-number'>32</span>
<span class='line-number'>33</span>
<span class='line-number'>34</span>
<span class='line-number'>35</span>
<span class='line-number'>36</span>
<span class='line-number'>37</span>
<span class='line-number'>38</span>
<span class='line-number'>39</span>
<span class='line-number'>40</span>
<span class='line-number'>41</span>
<span class='line-number'>42</span>
<span class='line-number'>43</span>
<span class='line-number'>44</span>
<span class='line-number'>45</span>
<span class='line-number'>46</span>
<span class='line-number'>47</span>
<span class='line-number'>48</span>
<span class='line-number'>49</span>
<span class='line-number'>50</span>
<span class='line-number'>51</span>
<span class='line-number'>52</span>
<span class='line-number'>53</span>
<span class='line-number'>54</span>
<span class='line-number'>55</span>
<span class='line-number'>56</span>
<span class='line-number'>57</span>
<span class='line-number'>58</span>
<span class='line-number'>59</span>
<span class='line-number'>60</span>
<span class='line-number'>61</span>
<span class='line-number'>62</span>
<span class='line-number'>63</span>
<span class='line-number'>64</span>
<span class='line-number'>65</span>
<span class='line-number'>66</span>
<span class='line-number'>67</span>
<span class='line-number'>68</span>
<span class='line-number'>69</span>
<span class='line-number'>70</span>
<span class='line-number'>71</span>
<span class='line-number'>72</span>
<span class='line-number'>73</span>
<span class='line-number'>74</span>
<span class='line-number'>75</span>
<span class='line-number'>76</span>
<span class='line-number'>77</span>
<span class='line-number'>78</span>
<span class='line-number'>79</span>
<span class='line-number'>80</span>
<span class='line-number'>81</span>
<span class='line-number'>82</span>
<span class='line-number'>83</span>
<span class='line-number'>84</span>
<span class='line-number'>85</span>
<span class='line-number'>86</span>
<span class='line-number'>87</span>
<span class='line-number'>88</span>
<span class='line-number'>89</span>
<span class='line-number'>90</span>
<span class='line-number'>91</span>
<span class='line-number'>92</span>
<span class='line-number'>93</span>
<span class='line-number'>94</span>
<span class='line-number'>95</span>
<span class='line-number'>96</span>
<span class='line-number'>97</span>
<span class='line-number'>98</span>
<span class='line-number'>99</span>
<span class='line-number'>100</span>
<span class='line-number'>101</span>
<span class='line-number'>102</span>
<span class='line-number'>103</span>
<span class='line-number'>104</span>
<span class='line-number'>105</span>
<span class='line-number'>106</span>
<span class='line-number'>107</span>
<span class='line-number'>108</span>
<span class='line-number'>109</span>
<span class='line-number'>110</span>
<span class='line-number'>111</span>
<span class='line-number'>112</span>
<span class='line-number'>113</span>
<span class='line-number'>114</span>
<span class='line-number'>115</span>
<span class='line-number'>116</span>
<span class='line-number'>117</span>
<span class='line-number'>118</span>
<span class='line-number'>119</span>
<span class='line-number'>120</span>
<span class='line-number'>121</span>
<span class='line-number'>122</span>
<span class='line-number'>123</span>
<span class='line-number'>124</span>
<span class='line-number'>125</span>
<span class='line-number'>126</span>
<span class='line-number'>127</span>
<span class='line-number'>128</span>
<span class='line-number'>129</span>
<span class='line-number'>130</span>
<span class='line-number'>131</span>
<span class='line-number'>132</span>
<span class='line-number'>133</span>
<span class='line-number'>134</span>
<span class='line-number'>135</span>
<span class='line-number'>136</span>
<span class='line-number'>137</span>
<span class='line-number'>138</span>
<span class='line-number'>139</span>
<span class='line-number'>140</span>
<span class='line-number'>141</span>
<span class='line-number'>142</span>
<span class='line-number'>143</span>
<span class='line-number'>144</span>
<span class='line-number'>145</span>
<span class='line-number'>146</span>
<span class='line-number'>147</span>
<span class='line-number'>148</span>
<span class='line-number'>149</span>
<span class='line-number'>150</span>
<span class='line-number'>151</span>
<span class='line-number'>152</span>
<span class='line-number'>153</span>
<span class='line-number'>154</span>
<span class='line-number'>155</span>
<span class='line-number'>156</span>
<span class='line-number'>157</span>
<span class='line-number'>158</span>
<span class='line-number'>159</span>
<span class='line-number'>160</span>
<span class='line-number'>161</span>
<span class='line-number'>162</span>
<span class='line-number'>163</span>
<span class='line-number'>164</span>
<span class='line-number'>165</span>
<span class='line-number'>166</span>
<span class='line-number'>167</span>
<span class='line-number'>168</span>
<span class='line-number'>169</span>
<span class='line-number'>170</span>
<span class='line-number'>171</span>
<span class='line-number'>172</span>
<span class='line-number'>173</span>
<span class='line-number'>174</span>
<span class='line-number'>175</span>
<span class='line-number'>176</span>
<span class='line-number'>177</span>
<span class='line-number'>178</span>
<span class='line-number'>179</span>
<span class='line-number'>180</span>
<span class='line-number'>181</span>
<span class='line-number'>182</span>
<span class='line-number'>183</span>
<span class='line-number'>184</span>
<span class='line-number'>185</span>
<span class='line-number'>186</span>
<span class='line-number'>187</span>
<span class='line-number'>188</span>
<span class='line-number'>189</span>
<span class='line-number'>190</span>
<span class='line-number'>191</span>
<span class='line-number'>192</span>
<span class='line-number'>193</span>
<span class='line-number'>194</span>
<span class='line-number'>195</span>
<span class='line-number'>196</span>
<span class='line-number'>197</span>
<span class='line-number'>198</span>
<span class='line-number'>199</span>
<span class='line-number'>200</span>
<span class='line-number'>201</span>
<span class='line-number'>202</span>
<span class='line-number'>203</span>
<span class='line-number'>204</span>
<span class='line-number'>205</span>
<span class='line-number'>206</span>
<span class='line-number'>207</span>
<span class='line-number'>208</span>
<span class='line-number'>209</span>
<span class='line-number'>210</span>
<span class='line-number'>211</span>
<span class='line-number'>212</span>
<span class='line-number'>213</span>
<span class='line-number'>214</span>
<span class='line-number'>215</span>
<span class='line-number'>216</span>
<span class='line-number'>217</span>
<span class='line-number'>218</span>
<span class='line-number'>219</span>
<span class='line-number'>220</span>
<span class='line-number'>221</span>
<span class='line-number'>222</span>
<span class='line-number'>223</span>
<span class='line-number'>224</span>
<span class='line-number'>225</span>
<span class='line-number'>226</span>
<span class='line-number'>227</span>
<span class='line-number'>228</span>
<span class='line-number'>229</span>
<span class='line-number'>230</span>
<span class='line-number'>231</span>
<span class='line-number'>232</span>
<span class='line-number'>233</span>
<span class='line-number'>234</span>
<span class='line-number'>235</span>
<span class='line-number'>236</span>
<span class='line-number'>237</span>
<span class='line-number'>238</span>
<span class='line-number'>239</span>
<span class='line-number'>240</span>
<span class='line-number'>241</span>
<span class='line-number'>242</span>
<span class='line-number'>243</span>
<span class='line-number'>244</span>
<span class='line-number'>245</span>
<span class='line-number'>246</span>
<span class='line-number'>247</span>
<span class='line-number'>248</span>
<span class='line-number'>249</span>
<span class='line-number'>250</span>
<span class='line-number'>251</span>
<span class='line-number'>252</span>
<span class='line-number'>253</span>
<span class='line-number'>254</span>
<span class='line-number'>255</span>
<span class='line-number'>256</span>
<span class='line-number'>257</span>
<span class='line-number'>258</span>
<span class='line-number'>259</span>
<span class='line-number'>260</span>
<span class='line-number'>261</span>
<span class='line-number'>262</span>
<span class='line-number'>263</span>
<span class='line-number'>264</span>
<span class='line-number'>265</span>
<span class='line-number'>266</span>
<span class='line-number'>267</span>
<span class='line-number'>268</span>
<span class='line-number'>269</span>
<span class='line-number'>270</span>
<span class='line-number'>271</span>
<span class='line-number'>272</span>
<span class='line-number'>273</span>
<span class='line-number'>274</span>
<span class='line-number'>275</span>
<span class='line-number'>276</span>
<span class='line-number'>277</span>
<span class='line-number'>278</span>
<span class='line-number'>279</span>
<span class='line-number'>280</span>
<span class='line-number'>281</span>
<span class='line-number'>282</span>
<span class='line-number'>283</span>
<span class='line-number'>284</span>
<span class='line-number'>285</span>
<span class='line-number'>286</span>
<span class='line-number'>287</span>
<span class='line-number'>288</span>
<span class='line-number'>289</span>
<span class='line-number'>290</span>
<span class='line-number'>291</span>
<span class='line-number'>292</span>
<span class='line-number'>293</span>
<span class='line-number'>294</span>
<span class='line-number'>295</span>
<span class='line-number'>296</span>
<span class='line-number'>297</span>
<span class='line-number'>298</span>
<span class='line-number'>299</span>
<span class='line-number'>300</span>
<span class='line-number'>301</span>
<span class='line-number'>302</span>
<span class='line-number'>303</span>
<span class='line-number'>304</span>
<span class='line-number'>305</span>
<span class='line-number'>306</span>
<span class='line-number'>307</span>
<span class='line-number'>308</span>
<span class='line-number'>309</span>
<span class='line-number'>310</span>
<span class='line-number'>311</span>
<span class='line-number'>312</span>
<span class='line-number'>313</span>
<span class='line-number'>314</span>
<span class='line-number'>315</span>
<span class='line-number'>316</span>
<span class='line-number'>317</span>
<span class='line-number'>318</span>
<span class='line-number'>319</span>
<span class='line-number'>320</span>
<span class='line-number'>321</span>
<span class='line-number'>322</span>
<span class='line-number'>323</span>
<span class='line-number'>324</span>
<span class='line-number'>325</span>
<span class='line-number'>326</span>
<span class='line-number'>327</span>
<span class='line-number'>328</span>
<span class='line-number'>329</span>
<span class='line-number'>330</span>
<span class='line-number'>331</span>
<span class='line-number'>332</span>
<span class='line-number'>333</span>
<span class='line-number'>334</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>struct snd_pcm {
</span><span class='line'>    struct snd_card &lt;em&gt;card; /&lt;/em&gt; 指向所属的card设备 &lt;em&gt;/
</span><span class='line'>    int device; /&lt;/em&gt; device number &lt;em&gt;/
</span><span class='line'>    struct snd_pcm_str streams[2]; /&lt;/em&gt; 播放和录制两个数据流 &lt;em&gt;/
</span><span class='line'>    wait_queue_head_t open_wait; /&lt;/em&gt; 打开pcm设备时等待打开一个可获得的substream */
</span><span class='line'>}&lt;/p&gt;
</span><span class='line'>
</span><span class='line'>&lt;pre&gt;&lt;code&gt;struct snd_pcm_str {
</span><span class='line'>int stream;             /* stream (direction) */
</span><span class='line'>struct snd_pcm *pcm; /* 指向所属的pcm设备 */
</span><span class='line'>/* -- substreams -- */
</span><span class='line'>unsigned int substream_count; /* 个数 */
</span><span class='line'>unsigned int substream_opened; /* 在使用的个数 */
</span><span class='line'>struct snd_pcm_substream *substream; /* 指向substream单链表 */
</span><span class='line'>}
</span><span class='line'>&lt;/code&gt;&lt;/pre&gt;
</span><span class='line'>
</span><span class='line'>&lt;pre&gt;&lt;code&gt;
</span><span class='line'>文件"/proc/asound/cardX/pcmXp/info"可以查看pcm的信息。一个pcm设备包含播 放/录制两个流，每个流有若干个substream.一个substream只能被一个进程占用。 snd_pcm_substream才是真正实现音频的播放或录制的结构。
</span><span class='line'>&lt;/code&gt;&lt;/pre&gt;
</span><span class='line'>
</span><span class='line'>&lt;pre&gt;&lt;code&gt;struct snd_pcm_substream {
</span><span class='line'>struct snd_pcm *pcm;
</span><span class='line'>struct snd_pcm_str *pstr;
</span><span class='line'>void *private_data;     /* copied from pcm-&gt;private_data */
</span><span class='line'>int number;
</span><span class='line'>char name[32];          /* substream name */
</span><span class='line'>int stream;         /* stream (direction) */ /* 录制/播放 */
</span><span class='line'>struct pm_qos_request latency_pm_qos_req; /* pm_qos request */
</span><span class='line'>size_t buffer_bytes_max;    /* limit ring buffer size */
</span><span class='line'>struct snd_dma_buffer dma_buffer;
</span><span class='line'>unsigned int dma_buf_id;
</span><span class='line'>size_t dma_max;
</span><span class='line'>/* -- hardware operations -- */
</span><span class='line'>const struct snd_pcm_ops *ops;
</span><span class='line'>/* -- runtime information -- */
</span><span class='line'>struct snd_pcm_runtime *runtime;
</span><span class='line'>    /* -- timer section -- */
</span><span class='line'>struct snd_timer *timer;        /* timer */
</span><span class='line'>unsigned timer_running: 1;  /* time is running */
</span><span class='line'>/* -- next substream -- */
</span><span class='line'>struct snd_pcm_substream *next;
</span><span class='line'>/* -- linked substreams -- */
</span><span class='line'>struct list_head link_list; /* linked list member */
</span><span class='line'>struct snd_pcm_group self_group;    /* fake group for non linked substream (with substream lock inside) */
</span><span class='line'>struct snd_pcm_group *group;        /* pointer to current group */
</span><span class='line'>/* -- assigned files -- */
</span><span class='line'>void *file; /* 指向 pcm_file, 不知道有什么用？ */
</span><span class='line'>int ref_count; /* 引用计数，打开 O_APPEND 时有用 */
</span><span class='line'>atomic_t mmap_count;  /* mmap 的引用计数 */
</span><span class='line'>unsigned int f_flags; /* pcm 打开的文件标记 */
</span><span class='line'>void (*pcm_release)(struct snd_pcm_substream *);
</span><span class='line'>struct pid *pid; /* 所在进程的pid，有多个substream时用于选择使用哪个 */
</span><span class='line'>/* misc flags */
</span><span class='line'>unsigned int hw_opened: 1; /* 若已打开，在释放substream时需要调用close() */
</span><span class='line'>};
</span><span class='line'>&lt;/code&gt;&lt;/pre&gt;
</span><span class='line'>
</span><span class='line'>&lt;pre&gt;&lt;code&gt;
</span><span class='line'>文件"/proc/asound/cardX/pcmXp/subX/info"可以查看这个substream的信息。这 个结构里两个最重要的成员是runtime和ops.
</span><span class='line'>
</span><span class='line'>snd_pcm_ops是substream的操作方法集。
</span><span class='line'>&lt;/code&gt;&lt;/pre&gt;
</span><span class='line'>
</span><span class='line'>&lt;pre&gt;&lt;code&gt;struct snd_pcm_ops {
</span><span class='line'>int (*open)(struct snd_pcm_substream *substream); /* 必须实现 */
</span><span class='line'>int (*close)(struct snd_pcm_substream *substream);
</span><span class='line'>int (*ioctl)(struct snd_pcm_substream * substream,
</span><span class='line'>         unsigned int cmd, void *arg); /* 用于实现几个特定的IOCTL1_{RESET,INFO,CHANNEL_INFO,GSTATE,FIFO_SIZE} */
</span><span class='line'>int (*hw_params)(struct snd_pcm_substream *substream,
</span><span class='line'>         struct snd_pcm_hw_params *params); /* 用于设定pcm参数，如采样率/位深... */
</span><span class='line'>int (*hw_free)(struct snd_pcm_substream *substream);
</span><span class='line'>int (*prepare)(struct snd_pcm_substream *substream); /* 读写数据前的准备 */
</span><span class='line'>int (*trigger)(struct snd_pcm_substream *substream, int cmd); /* 触发硬件对数据的启动/停止 */
</span><span class='line'>snd_pcm_uframes_t (*pointer)(struct snd_pcm_substream *substream); /* 查询当前的硬件指针 */
</span><span class='line'>int (*wall_clock)(struct snd_pcm_substream *substream,
</span><span class='line'>          struct timespec *audio_ts); /* 通过hw获得audio_tstamp */
</span><span class='line'>int (*copy)(struct snd_pcm_substream *substream, int channel,
</span><span class='line'>        snd_pcm_uframes_t pos,
</span><span class='line'>        void __user *buf, snd_pcm_uframes_t count); /* 除dma外的hw自身实现的数据传输方法 */
</span><span class='line'>int (*silence)(struct snd_pcm_substream *substream, int channel,
</span><span class='line'>           snd_pcm_uframes_t pos, snd_pcm_uframes_t count); /* hw静音数据的填充方法 */
</span><span class='line'>struct page *(*page)(struct snd_pcm_substream *substream,
</span><span class='line'>             unsigned long offset); /* 硬件分配缓冲区的方法 */
</span><span class='line'>int (*mmap)(struct snd_pcm_substream *substream, struct vm_area_struct *vma); /* */
</span><span class='line'>int (*ack)(struct snd_pcm_substream *substream); /* 通知硬件写了一次数据 */
</span><span class='line'>};
</span><span class='line'>&lt;/code&gt;&lt;/pre&gt;
</span><span class='line'>
</span><span class='line'>&lt;pre&gt;&lt;code&gt;
</span><span class='line'>这些操作方法集由各种声卡如PCI,USB,SOC等子模块来实现。
</span><span class='line'>
</span><span class='line'>snd_pcm_runtime用于表示substream运行时状态。
</span><span class='line'>&lt;/code&gt;&lt;/pre&gt;
</span><span class='line'>
</span><span class='line'>&lt;pre&gt;&lt;code&gt;struct snd_pcm_runtime {
</span><span class='line'>/* -- Status -- */ /* */
</span><span class='line'>
</span><span class='line'>/* -- HW params -- */ /* 当前流的数据格式 */
</span><span class='line'>
</span><span class='line'>/* -- SW params -- */ /* 用户配置的参数如pcm_config */
</span><span class='line'>
</span><span class='line'>/* -- mmap -- */
</span><span class='line'>struct snd_pcm_mmap_status *status; /* 当前硬件指针位置及其状态 */
</span><span class='line'>struct snd_pcm_mmap_control *control; /* 当前的应用指针及其状态 */
</span><span class='line'>
</span><span class='line'>/* -- locking / scheduling -- */ /* 用于通知如数据空闲/溢出等事件 */
</span><span class='line'>
</span><span class='line'>/* -- private section -- */
</span><span class='line'>
</span><span class='line'>/* -- hardware description -- */ /* 硬件支持的参数及参数之间的约束条件 */
</span><span class='line'>
</span><span class='line'>/* -- interrupt callbacks -- */ /* HW一次中断传输完毕时的回调，似乎没有哪个模块用到它？ */
</span><span class='line'>void (*transfer_ack_begin)(struct snd_pcm_substream *substream);
</span><span class='line'>void (*transfer_ack_end)(struct snd_pcm_substream *substream);
</span><span class='line'>
</span><span class='line'>/* -- timer -- */
</span><span class='line'>
</span><span class='line'>/* -- DMA -- */
</span><span class='line'>
</span><span class='line'>struct snd_dma_buffer *dma_buffer_p;    /* allocated buffer */
</span><span class='line'>}
</span><span class='line'>&lt;/code&gt;&lt;/pre&gt;
</span><span class='line'>
</span><span class='line'>&lt;pre&gt;&lt;code&gt;
</span><span class='line'>这是相当大的一个结构体，自带的注释很明晰，就不贴它的成员了。它反映了一个 substream运行时的状态及实时信息。文件"/proc/asound/*/subX/"可以得到这个 结构的大部分信息。
</span><span class='line'>
</span><span class='line'>#### PCM的状态转换
</span><span class='line'>
</span><span class='line'>下图是PCM的状态的转换图。
</span><span class='line'>
</span><span class='line'>![](/images/kernel/2018-03-03-30.png)
</span><span class='line'>
</span><span class='line'>除XRUN状态之后，其它的状态大多都由用户空间的ioctl()显式的切换。 以TinyAlsa的播放音频流程为例。 pcm_open()的对应的流程就是：
</span><span class='line'>
</span><span class='line'>  open(pcm)后绑定一个substream，处于OPEN状态
</span><span class='line'>
</span><span class='line'>  ioctl(SNDRV_PCM_IOCTL_SW_PARAMS)设定参数pcm_config.配置 runtime 的 sw_para.切换到SETUP状态
</span><span class='line'>
</span><span class='line'>Tinyalsa的pcm_wirte()流程：
</span><span class='line'>
</span><span class='line'>  ioctl(SNDRV_PCM_IOCTL_PREPARE)后，substream切换到PREPARE状态。
</span><span class='line'>
</span><span class='line'>  ioctl(SNDRV_PCM_IOCTL_WRITEI_FRAMES)后，substream切换到RUNNING状态。
</span><span class='line'>
</span><span class='line'>TinyAlsa的pcm_mmap_write()流程：
</span><span class='line'>
</span><span class='line'>  ioctl(SNDRV_PCM_IOCTL_PREPARE)后，substream切换到PREPARE状态。
</span><span class='line'>
</span><span class='line'>  ioctl(SNDRV_PCM_IOCTL_START)后，substream切换到RUNNING状态。
</span><span class='line'>
</span><span class='line'>TinyAlsa pcm_close流程：
</span><span class='line'>
</span><span class='line'>  ioctl(SNDRV_PCM_IOCTL_DROP)后，切换回SETUP状态。
</span><span class='line'>
</span><span class='line'>  close()之后，释放这个设备。
</span><span class='line'>
</span><span class='line'>XRUN状态又分有两种，在播放时，用户空间没及时写数据导致缓冲区空了，硬件没有 可用数据播放导致UNDERRUN;录制时，用户空间没有及时读取数据导致缓冲区满后溢出， 硬件录制的数据没有空闲缓冲可写导致OVERRUN.
</span><span class='line'>
</span><span class='line'>#### 缓冲区的管理
</span><span class='line'>
</span><span class='line'>音频的缓冲区是典型的只有一个读者和一个写者的FIFO结构。 下图是ALSA中FIFO缓冲区的示意图。
</span><span class='line'>
</span><span class='line'>![](/images/kernel/2018-03-03-31.png)
</span><span class='line'>
</span><span class='line'>上图以播放时的缓冲管理为例，runtime-&gt;boundary一般都是较大的数，ALSA中默认接近 LONG_MAX/2.这样FIFO的出队入队指针不是真实的缓冲区的地址偏移，经过转换才得到 物理缓冲的偏移。这样做的好处是简化了缓冲区的管理，只有在更新hw指针的时候才需 要换算到hw_ofs.
</span><span class='line'>
</span><span class='line'>当用户空间由于系统繁忙等原因，导致hw_ptr&gt;appl_ptr时，缓冲区已空，内核这里有两种方案：
</span><span class='line'>
</span><span class='line'>  停止DMA传输，进入XRUN状态。这是内核默认的处理方法。
</span><span class='line'>
</span><span class='line'>  继续播放缓冲区的重复的音频数据或静音数据。
</span><span class='line'>
</span><span class='line'>用户空间配置stop_threshold可选择方案1或方案2,配置silence_threshold选择继 续播放的原有的音频数据还是静意数据了。个人经验，偶尔的系统繁忙导致的这种状态， 重复播放原有的音频数据会显得更平滑，效果更好。
</span><span class='line'>
</span><span class='line'>#### 实现
</span><span class='line'>
</span><span class='line'>pcm的代码让人难以理解的部分莫过于硬件指针的更新snd_pcm_update_hw_ptr0(),分 析见这里。它是将hw_ofs转换成FIFO中 hw_ptr的过程，同时处理环形缓冲区的回绕，没有中断，中断丢失等情况。
</span><span class='line'>
</span><span class='line'>还有一处就是处理根据硬件参数的约束条件得到参数的代码 snd_pcm_hw_refine(substream, params). 留待以后分析吧。
</span><span class='line'>
</span><span class='line'>#### 调试
</span><span class='line'>
</span><span class='line'>"sound/core/info.c"是alsa为proc实现的接口。这也是用户空间来调试内核alsa 最主要的方法了。打开内核配置选项 CONFIG_SND_VERBOSE_PROCFS/CONFIG_SND_PCM_XRUN_DEBUG，可看到以下的目录树。
</span><span class='line'>&lt;/code&gt;&lt;/pre&gt;
</span><span class='line'>
</span><span class='line'>&lt;pre&gt;&lt;code&gt;/proc/asound/
</span><span class='line'>|-- card0
</span><span class='line'>|   |-- id  声卡名
</span><span class='line'>|   |-- pcm0c
</span><span class='line'>|   |   |-- info pcm设备信息
</span><span class='line'>|   |   |-- sub0
</span><span class='line'>|   |   |   |-- hw_params 硬件配置参数
</span><span class='line'>|   |   |   |-- info substream设备信息
</span><span class='line'>|   |   |   |-- status 实时的hw_ptr/appl_ptr
</span><span class='line'>|   |   |   `-- sw_params  软件配置参数
</span><span class='line'>|   |   `-- xrun_debug  控制内核alsa的调试日志输出
</span><span class='line'>|   `-- pcm0p
</span><span class='line'>|-- cards 内核拥有的声卡
</span><span class='line'>|-- devices 内核所有的snd_device设备
</span><span class='line'>|-- pcm 所有的pcm设备
</span><span class='line'>`-- version alsa的版本号
</span><span class='line'>&lt;/code&gt;&lt;/pre&gt;
</span><span class='line'>
</span><span class='line'>&lt;pre&gt;&lt;code&gt;
</span><span class='line'>在ALSA播放/录制异常时，若打开xrun_debug，内核日志会实时打印更多有用的信息， 往"/proc/asound/card0/pcm0p/xrun_debug"写入相应的掩码就好了。
</span><span class='line'>&lt;/code&gt;&lt;/pre&gt;
</span><span class='line'>
</span><span class='line'>&lt;pre&gt;&lt;code&gt;#define XRUN_DEBUG_BASIC    (1&lt;&lt;0)
</span><span class='line'>#define XRUN_DEBUG_STACK    (1&lt;&lt;1)  /* dump also stack */
</span><span class='line'>#define XRUN_DEBUG_JIFFIESCHECK (1&lt;&lt;2)  /* do jiffies check */
</span><span class='line'>#define XRUN_DEBUG_PERIODUPDATE (1&lt;&lt;3)  /* full period update info */
</span><span class='line'>#define XRUN_DEBUG_HWPTRUPDATE  (1&lt;&lt;4)  /* full hwptr update info */
</span><span class='line'>#define XRUN_DEBUG_LOG      (1&lt;&lt;5)  /* show last 10 positions on err */
</span><span class='line'>#define XRUN_DEBUG_LOGONCE  (1&lt;&lt;6)  /* do above only once */
</span><span class='line'>&lt;/code&gt;&lt;/pre&gt;
</span><span class='line'>
</span><span class='line'>&lt;p&gt;```&lt;/p&gt;
</span><span class='line'>
</span><span class='line'>&lt;p&gt;相当冗长的一篇总结。与其它内核模块比起来，这部分代码似乎显得更“晦涩”，原因 之一可能就是音频流是实时的数据，而内核本身不是实时的系统，软件上不能很好的保 证hw_ptr和appl_ptr的同步。&lt;/p&gt;
</span><span class='line'>]]&gt;&lt;/content&gt;
</span><span class='line'>  &lt;/entry&gt;
</span><span class='line'>  
</span><span class='line'>  &lt;entry&gt;
</span><span class='line'>&lt;title type="html"&gt;&lt;![CDATA[Linux ALSA 系统架构]]&gt;&lt;/title&gt;
</span><span class='line'>&lt;link href="http://abcdxyzk.github.io/blog/2018/03/03/kernel-alsa-2/"/&gt;
</span><span class='line'>&lt;updated&gt;2018-03-03T18:22:00+08:00&lt;/updated&gt;
</span><span class='line'>&lt;id&gt;http://abcdxyzk.github.io/blog/2018/03/03/kernel-alsa-2&lt;/id&gt;
</span><span class='line'>&lt;content type="html"&gt;&lt;![CDATA[&lt;p&gt;&lt;a href="https://www.linuxidc.com/Linux/2012-07/65903.htm"&gt;https://www.linuxidc.com/Linux/2012-07/65903.htm&lt;/a&gt;&lt;/p&gt;
</span><span class='line'>
</span><span class='line'>&lt;p&gt;ALSA是Linux声卡驱动的架构，下面基于linux-2.6.32描述下ALSA系统架构。ALSA系统可以分为alsa-lib、alsa-driver，而alsa-driver又分为core层和底层硬件层。作为开发者，我们只需移植底层硬件层，根据自己硬件特性，实现底层的移植。而core层基本属于ALSA标准框架，不需要自己实现。介绍ALSA框架，下面是大体框架图。&lt;/p&gt;
</span><span class='line'>
</span><span class='line'>&lt;p&gt;&lt;img src="/images/kernel/2018-03-03-21.png" alt="" /&gt;&lt;/p&gt;
</span><span class='line'>
</span><span class='line'>&lt;p&gt;如上图所示，alsa驱动最终会被上层应用调用，这是通过alsa-lib实现的，alsa-lib为alsa-driver封装了许多API，通过这些API，上层应用可以调用到驱动层。而alsa-lib中的这些API，我们可暂时把他们当做一个黑盒子，里面具体实现不需要去关注，下面以linux-2.6.32中ALSA调用函数关系说明其架构。先分析ALSA驱动的注册过程。&lt;/p&gt;
</span><span class='line'>
</span><span class='line'>&lt;h4&gt;一、ALSA驱动的注册&lt;/h4&gt;
</span><span class='line'>
</span><span class='line'>&lt;p&gt;&lt;img src="/images/kernel/2018-03-03-21.png" alt="" /&gt;&lt;/p&gt;
</span><span class='line'>
</span><span class='line'>&lt;p&gt;注册流程查看上图，具体的注册过程不在此赘述。&lt;/p&gt;
</span><span class='line'>
</span><span class='line'>&lt;p&gt;二、打开流程&lt;/p&gt;
</span><span class='line'>
</span><span class='line'>&lt;p&gt;在ALSA驱动注册完毕以后，当应用程序开始调用时，会有一个过程：打开设备、映射、设置硬件参数、准备工作、触发数据流。下图为整个流程。&lt;/p&gt;
</span><span class='line'>
</span><span class='line'>&lt;p&gt;&lt;img src="/images/kernel/2018-03-03-22.png" alt="" /&gt;&lt;/p&gt;
</span><span class='line'>
</span><span class='line'>&lt;p&gt;带sep0611的是需要自己实现的底层驱动。&lt;/p&gt;
</span><span class='line'>
</span><span class='line'>&lt;p&gt;三、写数据流程&lt;/p&gt;
</span><span class='line'>
</span><span class='line'>&lt;p&gt;&lt;img src="/images/kernel/2018-03-03-23.png" alt="" /&gt;&lt;/p&gt;
</span><span class='line'>
</span><span class='line'>&lt;p&gt;图中应用程序通过ALSA-lib的API函数写入数据，ALSA-lib调用等待函数等待底层可写。ALSA-lib通过poll系统调用进入底层驱动并将poll信号加入sleep队列阻塞进程。硬件的中断信号触发底层驱动注册的中断处理函数，中断处理函数进而调用ALSA-driver中的函数判读是否该写。ALSA-driver中的函数再调用底层芯片硬件驱动获取硬件当前数据大小。ALSA-driver再判断空闲数据区的大小，如果满足条件就唤醒sleep队列，poll信号从而被唤醒，进而返回给ALSA-lib，ALSA-lib收到信号后再执行往buffer里写数据。
</span><span class='line'>ALSA-lib通过mmap机制将硬件申请的内存映射到用户空间，从而应用程序只需调用ALSA-lib往相应位置写数据，硬件就可以直接读取了。如果映射内存里已有数据，通过DMA传输给codec，codec便开始读取数据并进行解码播放声音了。&lt;/p&gt;
</span><span class='line'>
</span><span class='line'>&lt;p&gt;&lt;a href="http://blog.chinaunix.net/uid-20564848-id-74726.html"&gt;http://blog.chinaunix.net/uid-20564848-id-74726.html&lt;/a&gt;&lt;/p&gt;
</span><span class='line'>
</span><span class='line'>&lt;p&gt;&lt;a href="https://my.oschina.net/abcijkxyz/blog/788796"&gt;https://my.oschina.net/abcijkxyz/blog/788796&lt;/a&gt;&lt;/p&gt;
</span><span class='line'>]]&gt;&lt;/content&gt;
</span><span class='line'>  &lt;/entry&gt;
</span><span class='line'>  
</span><span class='line'>  &lt;entry&gt;
</span><span class='line'>&lt;title type="html"&gt;&lt;![CDATA[alsa架构分析]]&gt;&lt;/title&gt;
</span><span class='line'>&lt;link href="http://abcdxyzk.github.io/blog/2018/03/03/kernel-alsa-1/"/&gt;
</span><span class='line'>&lt;updated&gt;2018-03-03T17:35:00+08:00&lt;/updated&gt;
</span><span class='line'>&lt;id&gt;http://abcdxyzk.github.io/blog/2018/03/03/kernel-alsa-1&lt;/id&gt;
</span><span class='line'>&lt;content type="html"&gt;&lt;![CDATA[&lt;p&gt;&lt;a href="http://blog.csdn.net/poltroon/article/details/7978304"&gt;http://blog.csdn.net/poltroon/article/details/7978304&lt;/a&gt;&lt;/p&gt;
</span><span class='line'>
</span><span class='line'>&lt;p&gt;&lt;a href="http://blog.csdn.net/droidphone/article/category/1118446"&gt;http://blog.csdn.net/droidphone/article/category/1118446&lt;/a&gt;&lt;/p&gt;
</span><span class='line'>
</span><span class='line'>&lt;h2&gt;Linux ALSA声卡驱动之一：ALSA架构简介&lt;/h2&gt;
</span><span class='line'>
</span><span class='line'>&lt;h4&gt;一.  概述&lt;/h4&gt;
</span><span class='line'>
</span><span class='line'>&lt;p&gt;  ALSA是Advanced Linux Sound Architecture 的缩写，目前已经成为了linux的主流音频体系结构，想了解更多的关于ALSA的这一开源项目的信息和知识，请查看以下网址：&lt;a href="http://www.alsa-project.org/%E3%80%82"&gt;http://www.alsa-project.org/%E3%80%82&lt;/a&gt;&lt;/p&gt;
</span><span class='line'>
</span><span class='line'>&lt;p&gt;  在内核设备驱动层，ALSA提供了alsa-driver，同时在应用层，ALSA为我们提供了alsa-lib，应用程序只要调用alsa-lib提供的API，即可以完成对底层音频硬件的控制。&lt;/p&gt;
</span><span class='line'>
</span><span class='line'>&lt;p&gt;&lt;img src="/images/kernel/2018-03-03-2.png" alt="" /&gt;&lt;br/&gt;
</span><span class='line'>                                        图 1.1   alsa的软件体系结构&lt;/p&gt;
</span><span class='line'>
</span><span class='line'>&lt;p&gt;由图1.1可以看出，用户空间的alsa-lib对应用程序提供统一的API接口，这样可以隐藏了驱动层的实现细节，简化了应用程序的实现难度。内核空间中，alsa-soc其实是对alsa-driver的进一步封装，他针对嵌入式设备提供了一些列增强的功能。本系列博文仅对嵌入式系统中的alsa-driver和alsa-soc进行讨论。&lt;/p&gt;
</span><span class='line'>
</span><span class='line'>&lt;h4&gt;二.  ALSA设备文件结构&lt;/h4&gt;
</span><span class='line'>
</span><span class='line'>&lt;p&gt;  我们从alsa在linux中的设备文件结构开始我们的alsa之旅. 看看我的电脑中的alsa驱动的设备文件结构:&lt;/p&gt;
</span><span class='line'>
</span><span class='line'>&lt;pre&gt;&lt;code&gt;    $ cd /dev/snd
</span><span class='line'>$ ls -l
</span><span class='line'>
</span><span class='line'>crw-rw----+ 1 root audio 116, 8 2011-02-23 21:38 controlC0
</span><span class='line'>crw-rw----+ 1 root audio 116, 4 2011-02-23 21:38 midiC0D0
</span><span class='line'>crw-rw----+ 1 root audio 116, 7 2011-02-23 21:39 pcmC0D0c
</span><span class='line'>crw-rw----+ 1 root audio 116, 6 2011-02-23 21:56 pcmC0D0p
</span><span class='line'>crw-rw----+ 1 root audio 116, 5 2011-02-23 21:38 pcmC0D1p
</span><span class='line'>crw-rw----+ 1 root audio 116, 3 2011-02-23 21:38 seq
</span><span class='line'>crw-rw----+ 1 root audio 116, 2 2011-02-23 21:38 timer
</span><span class='line'>&lt;/code&gt;&lt;/pre&gt;
</span><span class='line'>
</span><span class='line'>&lt;p&gt;我们可以看到以下设备文件:
</span><span class='line'>&lt;code&gt;
</span><span class='line'>controlC0 --&gt;               用于声卡的控制，例如通道选择，混音，麦克风的控制等
</span><span class='line'>midiC0D0  --&gt;               用于播放midi音频
</span><span class='line'>pcmC0D0c  --&gt;               用于录音的pcm设备
</span><span class='line'>pcmC0D0p  --&gt;               用于播放的pcm设备
</span><span class='line'>seq       --&gt;               音序器
</span><span class='line'>timer     --&gt;               定时器
</span><span class='line'>&lt;/code&gt;&lt;/p&gt;
</span><span class='line'>
</span><span class='line'>&lt;p&gt;其中，C0D0代表的是声卡0中的设备0，pcmC0D0c最后一个c代表capture，pcmC0D0p最后一个p代表playback，这些都是alsa-driver中的命名规则。从上面的列表可以看出，我的声卡下挂了6个设备，根据声卡的实际能力，驱动实际上可以挂上更多种类的设备，在include/sound/core.h中，定义了以下设备类型：&lt;/p&gt;
</span><span class='line'>
</span><span class='line'>&lt;pre&gt;&lt;code&gt;    #define SNDRV_DEV_TOPLEVEL  ((__force snd_device_type_t) 0)
</span><span class='line'>#define SNDRV_DEV_CONTROL   ((__force snd_device_type_t) 1)
</span><span class='line'>#define SNDRV_DEV_LOWLEVEL_PRE  ((__force snd_device_type_t) 2)
</span><span class='line'>#define SNDRV_DEV_LOWLEVEL_NORMAL ((__force snd_device_type_t) 0x1000)
</span><span class='line'>#define SNDRV_DEV_PCM       ((__force snd_device_type_t) 0x1001)
</span><span class='line'>#define SNDRV_DEV_RAWMIDI   ((__force snd_device_type_t) 0x1002)
</span><span class='line'>#define SNDRV_DEV_TIMER     ((__force snd_device_type_t) 0x1003)
</span><span class='line'>#define SNDRV_DEV_SEQUENCER ((__force snd_device_type_t) 0x1004)
</span><span class='line'>#define SNDRV_DEV_HWDEP     ((__force snd_device_type_t) 0x1005)
</span><span class='line'>#define SNDRV_DEV_INFO      ((__force snd_device_type_t) 0x1006)
</span><span class='line'>#define SNDRV_DEV_BUS       ((__force snd_device_type_t) 0x1007)
</span><span class='line'>#define SNDRV_DEV_CODEC     ((__force snd_device_type_t) 0x1008)
</span><span class='line'>#define SNDRV_DEV_JACK          ((__force snd_device_type_t) 0x1009)
</span><span class='line'>#define SNDRV_DEV_LOWLEVEL  ((__force snd_device_type_t) 0x2000)
</span><span class='line'>&lt;/code&gt;&lt;/pre&gt;
</span><span class='line'>
</span><span class='line'>&lt;p&gt; 通常，我们更关心的是pcm和control这两种设备。&lt;/p&gt;
</span><span class='line'>
</span><span class='line'>&lt;h4&gt;三.  驱动的代码文件结构&lt;/h4&gt;
</span><span class='line'>
</span><span class='line'>&lt;p&gt;  在Linux2.6代码树中，Alsa的代码文件结构如下：</span></code></pre></td></tr></table></div></figure>
    sound
            /core
                     /oss
                    /seq
            /ioctl32
            /include
            /drivers
            /i2c
            /synth
                    /emux
            /pci
                    /(cards)
            /isa
                    /(cards)
            /arm
            /ppc
            /sparc
            /usb
            /pcmcia /(cards)
            /oss
            /soc
                    /codecs</p>

<pre><code>core            该目录包含了ALSA驱动的中间层，它是整个ALSA驱动的核心部分
core/oss        包含模拟旧的OSS架构的PCM和Mixer模块
core/seq        有关音序器相关的代码
include         ALSA驱动的公共头文件目录，该目录的头文件需要导出给用户空间的应用程序使用，通常，驱动模块私有的头文件不应放置在这里
drivers         放置一些与CPU、BUS架构无关的公用代码
i2c             ALSA自己的I2C控制代码
pci             pci声卡的顶层目录，子目录包含各种pci声卡的代码
isa             isa声卡的顶层目录，子目录包含各种isa声卡的代码
soc             针对system-on-chip体系的中间层代码
soc/codecs      针对soc体系的各种codec的代码，与平台无关
</code></pre>

<pre><code>
## Linux ALSA声卡驱动之二：声卡的创建

#### 1. struct snd_card

##### 1.1. snd_card是什么

snd_card可以说是整个ALSA音频驱动最顶层的一个结构，整个声卡的软件逻辑结构开始于该结构，几乎所有与声音相关的逻辑设备都是在snd_card的管理之下，声卡驱动的第一个动作通常就是创建一个snd_card结构体。正因为如此，本节中，我们也从 struct cnd_card开始吧。

##### 1.2. snd_card的定义

snd_card的定义位于改头文件中：include/sound/core.h
</code></pre>

<pre><code>/* main structure for soundcard */

struct snd_card {
    int number;         /* number of soundcard (index to
                                snd_cards) */

    char id[16];            /* id string of this card */
    char driver[16];        /* driver name */
    char shortname[32];     /* short name of this soundcard */
    char longname[80];      /* name of this soundcard */
    char mixername[80];     /* mixer name */
    char components[128];       /* card components delimited with
                                space */
    struct module *module;      /* top-level module */

    void *private_data;     /* private data for soundcard */
    void (*private_free) (struct snd_card *card); /* callback for freeing of
                                private data */
    struct list_head devices;   /* devices */

    unsigned int last_numid;    /* last used numeric ID */
    struct rw_semaphore controls_rwsem; /* controls list lock */
    rwlock_t ctl_files_rwlock;  /* ctl_files list lock */
    int controls_count;     /* count of all controls */
    int user_ctl_count;     /* count of all user controls */
    struct list_head controls;  /* all controls for this card */
    struct list_head ctl_files; /* active control files */

    struct snd_info_entry *proc_root;   /* root for soundcard specific files */
    struct snd_info_entry *proc_id; /* the card id */
    struct proc_dir_entry *proc_root_link;  /* number link to real id */

    struct list_head files_list;    /* all files associated to this card */
    struct snd_shutdown_f_ops *s_f_ops; /* file operations in the shutdown
                                state */
    spinlock_t files_lock;      /* lock the files for this card */
    int shutdown;           /* this card is going down */
    int free_on_last_close;     /* free in context of file_release */
    wait_queue_head_t shutdown_sleep;
    struct device *dev;     /* device assigned to this card */
#ifndef CONFIG_SYSFS_DEPRECATED
    struct device *card_dev;    /* cardX object for sysfs */
#endif
#ifdef CONFIG_PM
    unsigned int power_state;   /* power state */
    struct mutex power_lock;    /* power lock */
    wait_queue_head_t power_sleep;
#endif
#if defined(CONFIG_SND_MIXER_OSS) || defined(CONFIG_SND_MIXER_OSS_MODULE)
    struct snd_mixer_oss *mixer_oss;
    int mixer_oss_change_count;
#endif
};

struct list_head devices     记录该声卡下所有逻辑设备的链表
struct list_head controls    记录该声卡下所有的控制单元的链表
void *private_data           声卡的私有数据，可以在创建声卡时通过参数指定数据的大小
</code></pre>

<pre><code>
#### 2. 声卡的建立流程

##### 2.1.1. 第一步，创建snd_card的一个实例
</code></pre>

<pre><code>int err;
....
err = snd_card_create(index, id, THIS_MODULE, 0, &amp;card);

index           一个整数值，该声卡的编号
id                字符串，声卡的标识符
第四个参数    该参数决定在创建snd_card实例时，需要同时额外分配的私有数据的大小，该数据的指针最终会赋值给snd_card的private_data数据成员
card             返回所创建的snd_card实例的指针
</code></pre>

<pre><code>
##### 2.1.2. 第二步，创建声卡的芯片专用数据

声卡的专用数据主要用于存放该声卡的一些资源信息，例如中断资源、io资源、dma资源等。可以有两种创建方法：

  通过上一步中snd_card_create()中的第四个参数，让snd_card_create自己创建
</code></pre>

<pre><code>// struct mychip 用于保存专用数据
err = snd_card_create(index, id, THIS_MODULE,
                sizeof(struct mychip), &amp;card);
// 从private_data中取出
struct mychip *chip = card-&gt;private_data;
</code></pre>

<pre><code>
  自己创建：
</code></pre>

<pre><code>struct mychip {
    struct snd_card *card;
    ....
};
struct snd_card *card;
struct mychip *chip;
err = snd_card_create(index[dev], id[dev], THIS_MODULE, 0, &amp;card);
// 专用数据记录snd_card实例
chip-&gt;card = card;
.....
chip = kzalloc(sizeof(*chip), GFP_KERNEL);
</code></pre>

<pre><code>
然后，把芯片的专有数据注册为声卡的一个低阶设备：
</code></pre>

<pre><code>static int snd_mychip_dev_free(struct snd_device *device)
{
    return snd_mychip_free(device-&gt;device_data);
}

static struct snd_device_ops ops = {
    .dev_free = snd_mychip_dev_free,
};
....
snd_device_new(card, SNDRV_DEV_LOWLEVEL, chip, &amp;ops);
</code></pre>

<pre><code>
##### 2.1.3. 第三步，设置Driver的ID和名字
</code></pre>

<pre><code>strcpy(card-&gt;driver, "My Chip");
strcpy(card-&gt;shortname, "My Own Chip 123");
sprintf(card-&gt;longname, "%s at 0x%lx irq %i",
            card-&gt;shortname, chip-&gt;ioport, chip-&gt;irq);
</code></pre>

<pre><code>
snd_card的driver字段保存着芯片的ID字符串，user空间的alsa-lib会使用到该字符串，所以必须要保证该ID的唯一性。shortname字段更多地用于打印信息，longname字段则会出现在/proc/asound/cards中。

##### 2.1.4. 第四步，创建声卡的功能部件（逻辑设备），例如PCM，Mixer，MIDI等

这时候可以创建声卡的各种功能部件了，还记得开头的snd_card结构体的devices字段吗？每一种部件的创建最终会调用snd_device_new()来生成一个snd_device实例，并把该实例链接到snd_card的devices链表中。

通常，alsa-driver的已经提供了一些常用的部件的创建函数，而不必直接调用snd_device_new()，比如：
</code></pre>

<pre><code>PCM     --        snd_pcm_new()
RAWMIDI --        snd_rawmidi_new()
CONTROL --        snd_ctl_create()
TIMER   --        snd_timer_new()
INFO    --        snd_card_proc_new()
JACK    --        snd_jack_new()
</code></pre>

<pre><code>
##### 2.1.5. 第五步，注册声卡
</code></pre>

<pre><code>err = snd_card_register(card);
if (err &lt; 0) {
    snd_card_free(card);
    return err;
}
</code></pre>

<pre><code>
#### 2.2. 一个实际的例子

我把/sound/arm/pxa2xx-ac97.c的部分代码贴上来：
</code></pre>

<pre><code>static int __devinit pxa2xx_ac97_probe(struct platform_device *dev)
{
    struct snd_card *card;
    struct snd_ac97_bus *ac97_bus;
    struct snd_ac97_template ac97_template;
    int ret;
    pxa2xx_audio_ops_t *pdata = dev-&gt;dev.platform_data;

    if (dev-&gt;id &gt;= 0) {
        dev_err(&amp;dev-&gt;dev, "PXA2xx has only one AC97 port./n");
        ret = -ENXIO;
        goto err_dev;
    }
////(1)////
    ret = snd_card_create(SNDRV_DEFAULT_IDX1, SNDRV_DEFAULT_STR1,
                  THIS_MODULE, 0, &amp;card);
    if (ret &lt; 0)
        goto err;

    card-&gt;dev = &amp;dev-&gt;dev;
////(3)////
    strncpy(card-&gt;driver, dev-&gt;dev.driver-&gt;name, sizeof(card-&gt;driver));

////(4)////
    ret = pxa2xx_pcm_new(card, &amp;pxa2xx_ac97_pcm_client, &amp;pxa2xx_ac97_pcm);
    if (ret)
        goto err;
////(2)////
    ret = pxa2xx_ac97_hw_probe(dev);
    if (ret)
        goto err;

////(4)////
    ret = snd_ac97_bus(card, 0, &amp;pxa2xx_ac97_ops, NULL, &amp;ac97_bus);
    if (ret)
        goto err_remove;
    memset(&amp;ac97_template, 0, sizeof(ac97_template));
    ret = snd_ac97_mixer(ac97_bus, &amp;ac97_template, &amp;pxa2xx_ac97_ac97);
    if (ret)
        goto err_remove;
////(3)////
    snprintf(card-&gt;shortname, sizeof(card-&gt;shortname),
         "%s", snd_ac97_get_short_name(pxa2xx_ac97_ac97));
    snprintf(card-&gt;longname, sizeof(card-&gt;longname),
         "%s (%s)", dev-&gt;dev.driver-&gt;name, card-&gt;mixername);

    if (pdata &amp;&amp; pdata-&gt;codec_pdata[0])
        snd_ac97_dev_add_pdata(ac97_bus-&gt;codec[0], pdata-&gt;codec_pdata[0]);
    snd_card_set_dev(card, &amp;dev-&gt;dev);
////(5)////
    ret = snd_card_register(card);
    if (ret == 0) {
        platform_set_drvdata(dev, card);
        return 0;
    }

err_remove:
    pxa2xx_ac97_hw_remove(dev);
err:
    if (card)
        snd_card_free(card);
err_dev:
    return ret;
}

static int __devexit pxa2xx_ac97_remove(struct platform_device *dev)
{
    struct snd_card *card = platform_get_drvdata(dev);

    if (card) {
        snd_card_free(card);
        platform_set_drvdata(dev, NULL);
        pxa2xx_ac97_hw_remove(dev);
    }

    return 0;
}

static struct platform_driver pxa2xx_ac97_driver = {
    .probe      = pxa2xx_ac97_probe,
    .remove     = __devexit_p(pxa2xx_ac97_remove),
    .driver     = {
        .name   = "pxa2xx-ac97",
        .owner  = THIS_MODULE,
#ifdef CONFIG_PM
        .pm = &amp;pxa2xx_ac97_pm_ops,
#endif
    },
};

static int __init pxa2xx_ac97_init(void)
{
    return platform_driver_register(&amp;pxa2xx_ac97_driver);
}

static void __exit pxa2xx_ac97_exit(void)
{
    platform_driver_unregister(&amp;pxa2xx_ac97_driver);
}

module_init(pxa2xx_ac97_init);
module_exit(pxa2xx_ac97_exit);

MODULE_AUTHOR("Nicolas Pitre");
MODULE_DESCRIPTION("AC97 driver for the Intel PXA2xx chip");
</code></pre>

<pre><code>
驱动程序通常由probe回调函数开始，对一下2.1中的步骤，是否有相似之处？

经过以上的创建步骤之后，声卡的逻辑结构如下图所示：

![](/images/kernel/2018-03-03-3.png)  
                                     图 2.2.1  声卡的软件逻辑结构


下面的章节里我们分别讨论一下snd_card_create()和snd_card_register()这两个函数。

#### 3. snd_card_create()

 snd_card_create()在/sound/core/init.c中定义。
</code></pre>

<pre><code>/**
 *  snd_card_create - create and initialize a soundcard structure
 *  @idx: card index (address) [0 ... (SNDRV_CARDS-1)]
 *  @xid: card identification (ASCII string)
 *  @module: top level module for locking
 *  @extra_size: allocate this extra size after the main soundcard structure
 *  @card_ret: the pointer to store the created card instance
 *
 *  Creates and initializes a soundcard structure.
 *
 *  The function allocates snd_card instance via kzalloc with the given
 *  space for the driver to use freely.  The allocated struct is stored
 *  in the given card_ret pointer.
 *
 *  Returns zero if successful or a negative error code.
 */
int snd_card_create(int idx, const char *xid,
            struct module *module, int extra_size,
            struct snd_card **card_ret)
</code></pre>

<pre><code>
首先，根据extra_size参数的大小分配内存，该内存区可以作为芯片的专有数据使用（见前面的介绍）：
</code></pre>

<pre><code>card = kzalloc(sizeof(*card) + extra_size, GFP_KERNEL);
if (!card)
    return -ENOMEM;
</code></pre>

<pre><code>
拷贝声卡的ID字符串：
</code></pre>

<pre><code>if (xid)
    strlcpy(card-&gt;id, xid, sizeof(card-&gt;id));
</code></pre>

<pre><code>
如果传入的声卡编号为-1，自动分配一个索引编号：
</code></pre>

<pre><code>if (idx &lt; 0) {
    for (idx2 = 0; idx2 &lt; SNDRV_CARDS; idx2++)
        /* idx == -1 == 0xffff means: take any free slot */
        if (~snd_cards_lock &amp; idx &amp; 1&lt;&lt;idx2) {
            if (module_slot_match(module, idx2)) {
                idx = idx2;
                break;
            }
        }
}
if (idx &lt; 0) {
    for (idx2 = 0; idx2 &lt; SNDRV_CARDS; idx2++)
        /* idx == -1 == 0xffff means: take any free slot */
        if (~snd_cards_lock &amp; idx &amp; 1&lt;&lt;idx2) {
            if (!slots[idx2] || !*slots[idx2]) {
                idx = idx2;
                break;
            }
        }
}
</code></pre>

<pre><code>
初始化snd_card结构中必要的字段：
</code></pre>

<pre><code>    card-&gt;number = idx;
    card-&gt;module = module;
    INIT_LIST_HEAD(&amp;card-&gt;devices);
    init_rwsem(&amp;card-&gt;controls_rwsem);
    rwlock_init(&amp;card-&gt;ctl_files_rwlock);
    INIT_LIST_HEAD(&amp;card-&gt;controls);
    INIT_LIST_HEAD(&amp;card-&gt;ctl_files);
    spin_lock_init(&amp;card-&gt;files_lock);
    INIT_LIST_HEAD(&amp;card-&gt;files_list);
    init_waitqueue_head(&amp;card-&gt;shutdown_sleep);
#ifdef CONFIG_PM
    mutex_init(&amp;card-&gt;power_lock);
    init_waitqueue_head(&amp;card-&gt;power_sleep);
#endif
</code></pre>

<pre><code>
建立逻辑设备：Control
</code></pre>

<pre><code>/* the control interface cannot be accessed from the user space until */
/* snd_cards_bitmask and snd_cards are set with snd_card_register */
err = snd_ctl_create(card);
</code></pre>

<pre><code>
建立proc文件中的info节点：通常就是/proc/asound/card0
</code></pre>

<pre><code>err = snd_info_card_create(card);
</code></pre>

<pre><code>
把第一步分配的内存指针放入private_data字段中：
</code></pre>

<pre><code>if (extra_size &gt; 0)
    card-&gt;private_data = (char *)card + sizeof(struct snd_card);
</code></pre>

<pre><code>
#### 4. snd_card_register()

  snd_card_create()在/sound/core/init.c中定义。
</code></pre>

<pre><code>/**
 *  snd_card_register - register the soundcard
 *  @card: soundcard structure
 *
 *  This function registers all the devices assigned to the soundcard.
 *  Until calling this, the ALSA control interface is blocked from the
 *  external accesses.  Thus, you should call this function at the end
 *  of the initialization of the card.
 *
 *  Returns zero otherwise a negative error code if the registrain failed.
 */
int snd_card_register(struct snd_card *card)
</code></pre>

<pre><code>
首先，创建sysfs下的设备：
</code></pre>

<pre><code>if (!card-&gt;card_dev) {
    card-&gt;card_dev = device_create(sound_class, card-&gt;dev,
                       MKDEV(0, 0), card,
                       "card%i", card-&gt;number);
    if (IS_ERR(card-&gt;card_dev))
        card-&gt;card_dev = NULL;
}
</code></pre>

<pre><code>
其中，sound_class是在/sound/sound_core.c中创建的：
</code></pre>

<pre><code>static char *sound_devnode(struct device *dev, mode_t *mode)
{
    if (MAJOR(dev-&gt;devt) == SOUND_MAJOR)
        return NULL;
    return kasprintf(GFP_KERNEL, "snd/%s", dev_name(dev));
}
static int __init init_soundcore(void)
{
    int rc;

    rc = init_oss_soundcore();
    if (rc)
        return rc;

    sound_class = class_create(THIS_MODULE, "sound");
    if (IS_ERR(sound_class)) {
        cleanup_oss_soundcore();
        return PTR_ERR(sound_class);
    }

    sound_class-&gt;devnode = sound_devnode;

    return 0;
}
</code></pre>

<pre><code>
由此可见，声卡的class将会出现在文件系统的/sys/class/sound/下面，并且，sound_devnode()也决定了相应的设备节点也将会出现在/dev/snd/下面。

接下来的步骤，通过snd_device_register_all()注册所有挂在该声卡下的逻辑设备，snd_device_register_all()实际上是通过snd_card的devices链表，遍历所有的snd_device，并且调用snd_device的ops-&gt;dev_register()来实现各自设备的注册的。
</code></pre>

<pre><code>if ((err = snd_device_register_all(card)) &lt; 0)
    return err;
</code></pre>

<pre><code>
最后就是建立一些相应的proc和sysfs下的文件或属性节点，代码就不贴了。

至此，整个声卡完成了建立过程


## Linux ALSA声卡驱动之三：PCM设备的创建

#### 1. PCM是什么

PCM是英文Pulse-code modulation的缩写，中文译名是脉冲编码调制。我们知道在现实生活中，人耳听到的声音是模拟信号，PCM就是要把声音从模拟转换成数字信号的一种技术，他的原理简单地说就是利用一个固定的频率对模拟信号进行采样，采样后的信号在波形上看就像一串连续的幅值不一的脉冲，把这些脉冲的幅值按一定的精度进行量化，这些量化后的数值被连续地输出、传输、处理或记录到存储介质中，所有这些组成了数字音频的产生过程。

![](/images/kernel/2018-03-03-4.png)  
                                    图1.1  模拟音频的采样、量化


PCM信号的两个重要指标是采样频率和量化精度，目前，CD音频的采样频率通常为44100Hz，量化精度是16bit。通常，播放音乐时，应用程序从存储介质中读取音频数据（MP3、WMA、AAC......），经过解码后，最终送到音频驱动程序中的就是PCM数据，反过来，在录音时，音频驱动不停地把采样所得的PCM数据送回给应用程序，由应用程序完成压缩、存储等任务。所以，音频驱动的两大核心任务就是：

  playback    如何把用户空间的应用程序发过来的PCM数据，转化为人耳可以辨别的模拟音频

  capture     把mic拾取到得模拟信号，经过采样、量化，转换为PCM信号送回给用户空间的应用程序

#### 2. alsa-driver中的PCM中间层

ALSA已经为我们实现了功能强劲的PCM中间层，自己的驱动中只要实现一些底层的需要访问硬件的函数即可。

要访问PCM的中间层代码，你首先要包含头文件&lt;sound/pcm.h&gt;，另外，如果需要访问一些与 hw_param相关的函数，可能也要包含&lt;sound/pcm_params.h&gt;。

每个声卡最多可以包含4个pcm的实例，每个pcm实例对应一个pcm设备文件。pcm实例数量的这种限制源于linux设备号所占用的位大小，如果以后使用64位的设备号，我们将可以创建更多的pcm实例。不过大多数情况下，在嵌入式设备中，一个pcm实例已经足够了。

一个pcm实例由一个playback stream和一个capture stream组成，这两个stream又分别有一个或多个substreams组成。

![](/images/kernel/2018-03-03-5.png)  
                                  图2.1  声卡中的pcm结构

在嵌入式系统中，通常不会像图2.1中这么复杂，大多数情况下是一个声卡，一个pcm实例，pcm下面有一个playback和capture stream，playback和capture下面各自有一个substream。

 下面一张图列出了pcm中间层几个重要的结构，他可以让我们从uml的角度看一看这列结构的关系，理清他们之间的关系，对我们理解pcm中间层的实现方式。

![](/images/kernel/2018-03-03-6.png)  
                                  图2.2  pcm中间层的几个重要的结构体的关系图

  snd_pcm是挂在snd_card下面的一个snd_device

  snd_pcm中的字段：streams[2]，该数组中的两个元素指向两个snd_pcm_str结构，分别代表playback stream和capture stream

  snd_pcm_str中的substream字段，指向snd_pcm_substream结构

  snd_pcm_substream是pcm中间层的核心，绝大部分任务都是在substream中处理，尤其是他的ops（snd_pcm_ops）字段，许多user空间的应用程序通过alsa-lib对驱动程序的请求都是由该结构中的函数处理。它的runtime字段则指向snd_pcm_runtime结构，snd_pcm_runtime记录这substream的一些重要的软件和硬件运行环境和参数。

#### 3. 新建一个pcm

alsa-driver的中间层已经为我们提供了新建pcm的api：
</code></pre>

<pre><code>    int snd_pcm_new(struct snd_card *card, const char *id, int device, int playback_count, int capture_count,
                                 struct snd_pcm ** rpcm);
</code></pre>

<pre><code>
参数device 表示目前创建的是该声卡下的第几个pcm，第一个pcm设备从0开始。

参数playback_count 表示该pcm将会有几个playback substream。

参数capture_count 表示该pcm将会有几个capture substream。

另一个用于设置pcm操作函数接口的api：
</code></pre>

<pre><code>    void snd_pcm_set_ops(struct snd_pcm *pcm, int direction, struct snd_pcm_ops *ops);
</code></pre>

<pre><code>
新建一个pcm可以用下面一张新建pcm的调用的序列图进行描述：

![](/images/kernel/2018-03-03-7.png)  
                                      图3.1 新建pcm的序列图

  snd_card_create    pcm是声卡下的一个设备（部件），所以第一步是要创建一个声卡

  snd_pcm_new    调用该api创建一个pcm，才该api中会做以下事情
   如果有，建立playback stream，相应的substream也同时建立
   如果有，建立capture stream，相应的substream也同时建立
   调用snd_device_new()把该pcm挂到声卡中，参数ops中的dev_register字段指向了函数snd_pcm_dev_register，这个回调函数会在声卡的注册阶段被调用。

  snd_pcm_set_ops    设置操作该pcm的控制/操作接口函数，参数中的snd_pcm_ops结构中的函数通常就是我们驱动要实现的函数

  snd_card_register    注册声卡，在这个阶段会遍历声卡下的所有逻辑设备，并且调用各设备的注册回调函数，对于pcm，就是第二步提到的snd_pcm_dev_register函数，该回调函数建立了和用户空间应用程序（alsa-lib）通信所用的设备文件节点:/dev/snd/pcmCxxDxxp和/dev/snd/pcmCxxDxxc

#### 4. 设备文件节点的建立（dev/snd/pcmCxxDxxp、pcmCxxDxxc） 4.1 struct snd_minor

每个snd_minor结构体保存了声卡下某个逻辑设备的上下文信息，他在逻辑设备建立阶段被填充，在逻辑设备被使用时就可以从该结构体中得到相应的信息。pcm设备也不例外，也需要使用该结构体。该结构体在include/sound/core.h中定义。
</code></pre>

<pre><code>struct snd_minor {
    int type;           /* SNDRV_DEVICE_TYPE_XXX */
    int card;           /* card number */
    int device;         /* device number */
    const struct file_operations *f_ops;    /* file operations */
    void *private_data;     /* private data for f_ops-&gt;open */
    struct device *dev;     /* device for sysfs */
};
</code></pre>

<pre><code>
在sound/sound.c中定义了一个snd_minor指针的全局数组：
</code></pre>

<pre><code>static struct snd_minor *snd_minors[256];
</code></pre>

<pre><code>
前面说过，在声卡的注册阶段（snd_card_register），会调用pcm的回调函数snd_pcm_dev_register()，这个函数里会调用函数snd_register_device_for_dev()：
</code></pre>

<pre><code>static int snd_pcm_dev_register(struct snd_device *device)
{
    ......

    /* register pcm */
    err = snd_register_device_for_dev(devtype, pcm-&gt;card,
                         pcm-&gt;device,
                    &amp;snd_pcm_f_ops[cidx],
                    pcm, str, dev);
    ......
}
</code></pre>

<pre><code>
我们再进入snd_register_device_for_dev()：
</code></pre>

<pre><code>int snd_register_device_for_dev(int type, struct snd_card *card, int dev,
                const struct file_operations *f_ops,
                void *private_data,
                const char *name, struct device *device)
{
    int minor;
    struct snd_minor *preg;

    if (snd_BUG_ON(!name))
        return -EINVAL;
    preg = kmalloc(sizeof *preg, GFP_KERNEL);
    if (preg == NULL)
        return -ENOMEM;
    preg-&gt;type = type;
    preg-&gt;card = card ? card-&gt;number : -1;
    preg-&gt;device = dev;
    preg-&gt;f_ops = f_ops;
    preg-&gt;private_data = private_data;
    mutex_lock(&amp;sound_mutex);
#ifdef CONFIG_SND_DYNAMIC_MINORS
    minor = snd_find_free_minor();
#else
    minor = snd_kernel_minor(type, card, dev);
    if (minor &gt;= 0 &amp;&amp; snd_minors[minor])
        minor = -EBUSY;
#endif
    if (minor &lt; 0) {
        mutex_unlock(&amp;sound_mutex);
        kfree(preg);
        return minor;
    }
    snd_minors[minor] = preg;
    preg-&gt;dev = device_create(sound_class, device, MKDEV(major, minor),
                  private_data, "%s", name);
    if (IS_ERR(preg-&gt;dev)) {
        snd_minors[minor] = NULL;
        mutex_unlock(&amp;sound_mutex);
        minor = PTR_ERR(preg-&gt;dev);
        kfree(preg);
        return minor;
    }

    mutex_unlock(&amp;sound_mutex);
    return 0;
}
</code></pre>

<pre><code>
  首先，分配并初始化一个snd_minor结构中的各字段
   type：SNDRV_DEVICE_TYPE_PCM_PLAYBACK/SNDRV_DEVICE_TYPE_PCM_CAPTURE
   card: card的编号
   device：pcm实例的编号，大多数情况为0
   f_ops：snd_pcm_f_ops
   private_data：指向该pcm的实例

  根据type，card和pcm的编号，确定数组的索引值minor，minor也作为pcm设备的此设备号

  把该snd_minor结构的地址放入全局数组snd_minors[minor]中

  最后，调用device_create创建设备节点

##### 4.2 设备文件的建立

在4.1节的最后，设备文件已经建立，不过4.1节的重点在于snd_minors数组的赋值过程，在本节中，我们把重点放在设备文件中。

回到pcm的回调函数snd_pcm_dev_register()中：
</code></pre>

<pre><code>static int snd_pcm_dev_register(struct snd_device *device)
{
    int cidx, err;
    char str[16];
    struct snd_pcm *pcm;
    struct device *dev;

    pcm = device-&gt;device_data;
         ......
    for (cidx = 0; cidx &lt; 2; cidx++) {
                  ......
        switch (cidx) {
        case SNDRV_PCM_STREAM_PLAYBACK:
            sprintf(str, "pcmC%iD%ip", pcm-&gt;card-&gt;number, pcm-&gt;device);
            devtype = SNDRV_DEVICE_TYPE_PCM_PLAYBACK;
            break;
        case SNDRV_PCM_STREAM_CAPTURE:
            sprintf(str, "pcmC%iD%ic", pcm-&gt;card-&gt;number, pcm-&gt;device);
            devtype = SNDRV_DEVICE_TYPE_PCM_CAPTURE;
            break;
        }
        /* device pointer to use, pcm-&gt;dev takes precedence if
         * it is assigned, otherwise fall back to card's device
         * if possible */
        dev = pcm-&gt;dev;
        if (!dev)
            dev = snd_card_get_device_link(pcm-&gt;card);
        /* register pcm */
        err = snd_register_device_for_dev(devtype, pcm-&gt;card,
                          pcm-&gt;device,
                          &amp;snd_pcm_f_ops[cidx],
                          pcm, str, dev);
                  ......
    }
         ......
}
</code></pre>

<pre><code>
以上代码我们可以看出，对于一个pcm设备，可以生成两个设备文件，一个用于playback，一个用于capture，代码中也确定了他们的命名规则：

  playback  --  pcmCxDxp，通常系统中只有一各声卡和一个pcm，它就是pcmC0D0p

  capture  --  pcmCxDxc，通常系统中只有一各声卡和一个pcm，它就是pcmC0D0c


##### snd_pcm_f_ops

snd_pcm_f_ops是一个标准的文件系统file_operations结构数组，它的定义在sound/core/pcm_native.c中：
</code></pre>

<pre><code>const struct file_operations snd_pcm_f_ops[2] = {
    {
        .owner =        THIS_MODULE,
        .write =        snd_pcm_write,
        .aio_write =        snd_pcm_aio_write,
        .open =         snd_pcm_playback_open,
        .release =      snd_pcm_release,
        .llseek =       no_llseek,
        .poll =         snd_pcm_playback_poll,
        .unlocked_ioctl =   snd_pcm_playback_ioctl,
        .compat_ioctl =     snd_pcm_ioctl_compat,
        .mmap =         snd_pcm_mmap,
        .fasync =       snd_pcm_fasync,
        .get_unmapped_area =    snd_pcm_get_unmapped_area,
    },
    {
        .owner =        THIS_MODULE,
        .read =         snd_pcm_read,
        .aio_read =     snd_pcm_aio_read,
        .open =         snd_pcm_capture_open,
        .release =      snd_pcm_release,
        .llseek =       no_llseek,
        .poll =         snd_pcm_capture_poll,
        .unlocked_ioctl =   snd_pcm_capture_ioctl,
        .compat_ioctl =     snd_pcm_ioctl_compat,
        .mmap =         snd_pcm_mmap,
        .fasync =       snd_pcm_fasync,
        .get_unmapped_area =    snd_pcm_get_unmapped_area,
    }
};
</code></pre>

<pre><code>
snd_pcm_f_ops作为snd_register_device_for_dev的参数被传入，并被记录在snd_minors[minor]中的字段f_ops中。最后，在snd_register_device_for_dev中创建设备节点：
</code></pre>

<pre><code>snd_minors[minor] = preg;
preg-&gt;dev = device_create(sound_class, device, MKDEV(major, minor),
              private_data, "%s", name);
</code></pre>

<pre><code>
##### 4.3 层层深入，从应用程序到驱动层pcm 4.3.1 字符设备注册

在sound/core/sound.c中有alsa_sound_init()函数，定义如下：
</code></pre>

<pre><code>static int __init alsa_sound_init(void)
{
    snd_major = major;
    snd_ecards_limit = cards_limit;
    if (register_chrdev(major, "alsa", &amp;snd_fops)) {
        snd_printk(KERN_ERR "unable to register native major device number %d/n", major);
        return -EIO;
    }
    if (snd_info_init() &lt; 0) {
        unregister_chrdev(major, "alsa");
        return -ENOMEM;
    }
    snd_info_minor_register();
    return 0;
}
</code></pre>

<pre><code>
register_chrdev中的参数major与之前创建pcm设备是device_create时的major是同一个，这样的结果是，当应用程序open设备文件/dev/snd/pcmCxDxp时，会进入snd_fops的open回调函数，我们将在下一节中讲述open的过程。

###### 4.3.2 打开pcm设备

从上一节中我们得知，open一个pcm设备时，将会调用snd_fops的open回调函数，我们先看看snd_fops的定义：
</code></pre>

<pre><code>static const struct file_operations snd_fops =
{
    .owner =    THIS_MODULE,
    .open =     snd_open
};
</code></pre>

<pre><code>
跟入snd_open函数，它首先从inode中取出此设备号，然后以次设备号为索引，从snd_minors全局数组中取出当初注册pcm设备时填充的snd_minor结构（参看4.1节的内容），然后从snd_minor结构中取出pcm设备的f_ops，并且把file-&gt;f_op替换为pcm设备的f_ops，紧接着直接调用pcm设备的f_ops-&gt;open()，然后返回。因为file-&gt;f_op已经被替换，以后，应用程序的所有read/write/ioctl调用都会进入pcm设备自己的回调函数中，也就是4.2节中提到的snd_pcm_f_ops结构中定义的回调。
</code></pre>

<pre><code>static int snd_open(struct inode *inode, struct file *file)
{
    unsigned int minor = iminor(inode);
    struct snd_minor *mptr = NULL;
    const struct file_operations *old_fops;
    int err = 0;

    if (minor &gt;= ARRAY_SIZE(snd_minors))
        return -ENODEV;
    mutex_lock(&amp;sound_mutex);
    mptr = snd_minors[minor];
    if (mptr == NULL) {
        mptr = autoload_device(minor);
        if (!mptr) {
            mutex_unlock(&amp;sound_mutex);
            return -ENODEV;
        }
    }
    old_fops = file-&gt;f_op;
    file-&gt;f_op = fops_get(mptr-&gt;f_ops);
    if (file-&gt;f_op == NULL) {
        file-&gt;f_op = old_fops;
        err = -ENODEV;
    }
    mutex_unlock(&amp;sound_mutex);
    if (err &lt; 0)
        return err;

    if (file-&gt;f_op-&gt;open) {
        err = file-&gt;f_op-&gt;open(inode, file);
        if (err) {
            fops_put(file-&gt;f_op);
            file-&gt;f_op = fops_get(old_fops);
        }
    }
    fops_put(old_fops);
    return err;
}
</code></pre>

<pre><code>

下面的序列图展示了应用程序如何最终调用到snd_pcm_f_ops结构中的回调函数：

![](/images/kernel/2018-03-03-8.png)  
                                      图4.3.2.1    应用程序操作pcm设备


## Linux ALSA声卡驱动之四：Control设备的创建

#### Control接口

Control接口主要让用户空间的应用程序（alsa-lib）可以访问和控制音频codec芯片中的多路开关，滑动控件等。对于Mixer（混音）来说，Control接口显得尤为重要，从ALSA 0.9.x版本开始，所有的mixer工作都是通过control接口的API来实现的。

ALSA已经为AC97定义了完整的控制接口模型，如果你的Codec芯片只支持AC97接口，你可以不用关心本节的内容。

&lt;sound/control.h&gt;定义了所有的Control API。如果你要为你的codec实现自己的controls，请在代码中包含该头文件。

#### Controls的定义

要自定义一个Control，我们首先要定义3各回调函数：info，get和put。然后，定义一个snd_kcontrol_new结构：
</code></pre>

<pre><code>static struct snd_kcontrol_new my_control __devinitdata = {
    .iface = SNDRV_CTL_ELEM_IFACE_MIXER,
    .name = "PCM Playback Switch",
    .index = 0,
    .access = SNDRV_CTL_ELEM_ACCESS_READWRITE,
    .private_value = 0xffff,
    .info = my_control_info,
    .get = my_control_get,
    .put = my_control_put
};
</code></pre>

<pre><code>
iface字段指出了control的类型，alsa定义了几种类型（SNDDRV_CTL_ELEM_IFACE_XXX），常用的类型是MIXER，当然也可以定义属于全局的CARD类型，也可以定义属于某类设备的类型，例如HWDEP，PCMRAWMIDI，TIMER等，这时需要在device和subdevice字段中指出卡的设备逻辑编号。

name字段是该control的名字，从ALSA 0.9.x开始，control的名字是变得比较重要，因为control的作用是按名字来归类的。ALSA已经预定义了一些control的名字，我们再Control Name一节详细讨论。

index字段用于保存该control的在该卡中的编号。如果声卡中有不止一个codec，每个codec中有相同名字的control，这时我们可以通过index来区分这些controls。当index为0时，则可以忽略这种区分策略。

access字段包含了该control的访问类型。每一个bit代表一种访问类型，这些访问类型可以多个“或”运算组合在一起。

private_value字段包含了一个任意的长整数类型值。该值可以通过info，get，put这几个回调函数访问。你可以自己决定如何使用该字段，例如可以把它拆分成多个位域，又或者是一个指针，指向某一个数据结构。

tlv字段为该control提供元数据。

#### Control的名字

control的名字需要遵循一些标准，通常可以分成3部分来定义control的名字：源--方向--功能。

  源，可以理解为该control的输入端，alsa已经预定义了一些常用的源，例如：Master，PCM，CD，Line等等。

  方向，代表该control的数据流向，例如：Playback，Capture，Bypass，Bypass Capture等等，也可以不定义方向，这时表示该Control是双向的（playback和capture）。
  功能，根据control的功能，可以是以下字符串：Switch，Volume，Route等等。

也有一些命名上的特例：

  全局的capture和playback    "Capture Source"，"Capture Volume"，"Capture Switch"，它们用于全局的capture source，switch和volume。同理，"Playback Volume"，"Playback Switch"，它们用于全局的输出switch和volume。
   Tone-controles    音调控制的开关和音量命名为：Tone Control - XXX，例如，"Tone Control - Switch"，"Tone Control - Bass"，"Tone Control - Center"。
   3D controls    3D控件的命名规则：，"3D Control - Switch"，"3D Control - Center"，"3D Control - Space"。
   Mic boost    麦克风音量加强控件命名为："Mic Boost"或"Mic Boost(6dB)"。

#### 访问标志（ACCESS Flags）

Access字段是一个bitmask，它保存了改control的访问类型。默认的访问类型是：SNDDRV_CTL_ELEM_ACCESS_READWRITE，表明该control支持读和写操作。如果access字段没有定义（.access==0），此时也认为是READWRITE类型。


如果是一个只读control，access应该设置为：SNDDRV_CTL_ELEM_ACCESS_READ，这时，我们不必定义put回调函数。类似地，如果是只写control，access应该设置为：SNDDRV_CTL_ELEM_ACCESS_WRITE，这时，我们不必定义get回调函数。


如果control的值会频繁地改变（例如：电平表），我们可以使用VOLATILE类型，这意味着该control会在没有通知的情况下改变，应用程序应该定时地查询该control的值。

#### 回调函数  info回调函数

info回调函数用于获取control的详细信息。它的主要工作就是填充通过参数传入的snd_ctl_elem_info对象，以下例子是一个具有单个元素的boolean型control的info回调：
</code></pre>

<pre><code>static int snd_myctl_mono_info(struct snd_kcontrol *kcontrol,
    struct snd_ctl_elem_info *uinfo)
{
    uinfo-&gt;type = SNDRV_CTL_ELEM_TYPE_BOOLEAN;
    uinfo-&gt;count = 1;
    uinfo-&gt;value.integer.min = 0;
    uinfo-&gt;value.integer.max = 1;
    return 0;
}
</code></pre>

<pre><code>
type字段指出该control的值类型，值类型可以是BOOLEAN, INTEGER, ENUMERATED, BYTES,IEC958和INTEGER64之一。count字段指出了改control中包含有多少个元素单元，比如，立体声的音量control左右两个声道的音量值，它的count字段等于2。value字段是一个联合体（union），value的内容和control的类型有关。其中，boolean和integer类型是相同的。

ENUMERATED类型有些特殊。它的value需要设定一个字符串和字符串的索引，请看以下例子：
</code></pre>

<pre><code>static int snd_myctl_enum_info(struct snd_kcontrol *kcontrol,
struct snd_ctl_elem_info *uinfo)
{
    static char *texts[4] = {
        "First", "Second", "Third", "Fourth"
    };
    uinfo-&gt;type = SNDRV_CTL_ELEM_TYPE_ENUMERATED;
    uinfo-&gt;count = 1;
    uinfo-&gt;value.enumerated.items = 4;
    if (uinfo-&gt;value.enumerated.item &gt; 3)
        uinfo-&gt;value.enumerated.item = 3;
    strcpy(uinfo-&gt;value.enumerated.name,
        texts[uinfo-&gt;value.enumerated.item]);
    return 0;
}
</code></pre>

<pre><code>
alsa已经为我们实现了一些通用的info回调函数，例如：snd_ctl_boolean_mono_info()，snd_ctl_boolean_stereo_info()等等。

#### get回调函数

该回调函数用于读取control的当前值，并返回给用户空间的应用程序。
</code></pre>

<pre><code>static int snd_myctl_get(struct snd_kcontrol *kcontrol,
    struct snd_ctl_elem_value *ucontrol)
{
    struct mychip *chip = snd_kcontrol_chip(kcontrol);
    ucontrol-&gt;value.integer.value[0] = get_some_value(chip);
    return 0;
}
</code></pre>

<pre><code>
value字段的赋值依赖于control的类型（如同info回调）。很多声卡的驱动利用它存储硬件寄存器的地址、bit-shift和bit-mask，这时，private_value字段可以按以下例子进行设置：

 .private_value = reg | (shift &lt;&lt; 16) | (mask &lt;&lt; 24);

然后，get回调函数可以这样实现：
</code></pre>

<pre><code>static int snd_sbmixer_get_single(struct snd_kcontrol *kcontrol,
    struct snd_ctl_elem_value *ucontrol)
{
    int reg = kcontrol-&gt;private_value &amp; 0xff;
    int shift = (kcontrol-&gt;private_value &gt;&gt; 16) &amp; 0xff;
    int mask = (kcontrol-&gt;private_value &gt;&gt; 24) &amp; 0xff;
    ....

    //根据以上的值读取相应寄存器的值并填入value中
}
</code></pre>

<pre><code>
如果control的count字段大于1，表示control有多个元素单元，get回调函数也应该为value填充多个数值。


#### put回调函数

put回调函数用于把应用程序的控制值设置到control中。
</code></pre>

<pre><code>static int snd_myctl_put(struct snd_kcontrol *kcontrol,
    struct snd_ctl_elem_value *ucontrol)
{
    struct mychip *chip = snd_kcontrol_chip(kcontrol);
    int changed = 0;
    if (chip-&gt;current_value !=
        ucontrol-&gt;value.integer.value[0]) {
        change_current_value(chip,
        ucontrol-&gt;value.integer.value[0]);
        changed = 1;
    }
    return changed;
}
</code></pre>

<pre><code>
如上述例子所示，当control的值被改变时，put回调必须要返回1，如果值没有被改变，则返回0。如果发生了错误，则返回一个负数的错误号。

和get回调一样，当control的count大于1时，put回调也要处理多个control中的元素值。

#### 创建Controls

当把以上讨论的内容都准备好了以后，我们就可以创建我们自己的control了。alsa-driver为我们提供了两个用于创建control的API：
</code></pre>

<pre><code>snd_ctl_new1()
snd_ctl_add()
</code></pre>

<pre><code>
我们可以用以下最简单的方式创建control：
</code></pre>

<pre><code>err = snd_ctl_add(card, snd_ctl_new1(&amp;my_control, chip));
if (err &lt; 0)
    return err;
</code></pre>

<pre><code>
在这里，my_control是一个之前定义好的snd_kcontrol_new对象，chip对象将会被赋值在kcontrol-&gt;private_data字段，该字段可以在回调函数中访问。

snd_ctl_new1()会分配一个新的snd_kcontrol实例，并把my_control中相应的值复制到该实例中，所以，在定义my_control时，通常我们可以加上__devinitdata前缀。snd_ctl_add则把该control绑定到声卡对象card当中。

#### 元数据（Metadata）

很多mixer control需要提供以dB为单位的信息，我们可以使用DECLARE_TLV_xxx宏来定义一些包含这种信息的变量，然后把control的tlv.p字段指向这些变量，最后，在access字段中加上SNDRV_CTL_ELEM_ACCESS_TLV_READ标志，就像这样：
</code></pre>

<pre><code>static DECLARE_TLV_DB_SCALE(db_scale_my_control, -4050, 150, 0);
</code></pre>

<pre><code></code></pre>

<pre><code>tatic struct snd_kcontrol_new my_control __devinitdata = {
   ...
   .access = SNDRV_CTL_ELEM_ACCESS_READWRITE |
           SNDRV_CTL_ELEM_ACCESS_TLV_READ,
    ...
    .tlv.p = db_scale_my_control,
};
</code></pre>

<pre><code>
DECLARE_TLV_DB_SCALE宏定义的mixer control，它所代表的值按一个固定的dB值的步长变化。该宏的第一个参数是要定义变量的名字，第二个参数是最小值，以0.01dB为单位。第三个参数是变化的步长，也是以0.01dB为单位。如果该control处于最小值时会做出mute时，需要把第四个参数设为1。

DECLARE_TLV_DB_LINEAR宏定义的mixer control，它的输出随值的变化而线性变化。 该宏的第一个参数是要定义变量的名字，第二个参数是最小值，以0.01dB为单位。第二个参数是最大值，以0.01dB为单位。如果该control处于最小值时会做出mute时，需要把第二个参数设为TLV_DB_GAIN_MUTE。

这两个宏实际上就是定义一个整形数组，所谓tlv，就是Type-Lenght-Value的意思，数组的第0各元素代表数据的类型，第1个元素代表数据的长度，第三个元素和之后的元素保存该变量的数据。

#### Control设备的建立

Control设备和PCM设备一样，都属于声卡下的逻辑设备。用户空间的应用程序通过alsa-lib访问该Control设备，读取或控制control的控制状态，从而达到控制音频Codec进行各种Mixer等控制操作。

Control设备的创建过程大体上和PCM设备的创建过程相同。详细的创建过程可以参考本博的另一篇文章：Linux音频驱动之三：PCM设备的创建。下面我们只讨论有区别的地方。

我们需要在我们的驱动程序初始化时主动调用snd_pcm_new()函数创建pcm设备，而control设备则在snd_card_create()内被创建，snd_card_create()通过调用snd_ctl_create()函数创建control设备节点。所以我们无需显式地创建control设备，只要建立声卡，control设备被自动地创建。

和pcm设备一样，control设备的名字遵循一定的规则：controlCxx，这里的xx代表声卡的编号。我们也可以通过代码正是这一点，下面的是snd_ctl_dev_register()函数的代码：
</code></pre>

<pre><code>/*
 * registration of the control device
 */
static int snd_ctl_dev_register(struct snd_device *device)
{
    struct snd_card *card = device-&gt;device_data;
    int err, cardnum;
    char name[16];

    if (snd_BUG_ON(!card))
        return -ENXIO;
    cardnum = card-&gt;number;
    if (snd_BUG_ON(cardnum &lt; 0 || cardnum &gt;= SNDRV_CARDS))
        return -ENXIO;
        /* control设备的名字 */
    sprintf(name, "controlC%i", cardnum);
    if ((err = snd_register_device(SNDRV_DEVICE_TYPE_CONTROL, card, -1,
                       &amp;snd_ctl_f_ops, card, name)) &lt; 0)
        return err;
    return 0;
}
</code></pre>

<p>```</p>

<p>snd_ctl_dev_register()函数会在snd_card_register()中，即声卡的注册阶段被调用。注册完成后，control设备的相关信息被保存在snd_minors[]数组中，用control设备的此设备号作索引，即可在snd_minors[]数组中找出相关的信息。注册完成后的数据结构关系可以用下图进行表述：</p>

<p><img src="/images/kernel/2018-03-03-9.png" alt="" /><br/>
                                        control设备的操作函数入口</p>

<p>用户程序需要打开control设备时，驱动程序通过snd_minors[]全局数组和此设备号，可以获得snd_ctl_f_ops结构中的各个回调函数，然后通过这些回调函数访问control中的信息和数据（最终会调用control的几个回调函数get，put，info）。详细的代码我就不贴了，大家可以读一下代码：/sound/core/control.c</p>

<h2>Linux ALSA声卡驱动之五：移动设备中的ALSA（ASoC）</h2>

<h4>1.  ASoC的由来</h4>

<p>  ASoC&ndash;ALSA System on Chip ，是建立在标准ALSA驱动层上，为了更好地支持嵌入式处理器和移动设备中的音频Codec的一套软件体系。在ASoc出现之前，内核对于SoC中的音频已经有部分的支持，不过会有一些局限性：</p>

<p>   Codec驱动与SoC CPU的底层耦合过于紧密，这种不理想会导致代码的重复，例如，仅是wm8731的驱动，当时Linux中有分别针对4个平台的驱动代码。</p>

<p>   音频事件没有标准的方法来通知用户，例如耳机、麦克风的插拔和检测，这些事件在移动设备中是非常普通的，而且通常都需要特定于机器的代码进行重新对音频路劲进行配置。</p>

<p>   当进行播放或录音时，驱动会让整个codec处于上电状态，这对于PC没问题，但对于移动设备来说，这意味着浪费大量的电量。同时也不支持通过改变过取样频率和偏置电流来达到省电的目的。</p>

<p>   ASoC正是为了解决上述种种问题而提出的，目前已经被整合至内核的代码树中：sound/soc。ASoC不能单独存在，他只是建立在标准ALSA驱动上的一个它必须和标准的ALSA驱动框架相结合才能工作。</p>

<h4>2.  硬件架构</h4>

<p>  通常，就像软件领域里的抽象和重用一样，嵌入式设备的音频系统可以被划分为板载硬件（Machine）、Soc（Platform）、Codec三大部分，如下图所示：</p>

<p><img src="/images/kernel/2018-03-03-10.png" alt="" /><br/>
                                        图2.1  音频系统结构</p>

<p>  Machine  是指某一款机器，可以是某款设备，某款开发板，又或者是某款智能手机，由此可以看出Machine几乎是不可重用的，每个Machine上的硬件实现可能都不一样，CPU不一样，Codec不一样，音频的输入、输出设备也不一样，Machine为CPU、Codec、输入输出设备提供了一个载体。</p>

<p>  Platform  一般是指某一个SoC平台，比如pxaxxx,s3cxxxx,omapxxx等等，与音频相关的通常包含该SoC中的时钟、DMA、I2S、PCM等等，只要指定了SoC，那么我们可以认为它会有一个对应的Platform，它只与SoC相关，与Machine无关，这样我们就可以把Platform抽象出来，使得同一款SoC不用做任何的改动，就可以用在不同的Machine中。实际上，把Platform认为是某个SoC更好理解。</p>

<p>  Codec  字面上的意思就是编解码器，Codec里面包含了I2S接口、D/A、A/D、Mixer、PA（功放），通常包含多种输入（Mic、Line-in、I2S、PCM）和多个输出（耳机、喇叭、听筒，Line-out），Codec和Platform一样，是可重用的部件，同一个Codec可以被不同的Machine使用。嵌入式Codec通常通过I2C对内部的寄存器进行控制。</p>

<h4>3.  软件架构</h4>

<p>  在软件层面，ASoC也把嵌入式设备的音频系统同样分为3大部分，Machine，Platform和Codec。</p>

<p>  Codec驱动  ASoC中的一个重要设计原则就是要求Codec驱动是平台无关的，它包含了一些音频的控件（Controls），音频接口，DAMP（动态音频电源管理）的定义和某些Codec IO功能。为了保证硬件无关性，任何特定于平台和机器的代码都要移到Platform和Machine驱动中。所有的Codec驱动都要提供以下特性：</p>

<p>   Codec DAI 和 PCM的配置信息；</p>

<p>   Codec的IO控制方式（I2C，SPI等）；</p>

<p>   Mixer和其他的音频控件；</p>

<p>   Codec的ALSA音频操作接口；</p>

<p>   必要时，也可以提供以下功能：
     DAPM描述信息；
     DAPM事件处理程序；
     DAC数字静音控制</p>

<p>  Platform驱动  它包含了该SoC平台的音频DMA和音频接口的配置和控制（I2S，PCM，AC97等等）；它也不能包含任何与板子或机器相关的代码。</p>

<p>  Machine驱动  Machine驱动负责处理机器特有的一些控件和音频事件（例如，当播放音频时，需要先行打开一个放大器）；单独的Platform和Codec驱动是不能工作的，它必须由Machine驱动把它们结合在一起才能完成整个设备的音频处理工作。</p>

<h4>4.  数据结构</h4>

<p>  整个ASoC是由一些列数据结构组成，要搞清楚ASoC的工作机理，必须要理解这一系列数据结构之间的关系和作用，下面的关系图展示了ASoC中重要的数据结构之间的关联方式：</p>

<p><img src="/images/kernel/2018-03-03-11.png" alt="" /><br/>
                                          图4.1  Kernel-2.6.35-ASoC中各个结构的静态关系</p>

<p>  ASoC把声卡实现为一个Platform Device，然后利用Platform_device结构中的dev字段：dev.drvdata，它实际上指向一个snd_soc_device结构。可以认为snd_soc_device是整个ASoC数据结构的根本，由他开始，引出一系列的数据结构用于表述音频的各种特性和功能。snd_soc_device结构引出了snd_soc_card和soc_codec_device两个结构，然后snd_soc_card又引出了snd_soc_platform、snd_soc_dai_link和snd_soc_codec结构。如上所述，ASoC被划分为Machine、Platform和Codec三大部分，如果从这些数据结构看来，snd_codec_device和snd_soc_card代表着Machine驱动，snd_soc_platform则代表着Platform驱动，snd_soc_codec和soc_codec_device则代表了Codec驱动，而snd_soc_dai_link则负责连接Platform和Codec。</p>

<h4>5.  3.0版内核对ASoC的改进</h4>

<p>  本来写这篇文章的时候参考的内核版本是2.6.35，不过有CSDN的朋友提出在内核版本3.0版本中，ASoC做了较大的变化。故特意下载了3.0的代码，发现确实有所变化，下面先贴出数据结构的静态关系图：</p>

<p><img src="/images/kernel/2018-03-03-12.png" alt="" /><br/>
                                          图5.1   Kernel 3.0中的ASoC数据结构</p>

<p>  由上图我们可以看出，3.0中的数据结构更为合理和清晰，取消了snd_soc_device结构，直接用snd_soc_card取代了它，并且强化了snd_soc_pcm_runtime的作用，同时还增加了另外两个数据结构snd_soc_codec_driver和snd_soc_platform_driver，用于明确代表Codec驱动和Platform驱动。</p>

<p>  后续的章节中将会逐一介绍Machine和Platform以及Codec驱动的工作细节和关联</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[wav音频文件格式]]></title>
    <link href="http://abcdxyzk.github.io/blog/2018/03/03/kernel-wav/"/>
    <updated>2018-03-03T17:10:00+08:00</updated>
    <id>http://abcdxyzk.github.io/blog/2018/03/03/kernel-wav</id>
    <content type="html"><![CDATA[<pre><code>    # mp3 转 wav
    ffmpeg -i source.mp3 output.wav

    # wav 转 mp3
    ffmpeg -i source.wav output.mp3

    # 从视频中提取音频
    ffmpeg -i source.mp4 -vn output.wav
</code></pre>

<p><a href="http://blog.csdn.net/mcgrady_tracy/article/details/52502263">http://blog.csdn.net/mcgrady_tracy/article/details/52502263</a></p>

<p><a href="http://blog.csdn.net/u013286409/article/details/47414273">http://blog.csdn.net/u013286409/article/details/47414273</a></p>

<p>wav是微软开发的一种音频文件格式，注意，wav文件格式是无损音频文件格式，相对于其他音频格式文件数据是没有经过压缩的，通常文件也相对比较大些。</p>

<p>文件格式如图所示：</p>

<p><img src="/images/kernel/2018-03-03-1.gif" alt="" /></p>

<p>解析代码如下：
```
    #include &lt;stdio.h>
    #include &lt;stdint.h>
    #include &lt;stdlib.h></p>

<pre><code>struct WAV_Format {
    uint32_t ChunkID;   /* "RIFF" */
    uint32_t ChunkSize; /* 36 + Subchunk2Size */
    uint32_t Format;    /* "WAVE" */

    /* sub-chunk "fmt" */
    uint32_t Subchunk1ID;   /* "fmt " */
    uint32_t Subchunk1Size; /* 16 for PCM */
    uint16_t AudioFormat;   /* PCM = 1*/
    uint16_t NumChannels;   /* Mono = 1, Stereo = 2, etc. */
    uint32_t SampleRate;    /* 8000, 44100, etc. */
    uint32_t ByteRate;  /* = SampleRate * NumChannels * BitsPerSample/8 */
    uint16_t BlockAlign;    /* = NumChannels * BitsPerSample/8 */
    uint16_t BitsPerSample; /* 8bits, 16bits, etc. */
    // LIST 包含歌手歌名专辑等

    /* sub-chunk "data" */
    uint32_t Subchunk2ID;   /* "data" */
    uint32_t Subchunk2Size; /* data size */
};

int main(void)
{
    FILE *fp = NULL;
    struct WAV_Format wav;

    fp = fopen("test.wav", "rb");
    if (!fp) {
        printf("can't open audio file\n");
        exit(1);
    }

    fread(&amp;wav, 1, sizeof(struct WAV_Format), fp);

    printf("ChunkID \t%x\n", wav.ChunkID);
    printf("ChunkSize \t%d\n", wav.ChunkSize);
    printf("Format \t\t%x\n", wav.Format);
    printf("Subchunk1ID \t%x\n", wav.Subchunk1ID);
    printf("Subchunk1Size \t%d\n", wav.Subchunk1Size);
    printf("AudioFormat \t%d\n", wav.AudioFormat);
    printf("NumChannels \t%d\n", wav.NumChannels);
    printf("SampleRate \t%d\n", wav.SampleRate);
    printf("ByteRate \t%d\n", wav.ByteRate);
    printf("BlockAlign \t%d\n", wav.BlockAlign);
    printf("BitsPerSample \t%d\n", wav.BitsPerSample);
    printf("Subchunk2ID \t%x\n", wav.Subchunk2ID);
    printf("Subchunk2Size \t%d\n", wav.Subchunk2Size);

    fclose(fp);

    return 0;
}
</code></pre>

<pre><code>
#### wav概述

WAV为微软公司（Microsoft)开发的一种声音文件格式，它符合RIFF(Resource Interchange File Format)文件规范，用于保存Windows平台的音频信息资源，被Windows平台及其应用程序所广泛支持，该格式也支持MSADPCM，CCITT A LAW等多种压缩运算法，支持多种音频数字，取样频率和声道，标准格式化的WAV文件和CD格式一样，也是44.1K的取样频率，16位量化数字，因此在声音文件质量和CD相差无几！ WAV打开工具是WINDOWS的媒体播放器。

通常使用三个参数来表示声音，量化位数，取样频率和采样点振幅。量化位数分为8位，16位，24位三种，声道有单声道和立体声之分，单声道振幅数据为n*1矩阵点，立体声为n*2矩阵点，取样频率一般有11025Hz(11kHz) ，22050Hz(22kHz)和44100Hz(44kHz) 三种，不过尽管音质出色，但在压缩后的文件体积过大！相对其他音频格式而言是一个缺点，其文件大小的计算方式为：WAV格式文件所占容量（B) = （取样频率 X量化位数X 声道） X 时间 / 8 (字节= 8bit) 每一分钟WAV格式的音频文件的大小为10MB，其大小不随音量大小及清晰度的变化而变化。

#### RIFF文件

1. 简介RIFF全称为资源互换文件格式（ResourcesInterchange FileFormat），RIFF文件是windows环境下大部分多媒体文件遵循的一种文件结构,RIFF文件所包含的数据类型由该文件的扩展名来标识，能以RIFF文件存储的数据包括：音频视频交错格式数据（.AVI) 波形格式数据（.WAV) 位图格式数据（.RDI) MIDI格式数据（.RMI)调色板格式（.PAL)多媒体电影（.RMN)动画光标（.ANI)其它RIFF文件（.BND)

2. CHUNK
chunk是组成RIFF文件的基本单元，它的基本结构如下：
</code></pre>

<pre><code>struct chunk {
    u32 id;     /* 块标志 */
    u32 size;   /* 块大小 */
    u8 dat[size];   /* 块内容 */
};
</code></pre>

<pre><code>id 由4个ASCII字符组成，用以识别块中所包含的数据。如：'RIFF','LIST','fmt','data','WAV','AVI'等等，由于这种文件结构最初是由Microsoft和IBM为PC机所定义,RIFF文件是按照little-endian[2] 字节顺序写入的。

size（块大小） 是存储在data域中数据的长度,id与size域的大小则不包括在该值内。

dat（块内容） 中所包含的数据是以字(WORD)为单位排列的，如果该数据结构长度是奇数，则在最后添加一个空(NULL)字节。

#### chunk块中有且仅有两种类型块：'RIFF'和'LIST'类型可以包含其他块，而其它块仅能含有数据。

'RIFF'和'LIST'类型的chunk结构如下
</code></pre>

<pre><code>struct chunk {
    u32 id;     /* 块标志 */
    u32 size;   /* 块大小 */
    /*此时的dat = type + restdat */
    u32 type;   /* 类型 */
    u8 restdat[size]; /* dat中除type4个字节后剩余的数据*/
};
</code></pre>

<p>```</p>

<p>可以看出，'RIFF'和'LIST'也是chunk,只是它的dat由两部分组成type和restdat。</p>

<p>type,由4个ASCII字符组成，代表RIFF文件的类型，如'WAV',&lsquo;AVI '；或者'LIST'块的类型，如avi文件中的列表'hdrl&rsquo;,&lsquo;movi'。</p>

<p>restdat,dat中除type4个字节后剩余的数据，包括块内容，包含若干chunk和'LIST'</p>

<p>2.1 FOURCC 一个FOURCC(fourcharacter code）是一个占4个字节的数据，一般表示4个ASCII字符。在RIFF文件格式中，FOURCC非常普遍,structchunk 中的id成员，'LIST',&lsquo;RIFF'的type成员，起始标识等信息都是用FOURCC表示的。FOURCC一般是四个字符，如'abcd'这样的形式，也可以三个字符包含一个空格，如'abc'这样的形式。</p>

<p>RIFF文件的FileData部分由若干个'LIST'和chunk组成，而'LIST'的ListData又可以由若干个'LIST'和chunk组成，即'LIST'是可以嵌套的。
&lsquo;RIFF&rsquo;,FileType,&lsquo;LIST&rsquo;,ListType,ChunkID都是FOURCC,即使用4字节的ASIIC字符标识类型。</p>

<p>FileSize,ListSize,ChunkSize为little-endian32-bit正整数，表示Type（只有'RIFF',&lsquo;LIST'chunk有Type)+Data一起的大小，注意它是little-endian表示，如：0x00123456,存储地址由低到高，在little-endian系统中的存储表示为0x56341200（字节由低位到高位存储），而在big-endian为0x00123456（字节由高位到低位存储）。32bit整数0x00123456存储地址低&mdash;&mdash;&mdash;>；高little-endian（字节由低位到高位存储）56341200big-endian（字节由高位到低位存储）00123456</p>
]]></content>
  </entry>
  
</feed>
