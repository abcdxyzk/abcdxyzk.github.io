<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

  <title><![CDATA[Category: language | kk Blog —— 通用基础]]></title>
  <link href="http://abcdxyzk.github.io/blog/cats/language/atom.xml" rel="self"/>
  <link href="http://abcdxyzk.github.io/"/>
  <updated>2024-07-31T15:24:28+08:00</updated>
  <id>http://abcdxyzk.github.io/</id>
  <author>
    <name><![CDATA[kk]]></name>
    
  </author>
  <generator uri="http://octopress.org/">Octopress</generator>

  
  <entry>
    <title type="html"><![CDATA[Chrome浏览器使用Overrides调试线上代码]]></title>
    <link href="http://abcdxyzk.github.io/blog/2024/07/31/lang-web-override/"/>
    <updated>2024-07-31T14:54:00+08:00</updated>
    <id>http://abcdxyzk.github.io/blog/2024/07/31/lang-web-override</id>
    <content type="html"><![CDATA[<p><a href="https://blog.csdn.net/qq_42961150/article/details/123499276">https://blog.csdn.net/qq_42961150/article/details/123499276</a></p>

<h4>2. 创建文件夹</h4>

<p>在自己电脑任何地方创建一个空的文件夹，比如：我在桌面上创建了一个test文件夹。</p>

<h4>3. 打开浏览器开发者工具</h4>

<p>f12可打开浏览器开发者工具，找到Sources=>Overrides=>+Select folder for overrides选择文件，找到创建的test文件夹，记住不要双击进文件夹，直接单击选择，然后下面窗口下面的选择文件夹即可。</p>

<p><img src="/images/lang/20240731-21.png" alt="" /></p>

<p>注意： 选择了文件夹后，浏览器上方会有个提示，点击允许。点击允许后，选择的文件夹就会显示在浏览器里面。</p>

<p><img src="/images/lang/20240731-22.png" alt="" /></p>

<h4>4. 打开线上源码</h4>

<p>找到线上需要调试的代码，一般都是在network里面找到需要修改的文件，然后选中文件，在右边可以显示出读取的源码，然后鼠标右击选择菜单中的Open in Sources panel，就会自动转到刚刚选择文件夹的界面。</p>

<p><img src="/images/lang/20240731-23.png" alt="" /></p>

<h4>5. 编辑代码</h4>

<p>编辑源码，比如我在源码中增加了一行代码，然后ctrl+s直接保存，就可以看到左侧test文件夹中就多了一个文件夹，里面就是保存的就是web.html到本地。</p>

<p><img src="/images/lang/20240731-24.png" alt="" /></p>

<h4>6. 刷新页面，看效果</h4>

<p>刷新，就可以看到console控制台中多了一行打印，说明已经实现了该功能。</p>

<p><img src="/images/lang/20240731-25.png" alt="" /></p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[fetch使用介绍, chrome如何重新提交请求并且更改参数]]></title>
    <link href="http://abcdxyzk.github.io/blog/2024/07/31/lang-web-fetch/"/>
    <updated>2024-07-31T14:47:00+08:00</updated>
    <id>http://abcdxyzk.github.io/blog/2024/07/31/lang-web-fetch</id>
    <content type="html"><![CDATA[<p><a href="http://www.3scard.com/index.php?m=blog&amp;f=view&amp;id=260">http://www.3scard.com/index.php?m=blog&amp;f=view&amp;id=260</a></p>

<p>fetch函数用于发起异步http请求；</p>

<p>fetch相比XMLHttpRequest更容易使用；</p>

<p>promise是异步对象，fetch使用promise实现异步操作；</p>

<h4>发起get请求</h4>

<pre><code>    fetch('http://localhost:8080/springmvc/test_get.do?name=who', {
        method: 'GET',
        headers: {
            'Content-Type': 'application/x-www-form-urlencoded',
        },
    }).then((resp)=&gt;{return resp.text()}).then((data)=&gt;{console.log(data)});
</code></pre>

<h4>发起post请求</h4>

<pre><code>    fetch('http://localhost:8080/springmvc/test_post.do', {
        method: 'POST',
        headers: {
            'Content-Type': 'application/x-www-form-urlencoded',
        },
        body: 'name=who'
    }).then((resp)=&gt;{return resp.text()}).then((data)=&gt;{console.log(data)});
</code></pre>

<p><a href="https://blog.csdn.net/daban2008/article/details/127180303">https://blog.csdn.net/daban2008/article/details/127180303</a></p>

<h2>chrome如何重新提交post请求，并且更改请求参数</h2>

<h4>1、直接在当前页copy as fetch</h4>

<p><img src="/images/lang/20240731-11.png" alt="" /></p>

<h4>2、直接粘贴到当前的console中</h4>

<p><img src="/images/lang/20240731-12.png" alt="" /></p>

<h4>3、回车</h4>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[95598停电公告信息抓取]]></title>
    <link href="http://abcdxyzk.github.io/blog/2024/07/31/lang-web-95598/"/>
    <updated>2024-07-31T14:40:00+08:00</updated>
    <id>http://abcdxyzk.github.io/blog/2024/07/31/lang-web-95598</id>
    <content type="html"><![CDATA[<p><a href="https://blog.csdn.net/weixin_44492045/article/details/131921632">https://blog.csdn.net/weixin_44492045/article/details/131921632</a></p>

<p>抓取网站：95598智能互动网站 <a href="https://www.95598.cn/osgweb/blackoutNotice">https://www.95598.cn/osgweb/blackoutNotice</a></p>

<p>首先找到准确的url，可以看到请求参数是加密的，返回的数据也是加密的。</p>

<p><img src="/images/lang/20240731-1.png" alt="" /></p>

<p>对于这类需要逆向加解密的网站，先通过请求栈来看一下，注意框起来的地方，可以很清楚的看到这里用到的是axios，所以加解密的过程中一定会运用到拦截器。</p>

<p><img src="/images/lang/20240731-2.png" alt="" /></p>

<p>直接在全局搜索interceptor，可以看到能搜到对应的js，进入js就能找到对应的加密入口。</p>

<p><img src="/images/lang/20240731-3.png" alt="" /></p>

<p>要想完成这个网站的逆向，还需要对加密算法有一定了解，比如sm国密算法，在进行加密之前还会先请求keycode和publickey，调整好流程，通过两次请求和加解密过程就能得到想要的数据。</p>

<p><img src="/images/lang/20240731-4.png" alt="" /></p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[sm1、sm2、sm3、sm4简单介绍]]></title>
    <link href="http://abcdxyzk.github.io/blog/2024/07/30/lang-php-sm1234/"/>
    <updated>2024-07-30T16:52:00+08:00</updated>
    <id>http://abcdxyzk.github.io/blog/2024/07/30/lang-php-sm1234</id>
    <content type="html"><![CDATA[<p><a href="https://www.cnblogs.com/coolYuan/p/8630280.html">https://www.cnblogs.com/coolYuan/p/8630280.html</a></p>

<p>国密即国家密码局认定的国产密码算法。主要有SM1，SM2，SM3，SM4。密钥长度和分组长度均为128位。</p>

<p>SM1 为对称加密。其加密强度与AES相当。该算法不公开，调用该算法时，需要通过加密芯片的接口进行调用。</p>

<p>SM2为非对称加密，基于ECC。该算法已公开。由于该算法基于ECC，故其签名速度与秘钥生成速度都快于RSA。ECC 256位（SM2采用的就是ECC 256位的一种）安全强度比RSA 2048位高，但运算速度快于RSA。</p>

<p>SM3 消息摘要。可以用MD5作为对比理解。该算法已公开。校验结果为256位。</p>

<p>SM4 无线局域网标准的分组数据算法。对称加密，密钥长度和分组长度均为128位。</p>

<p>由于SM1、SM4加解密的分组大小为128bit，故对消息进行加解密时，若消息长度过长，需要进行分组，要消息长度不足，则要进行填充。</p>

<p>补充：</p>

<p>当使用特定的芯片进行SM1或其他国密算法加密时，若用多个线程调用加密卡的API时，要考虑芯片对于多线程的支持情况。</p>

<p>国产密码算法（国密算法）是指国家密码局认定的国产商用密码算法，在金融领域目前主要使用公开的SM2、SM3、SM4三类算法，分别是非对称算法、哈希算法和对称算法。</p>

<p>SM2算法：SM2椭圆曲线公钥密码算法是我国自主设计的公钥密码算法，包括SM2-1椭圆曲线数字签名算法，SM2-2椭圆曲线密钥交换协议，SM2-3椭圆曲线公钥加密算法，分别用于实现数字签名密钥协商和数据加密等功能。SM2算法与RSA算法不同的是，SM2算法是基于椭圆曲线上点群离散对数难题，相对于RSA算法，256位的SM2密码强度已经比2048位的RSA密码强度要高。</p>

<p>SM3算法：SM3杂凑算法是我国自主设计的密码杂凑算法，适用于商用密码应用中的数字签名和验证消息认证码的生成与验证以及随机数的生成，可满足多种密码应用的安全需求。为了保证杂凑算法的安全性，其产生的杂凑值的长度不应太短，例如MD5输出128比特杂凑值，输出长度太短，影响其安全性SHA-1算法的输出长度为160比特，SM3算法的输出长度为256比特，因此SM3算法的安全性要高于MD5算法和SHA-1算法。</p>

<p>SM4算法：SM4分组密码算法是我国自主设计的分组对称密码算法，用于实现数据的加密/解密运算，以保证数据和信息的机密性。要保证一个对称密码算法的安全性的基本条件是其具备足够的密钥长度，SM4算法与AES算法具有相同的密钥长度分组长度128比特，因此在安全性上高于3DES算法。</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[php sm2]]></title>
    <link href="http://abcdxyzk.github.io/blog/2024/07/30/lang-php-sm2/"/>
    <updated>2024-07-30T16:41:00+08:00</updated>
    <id>http://abcdxyzk.github.io/blog/2024/07/30/lang-php-sm2</id>
    <content type="html"><![CDATA[<p><a href="https://github.com/lpilp/phpsm2sm3sm4">https://github.com/lpilp/phpsm2sm3sm4</a></p>

<pre><code>    yum --enablerepo=remi-php74 install php-gmp
    ./composer.phar require mdanter/ecc
    ./composer.phar require lpilp/guomi
</code></pre>

<pre><code>    require '../composer/vendor/autoload.php';
    use Rtgm\sm\RtSm2;

    // $sm2 = new RtSm2('hex', false); 相同字符串每次算出不同值
    $sm2 = new RtSm2();

    echo "sm2加解密测试:\n";
    $mks = $sm2-&gt;generateKey();
    var_dump($mks);
    $en = $sm2-&gt;doEncrypt($sm2-&gt;_str2hex($key), $mks[1]);
    var_dump($en);

    $de = $sm2-&gt;doDecrypt($en, $mks[0]);
    var_dump($de);
    var_dump(hex2bin($de));
    echo "\n";
    echo "\n";
</code></pre>

<hr />

<p><a href="https://www.cnblogs.com/blog-dyn/p/16301425.html">https://www.cnblogs.com/blog-dyn/p/16301425.html</a></p>

<pre><code>    use Mdanter\Ecc\Crypto\Key\PrivateKey;
    use Mdanter\Ecc\Crypto\Signature\Signature;
    use Mdanter\Ecc\Serializer\Signature\DerSignatureSerializer;
    use Rtgm\ecc\RtEccFactory;
    use Rtgm\sm\RtSm2;

    require 'vendor/autoload.php';

    $data = '{"request":{"body":{"TEST":"中文","TEST2":"!@#$%^&amp;*()","TEST3":12345,"TEST4":[{"arrItem1":"qaz","arrItem2":123,"arrItem3":true,"arrItem4":"中文"}],"buscod":"N02030"},"head":{"funcode":"DCLISMOD","userid":"N003261207"}},"signature":{"sigdat":"__signature_sigdat__"}}';
    $key = 'NBtl7WnuUtA2v5FaebEkU0/Jj1IodLGT6lQqwkzmd2E=';
    $key = bin2hex(base64_decode($key));//转为16进制
    $sm2 = new RtSm2('base64');
    $userid = 'N003261207' . "0000000000000000";
    $userid = substr($userid, 0, 16);
    //签名
    $sign = $sm2-&gt;doSign($data, $key, $userid);
    $sign = base64_decode($sign);
    $a = \FG\ASN1\ASNObject::fromBinary($sign)-&gt;getChildren();

    $aa = formatHex($a[0]-&gt;getContent());
    $bb = formatHex($a[1]-&gt;getContent());
    $sign = $aa. $bb;
    $sign = base64_encode(hex2bin($sign));
    var_dump($sign);
    //验签

    $signHex = bin2hex(base64_decode($sign));
    var_dump($signHex);
    $r = substr($signHex, 0, 64);
    $s = substr($signHex, 64, 64);
    var_dump($r, $s);
    $r = gmp_init($r, 16);
    $s = gmp_init($s, 16);
    /*$r = gmp_init('90416529259334433398865842692135340273188180784859666141339740103133164395295', 10);
    $s = gmp_init('51927610271972364114244381230895889971736075490328811928131691394657016568041', 10);*/
    $signature = new Signature( $r, $s );
    $serializer = new DerSignatureSerializer();
    $serializedSig = $serializer-&gt;serialize($signature);

    $sign = base64_encode($serializedSig);
    var_dump($sign);
    $adapter = RtEccFactory::getAdapter();
    $generator = RtEccFactory::getSmCurves()-&gt;generatorSm2();
    $secret = gmp_init($key, 16);
    $key = new PrivateKey($adapter, $generator, $secret);
    $pubkey = $key-&gt;getPublicKey()-&gt;getPoint();
    $x = $pubkey-&gt;getX();
    $y = $pubkey-&gt;getY();
    $pub = gmp_strval($x, 16);
    $pub .= gmp_strval($y, 16);
    var_dump($pub);
    $b = $sm2-&gt;verifySign($data, $sign, $pub, $userid);
    var_dump($b);

    function formatHex($dec)
    {
        $hex = gmp_strval(gmp_init($dec, 10), 16);
        $len = strlen($hex);
        if ($len == 64) {
            return $hex;
        }
        if ($len &lt; 64){
            $hex = str_pad($hex, 64, "0", STR_PAD_LEFT);
        }else {
            $hex = substr($hex, $len - 64, 64);
        }

        return $hex;
    }
</code></pre>

<h4>SM4加密</h4>

<pre><code>    $userid = 'N003261207' . "0000000000000000";
    $userid = substr($userid, 0, 16);
    $sm4 = new RtSm4($key);
    $sign = $sm4-&gt;encrypt($data,'sm4',$userid ,'base64');
</code></pre>

<h4>SM4解密</h4>

<pre><code>    $userid = 'N003261207' . "0000000000000000";
    $userid = substr($userid, 0, 16);
    $sm4 = new RtSm4($key);
    $data = $sm4-&gt;decrypt($sign,'sm4-cbc',$userid ,'base64');
</code></pre>
]]></content>
  </entry>
  
</feed>
