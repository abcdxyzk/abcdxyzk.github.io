<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

  <title><![CDATA[Category: system | kk Blog —— 通用基础]]></title>
  <link href="http://abcdxyzk.github.io/blog/cats/system/atom.xml" rel="self"/>
  <link href="http://abcdxyzk.github.io/"/>
  <updated>2024-03-13T12:10:10+08:00</updated>
  <id>http://abcdxyzk.github.io/</id>
  <author>
    <name><![CDATA[kk]]></name>
    
  </author>
  <generator uri="http://octopress.org/">Octopress</generator>

  
  <entry>
    <title type="html"><![CDATA[Ubuntu安装vulkan]]></title>
    <link href="http://abcdxyzk.github.io/blog/2023/12/10/ubuntu-vulkan/"/>
    <updated>2023-12-10T16:37:00+08:00</updated>
    <id>http://abcdxyzk.github.io/blog/2023/12/10/ubuntu-vulkan</id>
    <content type="html"><![CDATA[<p><a href="https://blog.csdn.net/luolinll1212/article/details/113261022">https://blog.csdn.net/luolinll1212/article/details/113261022</a></p>

<h2>安装</h2>

<h4>2.1 方式一</h4>

<pre><code>    sudo apt-get install cmake git gcc g++ mesa-* libwayland-dev libxrandr-dev
    sudo apt-get install libvulkan1 mesa-vulkan-drivers vulkan-utils
    vulkaninfo
</code></pre>

<h4>2.2 方式二 （推荐）</h4>

<pre><code>    sudo apt-get install cmake git gcc g++ mesa-* libwayland-dev libxrandr-dev 
    sudo apt-get install libvulkan1 mesa-vulkan-drivers vulkan-utils libxcb-keysyms1-dev
    sudo apt-get install libxcb1-dev libx11-dev
    wget https://sdk.lunarg.com/sdk/download/1.2.162.1/linux/vulkansdk-linux-x86_64-1.2.162.1.tar.gz
    mkdir vulkan 
    mv vulkansdk-linux-x86_64-1.2.162.1.tar.gz vulkan
    cd vulkan
    tar xf vulkansdk-linux-x86_64-1.2.162.1.tar.gz
    # 下载github
    cd 1.2.162.1/source/shaderc
    python update_shaderc_sources.py 
    # 编译
    cd 1.2.162.1
    bash vulkansdk  # 编译vulkan
    source setup-env.sh # vulkan -&gt; 系统环境变量
    ./x86_64/bin/vulkaninfo
</code></pre>

<h3>2.3 方式三</h3>

<pre><code>    git clone https://github.com/SaschaWillems/Vulkan.git
    git submodule sync
    git submodule update --init --recursive
    mkdir build
    cd build
    cmake ..
    make
</code></pre>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[ubuntu18.04 编译php8.1 fpm, 连接apache2, mariadb]]></title>
    <link href="http://abcdxyzk.github.io/blog/2023/08/05/php-apache2-mysql/"/>
    <updated>2023-08-05T16:42:00+08:00</updated>
    <id>http://abcdxyzk.github.io/blog/2023/08/05/php-apache2-mysql</id>
    <content type="html"><![CDATA[<p>下载 <a href="https://www.php.net/downloads.php">https://www.php.net/downloads.php</a></p>

<h2>一、编译安装php</h2>

<p><a href="https://www.cnblogs.com/architectforest/p/15714248.html">https://www.cnblogs.com/architectforest/p/15714248.html</a></p>

<h4>依赖</h4>

<pre><code>    sudo apt-get install gcc g++ libxml2-dev pkg-config libkrb5-dev libssl-dev libsqlite3-dev zlib1g-dev libbz2-dev libcurl4-openssl-dev libpng-dev libjpeg-dev libfreetype-dev libonig-dev libxslt-dev libzip-dev
</code></pre>

<h4>配置:</h4>

<p>安装目录为 /usr/local/php8</p>

<pre><code>    ./configure --prefix=/usr/local/php8 --with-config-file-path=/usr/local/php8/etc --with-curl --with-freetype --enable-gd --with-jpeg  --with-gettext --with-kerberos --with-libdir=lib64 --with-libxml --with-mysqli --with-openssl --with-pdo-mysql  --with-pdo-sqlite --with-pear --enable-sockets --with-mhash --with-ldap-sasl --with-xsl --with-zlib --with-zip -with-bz2 --with-iconv  --enable-fpm --enable-pdo --enable-ftp --enable-bcmath  --enable-mbregex --enable-mbstring --enable-opcache --enable-pcntl  --enable-shmop --enable-soap --enable-sockets --enable-sysvsem --enable-xml --enable-sysvsem --enable-cli --enable-opcache --enable-intl --enable-calendar --enable-static --enable-mysqlnd
</code></pre>

<h4>编译安装</h4>

<pre><code>    make
    make install
</code></pre>

<h4>配置文件</h4>

<p>在编译目录
php.ini
<code>
    cp php.ini-production /usr/local/php8/etc/php.ini
</code></p>

<p>www.conf
<code>
    cp /usr/local/php8/etc/php-fpm.d/www.conf.default /usr/local/php8/etc/php-fpm.d/www.conf
</code></p>

<p>php-fpm.conf
<code>
    cp /usr/local/php8/etc/php-fpm.conf.default /usr/local/php8/etc/php-fpm.conf
</code></p>

<p>配置用户</p>

<pre><code>    vim /usr/local/php8/etc/php-fpm.d/www.conf

    ;user = nobody
    ;group = nobody
    user = apache
    group = apache
</code></pre>

<h4>生成启动文件</h4>

<p>在编译目录
```
    cp sapi/fpm/php-fpm.service /etc/systemd/system/</p>

<pre><code>vim /etc/systemd/system/php-fpm.service

# Mounts the /usr, /boot, and /etc directories read-only for processes invoked by this unit.
#ProtectSystem=full
ProtectSystem=false
</code></pre>

<pre><code>
把 ProtectSystem=full修改为: ProtectSystem=false

#### 启动
</code></pre>

<pre><code>systemctl daemon-reload

systemctl restart php-fpm


netstat -ltnup | grep 9000
tcp        0      0 127.0.0.1:9000          0.0.0.0:*               LISTEN      12374/php-fpm: mast
</code></pre>

<pre><code>
## 编译安装mysqli拓展

https://www.cnblogs.com/sqsgoodluck/p/16659116.html

编译的时候已经默认包含了？

#### mysqlnd
</code></pre>

<pre><code>cd ext/mysqlnd

/usr/local/php8/bin/phpize

./configue
make
make install
</code></pre>

<pre><code>
#### mysqli
</code></pre>

<pre><code>cd ext/mysqli

/usr/local/php8/bin/phpize

./configue
make
make install
</code></pre>

<pre><code>
## apache2 使用 php-fpm

https://www.php.cn/faq/503744.html

我们需要了解Apache服务器与PHP语言之间的关系。Web服务器通过模块来扩展或优化其功能。对于Apache而言，它通过一个叫做“模块”的方式来扩展它的功能。而在Apache的模块中，就有一个关于PHP解释器的模块，可以让Apache服务器在运行时对PHP文件的解析和执行提供支持。


https://blog.csdn.net/yueyecheshou1980/article/details/106229421

使用 PHP-FPM 就意味着不用 Apache 内置的 mod_php，也就是要在 Apache 之外处理 php 程序的解释运行问题。看起来是多引入了一个额外的程序 PHP-FPM，既占 CPU 又占内存。但是这样一来，因为 Apache 可以专心处理除 php 之外的静态网页及元素，反而 httpd 进程本身占用的 CPU 和内存可以显著降低，从而从整体上降低资源消耗。


https://blog.csdn.net/paul_god/article/details/125251431

要想使php支持php-fpm，只需要找到你当初安装的源码,重新编译一下,在编译的时候带上 --enable-fpm 就可以了。


#### PHP-FPM 监听方式

官方文档提到的 PHP-FPM 监听方式（接收 Apache 转过去的处理 PHP 的请求的方式）有 2 个。这是在 PHP-FPM 的 pool 配置文件，如 /etc/php-fpm.d/www.conf 中设置的监听方式。分别如下，

vim /usr/local/php8/etc/php-fpm.d/www.conf
</code></pre>

<pre><code>TCP socket （IP 和 port）
listen = 127.0.0.1:9000
</code></pre>

<pre><code>就表示使用 TCP socket 方式。

Unix Domain Socket （UDS）（Apache 2.4.9 及以上版本才支持此方式），通过路径指明 socket 的位置 /path/to/unix/socket，例如，
</code></pre>

<pre><code>listen = /var/run/php-fpm/php-fpm.sock
</code></pre>

<pre><code>就表示使用 UDS 方式。

因为暂时 CentOS 7 中默认的还是 Apache 2.4.6

#### Apache 发送 PHP 处理请求的方式

原来的 mod_php 采用 SetHandler 的方式处理 php 文件并不需要特别的设置，因为在安装 PHP 的时候会自动在 Apache 的配置文件目录写入一个 php.conf 的配置文件，里面有告诉 Apache 处理 php 需要的操作：

vim /etc/apache2/apache2.conf
</code></pre>

<pre><code>&lt;FilesMatch .php$&gt;
    SetHandler "proxy:fcgi://127.0.0.1:9000"
&lt;/FilesMatch&gt;
</code></pre>

<pre><code>
service apache2 restart

## php-fpm 连接 mysql

https://blog.csdn.net/youcijibi/article/details/77002714

service php-fpm restart

service php-fpm status

因为mysqlnd并不是一个php的扩展，所以会报错：

NOTICE: PHP message: PHP Warning:  PHP Startup: Invalid library (maybe not a PHP library) 'mysqlnd.so' in Unknown on line 0


只要在php.ini里指定好mysql.sock的位置即可：大约在1023行

vim /usr/local/php8/etc/php.ini
</code></pre>

<pre><code>[Pdo_mysql]
pdo_mysql.default_socket=/var/run/mysqld/mysqld.sock

mysqli.default_socket = /var/run/mysqld/mysqld.sock
</code></pre>

<p>```</p>

<p>service php-fpm restart</p>

<p>这样php即可与mysql进行通信</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[IPMI share 端口]]></title>
    <link href="http://abcdxyzk.github.io/blog/2023/07/09/ipmi-share/"/>
    <updated>2023-07-09T17:54:00+08:00</updated>
    <id>http://abcdxyzk.github.io/blog/2023/07/09/ipmi-share</id>
    <content type="html"><![CDATA[<p><a href="https://blog.csdn.net/weixin_44652157/article/details/100095620">https://blog.csdn.net/weixin_44652157/article/details/100095620</a></p>

<p>发现没有你的服务器会额外多出一个以太网口来，那个网口是专门用来访问管理控制器（BMC）的，当然也可以通过普通网口的共享模式访问BMC。</p>

<h4>什么是共享网口方式？</h4>

<p>这里要简单地提到NC-SI（Network Controller – Sideband Interface）技术，即网络控制器边带接口技术。这一技术是用来实现BMC芯片和以太网控制器之间信息传递的，它使得BMC芯片能够像使用独立管理网口那样使用主板上的网络接口。以下是共享访问模式的实现结构图：</p>

<p><img src="/images/system/20230709-10.png" alt="" /></p>

<h4>NCSI</h4>

<p>简单理解：BMC其实是一个单片机，它有自己独立的IO设备，而独立网口就是其中之一。将BMC芯片和网络控制器之间互联，并通过NC-SI技术使得BMC芯片能够使用网络控制器上的接口。
为何要使用共享网口访问管理控制器？</p>

<p>1、减少物料成本：共享访问模式能够为单机节省一根网线；</p>

<p>2、减少人力成本：如果业务网只需要接一根网线，共享方案可以减少一半的布线人力支出；</p>

<p>3、减少交换机投入：独立网口会多占用一个交换机端口，增加交换机采购数量，使用共享模式减少了这部分的支出和额外的交换机运维成本；</p>

<h4>如何实现共享网口模式？</h4>

<p>1、BIOS或者WEB bmc界面中将IPMI访问方式修改为share（共享模式）；</p>

<p>2、为共享网口独立分配一个VLAN号和IP地址，以便和业务网剥离；</p>

<p>3、在交换机端开启802.1q协议，并分配相同的VLAN号。</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[hik SADPtool 海康SADP搜索软件]]></title>
    <link href="http://abcdxyzk.github.io/blog/2023/04/22/hik-sadptool/"/>
    <updated>2023-04-22T20:40:00+08:00</updated>
    <id>http://abcdxyzk.github.io/blog/2023/04/22/hik-sadptool</id>
    <content type="html"><![CDATA[<p><a href="https://www.onlinedown.net/soft/971269.htm">https://www.onlinedown.net/soft/971269.htm</a></p>

<p>海康SADP搜索软件(SADPTool)是一款适合海康设备使用的搜索工具。海康SADP搜索软件功能强大，可以搜索同一局域网内所有在线的设备。除此之外，该软件还可以修改设备网络参数、恢复设备的缺省密码以及显示设备的相关信息。</p>

<h4>海康SADP搜索软件(SADPTool)软件功能</h4>

<p>1、通过网络搜索软件所在网段内的在线设备。</p>

<p>2、可显示相关设备的具体信息，包括设备类型、激活状态、IP地址、端口、IPv4网关、HTTP端口等。</p>

<p>3、可修改设备的网络参数：包括IP 地址、端口、子网掩码、网关等。</p>

<p>4、可一键导出所有的设备信息。</p>

<p>5、支持使用DHCP网络。</p>

<p>6、支持修改网络管理员密码。</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Linux查看系统硬件制造商、型号和序列号]]></title>
    <link href="http://abcdxyzk.github.io/blog/2023/02/14/base-info/"/>
    <updated>2023-02-14T10:19:00+08:00</updated>
    <id>http://abcdxyzk.github.io/blog/2023/02/14/base-info</id>
    <content type="html"><![CDATA[<p><a href="https://zhuanlan.zhihu.com/p/42403181">https://zhuanlan.zhihu.com/p/42403181</a></p>

<h3>方法一：使用 dmidecode 命令</h3>

<p>dmidecode 是一个读取电脑 DMI(桌面管理接口(Desktop Management Interface))表内容并且以人类可读的格式显示系统硬件信息的工具。(也有人说是读取 SMBIOS &ndash; 系统管理 BIOS(System Management BIOS))</p>

<p>这个表包含系统硬件组件的说明，也包含如序列号、制造商、发布日期以及 BIOS 修订版本号等其它有用的信息。</p>

<p>DMI 表不仅描述了当前的系统构成，还可以报告可能的升级信息(比如可以支持的最快的 CPU 或者最大的内存容量)。</p>

<p>这将有助于分析你的硬件兼容性，比如是否支持最新版本的程序。</p>

<pre><code>    # dmidecode -t system
</code></pre>

<h3>方法二：使用 inxi 命令</h3>

<p>inxi 是 Linux 上查看硬件信息的一个灵巧的小工具，它提供了大量的选项来获取所有硬件信息，这是我在现有的其它 Linux 工具集里所没见到过的。它是从 locsmif 编写的古老的但至今看来都异常灵活的 infobash fork 出来的。</p>

<p>inxi 是一个可以快速显示系统硬件、CPU、驱动、Xorg、桌面、内核、GCC 版本、进程、内存使用以及大量其它有用信息的脚本，也可以用来做技术支持和调试工具。</p>

<pre><code>    # inxi -M
    Machine: Device: server System: IBM product: N/A v: 0B serial: MK2RL11
     Mobo: IBM model: 00Y8494 serial: 37M17D UEFI: IBM v: -[VVE134MUS-1.50]- date: 08/30/2013
</code></pre>

<h3>方法三：使用 lshw 命令</h3>

<p>lshw (指硬件监听器(Hardware Lister))是一个小巧灵活的工具，可以生成如内存配置、固件版本、主板配置、CPU 版本和速度、缓存配置、USB、网卡、显卡、多媒体、打印机以及总线速度等机器中各种硬件组件的详细报告。</p>

<p>它通过读取 /proc 目录下各种文件的内容和 DMI 表来生成硬件信息。</p>

<p>lshw 必须以超级用户的权限运行来检测完整的硬件信息，否则它只汇报部分信息。lshw 里有一个叫做 class 的特殊选项，它可以以详细的模式显示特定的硬件信息。</p>

<pre><code>    # lshw -C system
    enal-dbo01t
     description: Blade
     product: System x2530 M4: -[1214AC1]-
     vendor: IBM
     version: 0B
     serial: MK2RL11
     width: 64 bits
     capabilities: smbios-2.7 dmi-2.7 vsyscall32
     configuration: boot=normal chassis=enclosure family=System X uuid=762A99BF-6916-450F-80A6-B2E9E78FC9A1
</code></pre>

<h3>方法四：使用 /sys 文件系统</h3>

<p>内核在 /sys 目录下的文件中公开了一些 DMI 信息。因此，我们可以通过如下方式运行 grep 命令来轻易地获取机器类型。</p>

<pre><code>    # grep "" /sys/class/dmi/id/[pbs]*
</code></pre>

<p>或者，可以使用 cat 命令仅打印出特定的详细信息。</p>

<pre><code>    # cat /sys/class/dmi/id/board_vendor
    IBM

    # cat /sys/class/dmi/id/product_name
    System x2530 M4: -[1214AC1]-

    # cat /sys/class/dmi/id/product_serial
    MK2RL11

    # cat /sys/class/dmi/id/bios_version
    -[VVE134MUS-1.50]-
</code></pre>

<h3>方法五：使用 dmesg 命令</h3>

<p>dmesg 命令是在 Linux 上 syslogd 或 klogd 启动前用来记录内核消息(启动阶段的消息)的。它通过读取内核的环形缓冲区来获取数据。在排查问题或只是尝试获取系统硬件信息时，dmesg 非常有用。</p>

<pre><code>    # dmesg | grep -i DMI
    DMI: System x2530 M4: -[1214AC1]-/00Y8494, BIOS -[VVE134MUS-1.50]- 08/30/2013
</code></pre>

<h3>方法六：使用 hwinfo 命令</h3>

<p>hwinfo(硬件信息(hardware information))是另一个很棒的工具，用于检测当前系统存的硬件，并以人类可读的方式显示各种硬件模块的详细信息。</p>

<p>它报告关于 CPU、内存、键盘、鼠标、显卡、声卡、存储、网络接口、磁盘、分区、BIOS 以及桥接器等信息。它可以比其它像 lshw、dmidecode 或 inxi 等工具显示更为详细的信息。</p>

<p>hwinfo 使用 libhd 库 libhd.so 来收集系统上的硬件信息。该工具是为 openSuse 特别设计的，后来其它发行版也将它包含在其官方仓库中。</p>

<pre><code>    # hwinfo | egrep "system.hardware.vendor|system.hardware.product"
     system.hardware.vendor = 'IBM'
     system.hardware.product = 'System x2530 M4: -[1214AC1]-'
</code></pre>
]]></content>
  </entry>
  
</feed>
