<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

  <title><![CDATA[Category: system~base | kk Blog —— 通用基础]]></title>
  <link href="http://abcdxyzk.github.io/blog/cats/system~base/atom.xml" rel="self"/>
  <link href="http://abcdxyzk.github.io/"/>
  <updated>2024-03-13T12:10:10+08:00</updated>
  <id>http://abcdxyzk.github.io/</id>
  <author>
    <name><![CDATA[kk]]></name>
    
  </author>
  <generator uri="http://octopress.org/">Octopress</generator>

  
  <entry>
    <title type="html"><![CDATA[IPMI share 端口]]></title>
    <link href="http://abcdxyzk.github.io/blog/2023/07/09/ipmi-share/"/>
    <updated>2023-07-09T17:54:00+08:00</updated>
    <id>http://abcdxyzk.github.io/blog/2023/07/09/ipmi-share</id>
    <content type="html"><![CDATA[<p><a href="https://blog.csdn.net/weixin_44652157/article/details/100095620">https://blog.csdn.net/weixin_44652157/article/details/100095620</a></p>

<p>发现没有你的服务器会额外多出一个以太网口来，那个网口是专门用来访问管理控制器（BMC）的，当然也可以通过普通网口的共享模式访问BMC。</p>

<h4>什么是共享网口方式？</h4>

<p>这里要简单地提到NC-SI（Network Controller – Sideband Interface）技术，即网络控制器边带接口技术。这一技术是用来实现BMC芯片和以太网控制器之间信息传递的，它使得BMC芯片能够像使用独立管理网口那样使用主板上的网络接口。以下是共享访问模式的实现结构图：</p>

<p><img src="/images/system/20230709-10.png" alt="" /></p>

<h4>NCSI</h4>

<p>简单理解：BMC其实是一个单片机，它有自己独立的IO设备，而独立网口就是其中之一。将BMC芯片和网络控制器之间互联，并通过NC-SI技术使得BMC芯片能够使用网络控制器上的接口。
为何要使用共享网口访问管理控制器？</p>

<p>1、减少物料成本：共享访问模式能够为单机节省一根网线；</p>

<p>2、减少人力成本：如果业务网只需要接一根网线，共享方案可以减少一半的布线人力支出；</p>

<p>3、减少交换机投入：独立网口会多占用一个交换机端口，增加交换机采购数量，使用共享模式减少了这部分的支出和额外的交换机运维成本；</p>

<h4>如何实现共享网口模式？</h4>

<p>1、BIOS或者WEB bmc界面中将IPMI访问方式修改为share（共享模式）；</p>

<p>2、为共享网口独立分配一个VLAN号和IP地址，以便和业务网剥离；</p>

<p>3、在交换机端开启802.1q协议，并分配相同的VLAN号。</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Linux查看系统硬件制造商、型号和序列号]]></title>
    <link href="http://abcdxyzk.github.io/blog/2023/02/14/base-info/"/>
    <updated>2023-02-14T10:19:00+08:00</updated>
    <id>http://abcdxyzk.github.io/blog/2023/02/14/base-info</id>
    <content type="html"><![CDATA[<p><a href="https://zhuanlan.zhihu.com/p/42403181">https://zhuanlan.zhihu.com/p/42403181</a></p>

<h3>方法一：使用 dmidecode 命令</h3>

<p>dmidecode 是一个读取电脑 DMI(桌面管理接口(Desktop Management Interface))表内容并且以人类可读的格式显示系统硬件信息的工具。(也有人说是读取 SMBIOS &ndash; 系统管理 BIOS(System Management BIOS))</p>

<p>这个表包含系统硬件组件的说明，也包含如序列号、制造商、发布日期以及 BIOS 修订版本号等其它有用的信息。</p>

<p>DMI 表不仅描述了当前的系统构成，还可以报告可能的升级信息(比如可以支持的最快的 CPU 或者最大的内存容量)。</p>

<p>这将有助于分析你的硬件兼容性，比如是否支持最新版本的程序。</p>

<pre><code>    # dmidecode -t system
</code></pre>

<h3>方法二：使用 inxi 命令</h3>

<p>inxi 是 Linux 上查看硬件信息的一个灵巧的小工具，它提供了大量的选项来获取所有硬件信息，这是我在现有的其它 Linux 工具集里所没见到过的。它是从 locsmif 编写的古老的但至今看来都异常灵活的 infobash fork 出来的。</p>

<p>inxi 是一个可以快速显示系统硬件、CPU、驱动、Xorg、桌面、内核、GCC 版本、进程、内存使用以及大量其它有用信息的脚本，也可以用来做技术支持和调试工具。</p>

<pre><code>    # inxi -M
    Machine: Device: server System: IBM product: N/A v: 0B serial: MK2RL11
     Mobo: IBM model: 00Y8494 serial: 37M17D UEFI: IBM v: -[VVE134MUS-1.50]- date: 08/30/2013
</code></pre>

<h3>方法三：使用 lshw 命令</h3>

<p>lshw (指硬件监听器(Hardware Lister))是一个小巧灵活的工具，可以生成如内存配置、固件版本、主板配置、CPU 版本和速度、缓存配置、USB、网卡、显卡、多媒体、打印机以及总线速度等机器中各种硬件组件的详细报告。</p>

<p>它通过读取 /proc 目录下各种文件的内容和 DMI 表来生成硬件信息。</p>

<p>lshw 必须以超级用户的权限运行来检测完整的硬件信息，否则它只汇报部分信息。lshw 里有一个叫做 class 的特殊选项，它可以以详细的模式显示特定的硬件信息。</p>

<pre><code>    # lshw -C system
    enal-dbo01t
     description: Blade
     product: System x2530 M4: -[1214AC1]-
     vendor: IBM
     version: 0B
     serial: MK2RL11
     width: 64 bits
     capabilities: smbios-2.7 dmi-2.7 vsyscall32
     configuration: boot=normal chassis=enclosure family=System X uuid=762A99BF-6916-450F-80A6-B2E9E78FC9A1
</code></pre>

<h3>方法四：使用 /sys 文件系统</h3>

<p>内核在 /sys 目录下的文件中公开了一些 DMI 信息。因此，我们可以通过如下方式运行 grep 命令来轻易地获取机器类型。</p>

<pre><code>    # grep "" /sys/class/dmi/id/[pbs]*
</code></pre>

<p>或者，可以使用 cat 命令仅打印出特定的详细信息。</p>

<pre><code>    # cat /sys/class/dmi/id/board_vendor
    IBM

    # cat /sys/class/dmi/id/product_name
    System x2530 M4: -[1214AC1]-

    # cat /sys/class/dmi/id/product_serial
    MK2RL11

    # cat /sys/class/dmi/id/bios_version
    -[VVE134MUS-1.50]-
</code></pre>

<h3>方法五：使用 dmesg 命令</h3>

<p>dmesg 命令是在 Linux 上 syslogd 或 klogd 启动前用来记录内核消息(启动阶段的消息)的。它通过读取内核的环形缓冲区来获取数据。在排查问题或只是尝试获取系统硬件信息时，dmesg 非常有用。</p>

<pre><code>    # dmesg | grep -i DMI
    DMI: System x2530 M4: -[1214AC1]-/00Y8494, BIOS -[VVE134MUS-1.50]- 08/30/2013
</code></pre>

<h3>方法六：使用 hwinfo 命令</h3>

<p>hwinfo(硬件信息(hardware information))是另一个很棒的工具，用于检测当前系统存的硬件，并以人类可读的方式显示各种硬件模块的详细信息。</p>

<p>它报告关于 CPU、内存、键盘、鼠标、显卡、声卡、存储、网络接口、磁盘、分区、BIOS 以及桥接器等信息。它可以比其它像 lshw、dmidecode 或 inxi 等工具显示更为详细的信息。</p>

<p>hwinfo 使用 libhd 库 libhd.so 来收集系统上的硬件信息。该工具是为 openSuse 特别设计的，后来其它发行版也将它包含在其官方仓库中。</p>

<pre><code>    # hwinfo | egrep "system.hardware.vendor|system.hardware.product"
     system.hardware.vendor = 'IBM'
     system.hardware.product = 'System x2530 M4: -[1214AC1]-'
</code></pre>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[libvirtd 虚拟网卡 virbr0 192.168.122.1]]></title>
    <link href="http://abcdxyzk.github.io/blog/2022/10/22/base-virbr0/"/>
    <updated>2022-10-22T11:14:00+08:00</updated>
    <id>http://abcdxyzk.github.io/blog/2022/10/22/base-virbr0</id>
    <content type="html"><![CDATA[<h4>dnsmasq不会自动停</h4>

<pre><code>    service libvirtd stop
    systemctl stop libvirtd.service

    service libvirtd status
</code></pre>

<p>还是有dnsmasq进程，手动kill</p>

<hr />

<p><a href="https://blog.csdn.net/cqszpx/article/details/126730428">https://blog.csdn.net/cqszpx/article/details/126730428</a></p>

<p>在CentOS 7的安装过程中如果有选择相关虚拟化的的服务安装系统后，启动网卡时会发现有一个以网桥连接的私网地址的virbr0网卡，这个是因为在虚拟化中有使用到libvirtd服务生成的，如果不需要可以关闭后去掉：</p>

<h4>一、查看IP及网桥设备</h4>

<pre><code>    [root@etc ~]# ifconfig //查看IP地址

    [root@etc ~]# brctl show //查看网桥
    bridge name bridge id STP enabled interfaces
    virbr0 8321.5254115cdv00 yes virbr0-nic

    [root@etc ~]#
</code></pre>

<h4>二、删除网桥</h4>

<pre><code>    [root@etc ~]# ifconfig virbr0 down
    [root@etc ~]# brctl delbr virbr0 //删除网桥
</code></pre>

<h4>三、禁用开机服务</h4>

<pre><code>    [root@etc ~]# systemctl disable libvirtd.service //禁用libvirtd服务开机自启动
    Removed symlink /etc/systemd/system/multi-user.target.wants/libvirtd.service.
    Removed symlink /etc/systemd/system/sockets.target.wants/virtlockd.socket.
    Removed symlink /etc/systemd/system/sockets.target.wants/virtlogd.socket.

    [root@etc ~]# systemctl mask libvirtd.service
    Created symlink from /etc/systemd/system/libvirtd.service to /dev/null.
</code></pre>

<p>再次使用ifconfig查看，即可发现virbr0不在了</p>

<h4>当然也可直接将libvirtd服务卸载</h4>

<p>这样也就不会生成虚拟网卡，更是一劳永逸，待需要使用时，再安装该服务即可。操作命令如下：</p>

<pre><code>    yum remove libvirt-libs.x86_64
</code></pre>

<h4>systemctl mask 和 systemctl disable</h4>

<p>disable是禁用的开机自启，但是其他服务仍可以调用开启disable的服务</p>

<p>而mask是屏蔽服务，mask了的服务，不可以被调用</p>

<p>enable和disable相对应的</p>

<p>unmask和mask相对应的</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[VirtualBox虚拟机内的系统时间调整]]></title>
    <link href="http://abcdxyzk.github.io/blog/2022/09/24/vm-time/"/>
    <updated>2022-09-24T23:34:00+08:00</updated>
    <id>http://abcdxyzk.github.io/blog/2022/09/24/vm-time</id>
    <content type="html"><![CDATA[<p><a href="https://www.cnblogs.com/Thenext/p/13780745.html">https://www.cnblogs.com/Thenext/p/13780745.html</a></p>

<ol>
<li><p>先到管理工具->服务，将“windows time”服务停止并设为手动启动。</p></li>
<li><p>打开虚拟机内的注册表，找到</p></li>
</ol>


<p>HKEY_LOCAL_MACHINE\SYSTEM\CurrentControlSet\Services\VBoxService项下的ImagePath键，将其值修改为system32\VBoxService.exe &ndash;disable-timesync</p>

<ol>
<li>虚拟机重启一下，再调整日期。</li>
</ol>


<p>以上是针对虚拟windows系统。</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[关闭非业务端口]]></title>
    <link href="http://abcdxyzk.github.io/blog/2022/08/21/port/"/>
    <updated>2022-08-21T21:22:00+08:00</updated>
    <id>http://abcdxyzk.github.io/blog/2022/08/21/port</id>
    <content type="html"><![CDATA[<h3>查看本机监听的端口</h3>

<pre><code>    netstat -ltunp

    l: listen
    t: tcp
    u: udp
    n: --numeric 不解析名称
    p: --programs
</code></pre>

<pre><code>    netstat -ltunp
    Active Internet connections (only servers)
    Proto Recv-Q Send-Q Local Address           Foreign Address         State       PID/Program name
    tcp        0      0 0.0.0.0:22              0.0.0.0:*               LISTEN      1523/sshd
    tcp        0      0 127.0.0.1:631           0.0.0.0:*               LISTEN      1312/cupsd
    tcp        0      0 127.0.0.1:25            0.0.0.0:*               LISTEN      1978/master
    tcp        0      0 0.0.0.0:111             0.0.0.0:*               LISTEN      1062/rpcbind
    tcp        0      0 192.168.122.1:53        0.0.0.0:*               LISTEN      2008/dnsmasq
    tcp6       0      0 :::22                   :::*                    LISTEN      1523/sshd
    tcp6       0      0 ::1:631                 :::*                    LISTEN      1312/cupsd
    tcp6       0      0 ::1:25                  :::*                    LISTEN      1978/master
    tcp6       0      0 :::443                  :::*                    LISTEN      1999/httpd
    tcp6       0      0 :::3306                 :::*                    LISTEN      1717/mariadbd
    tcp6       0      0 :::111                  :::*                    LISTEN      1062/rpcbind
    tcp6       0      0 :::80                   :::*                    LISTEN      1999/httpd
    udp        0      0 0.0.0.0:54212           0.0.0.0:*                           1110/avahi-daemon:
    udp        0      0 192.168.122.1:53        0.0.0.0:*                           2008/dnsmasq
    udp        0      0 0.0.0.0:67              0.0.0.0:*                           2012/dnsmasq
    udp        0      0 0.0.0.0:111             0.0.0.0:*                           1062/rpcbind
    udp        0      0 127.0.0.1:323           0.0.0.0:*                           1079/chronyd
    udp        0      0 0.0.0.0:806             0.0.0.0:*                           1062/rpcbind
    udp        0      0 0.0.0.0:5353            0.0.0.0:*                           1110/avahi-daemon:
    udp        0      0 0.0.0.0:44291           0.0.0.0:*                           53849/local
    udp6       0      0 :::111                  :::*                                1062/rpcbind
    udp6       0      0 ::1:323                 :::*                                1079/chronyd
    udp6       0      0 :::806                  :::*                                1062/rpcbind
</code></pre>

<h3>1. avahi-daemon</h3>

<p>Avahi允许程序在不需要进行手动网络配置的情况 下，在一个本地网络中发布和获知各种服务和主机。例如，当某用户把他的计算机接入到某个局域网时，如果他的机器运行有Avahi服务，则Avahi程式自 动广播，从而发现网络中可用的打印机、共享文件和可相互聊天的其他用户。这有点象他正在接收局域网中的各种网络广告一样。</p>

<p>Linux下系统实际启动的进程名，是avahi-daemon</p>

<p>除非你有兼容的设备或使用 zeroconf 协议的服务，否则应该关闭它。</p>

<pre><code>    service avahi-daemon stop
    service avahi-daemon.socket stop
    chkconfig avahi-daemon off
</code></pre>

<h3>2. port 631</h3>

<p>目前的Linux发行版本基本上都使用cups作为Linux下管理打印的服务应用。CUPS软件为Unix/Linux用户提供了有效而可靠的方式来管理打印的方法。它生来就支持IPP，并有LPD、SMB和JetDirect接口。CUPS本身可以提供网络打印机功能，使用它可以非常方便的令Linux与Linux之间、Linux与Windows之间实现打印共享。</p>

<p>使用浏览器访问<a href="http://127.0.0.1:631/">http://127.0.0.1:631/</a></p>

<pre><code>    service cups stop
    service cups.socket stop
    service cups.path stop

    chkconfig cups off
</code></pre>

<h3>3. port 25</h3>

<p>SMTP 邮件相关</p>

<pre><code>    lsof -i tcp:25
    COMMAND  PID USER   FD   TYPE DEVICE SIZE/OFF NODE NAME
    master  1957 root   13u  IPv4  21979      0t0  TCP localhost:smtp (LISTEN)
    master  1957 root   14u  IPv6  21980      0t0  TCP localhost:smtp (LISTEN)
</code></pre>

<pre><code>    systemctl list-unit-files | grep post
    systemctl disable --now postfix.service
</code></pre>

<h3>port 53 67</h3>

<p>dnsmasq</p>

<p>Dnsmasq提供了DNS缓存、DHCP服务与Tftp服务功能。本文将用它在Linux中部署DNS服务，作为域名解析服务器(DNS)，Dnsmasq可以通过缓存DNS请求来提高对访问过的网址的连接速度。作为DHCP服务器，Dnsmasq可以为局域网电脑提供内网ip地址和路由。DNS和DHCP两个功能可以同时或分别单独实现。Dnsmasq轻量且易配置，适用于个人用户或少于50台主机的网络。此外它还自带了一个PXE服务器。</p>

<h3>port 323</h3>

<p>Chrony是NTP（Network Time Protocol，网络时间协议，服务器时间同步的一种协议）的另一种实现，与ntpd不同，它可以更快且更准确地同步系统时钟，最大程度的减少时间和频率误差。</p>

<p>在CentOS6中，默认是使用ntpd来同步时间的，但ntpd同步时间并不理想，有可能需要数小时来同步时间。而且ntp也已经很老了。所以在Centos7中换成了chrony来实现时间同步。chrony并且兼容ntpd监听在udp123端口上，自己则监听在udp的323端口上。</p>

<h3>port 111</h3>

<p>NFS文件共享.NFS依靠远程过程调用(RPC)在客户端和服务器端路由请求。在Linux下RPC服务由portmap服务控制.</p>

<p>为了共享和加载NFS文件系统，下面的服务要一起工作:</p>

<pre><code>    * nfs - 启动相应RPC服务进程来服务对于NFS文件系统的请求.
    * nfslock - 一个可选的服务，用于启动相应的RPC进程，允许NFS客户端在服务器上对文件加锁.
    * portmap - Linux的RPC服务,它响应RPC服务的请求和与请求的RPC服务建立连接.
</code></pre>

<p>下面的RPC进程在后台一起工作服务于NFS服务：</p>

<pre><code>    * rpc.mountd - 这个进程接受来自NFS客户端的加载请求和验证请求的文件系统正在被输出.这个进程由NFS服务自动启动，不需要用户的配置.
    * rpc.nfsd - 这个进程是NFS服务器.它和Linux核心一起工作来满足NFS客户端的动态需求，例如提供为每个NFS客户端的每次请求服务器线程.这个进程对应于nfs服务.
    * rpc.lockd - 一个可选的进程，它允许NFS客户端在服务器上对文件加锁.这个进程对应于nfslock服务.
    * rpc.statd - 这个进程实现了网络状态监控(NSM)RPC协议,通知NFS客户端什么时候一个NFS服务器非正常重启动.这个进程被nfslock服务自动启动，不需要用户的配置.
    * rpc.rquotad - 这个进程对于远程用户提供用户配额信息. 这个进程被nfs服务自动启动，不需要用户的配置.

    停用命令
    service nfslock stop
    chkconfig nfslock off

    rpcbind服务停止命令
    service portmap stop
</code></pre>

<p><a href="https://blog.csdn.net/tjjingpan/article/details/81237308">https://blog.csdn.net/tjjingpan/article/details/81237308</a></p>

<p><a href="http://www.linuxfly.org/post/72/">http://www.linuxfly.org/post/72/</a></p>

<p><a href="https://blog.51cto.com/holy2010/343888">https://blog.51cto.com/holy2010/343888</a></p>

<p><a href="http://www.manongjc.com/detail/23-crrktpmgggcujfu.html">http://www.manongjc.com/detail/23-crrktpmgggcujfu.html</a></p>

<p><a href="http://www.wjhsh.net/pipci-p-12871993.html">http://www.wjhsh.net/pipci-p-12871993.html</a></p>

<p><a href="https://www.cnblogs.com/archoncap/p/6179666.html">https://www.cnblogs.com/archoncap/p/6179666.html</a></p>
]]></content>
  </entry>
  
</feed>
