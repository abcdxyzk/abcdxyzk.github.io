<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

  <title><![CDATA[Category: system~fs | kk Blog —— 通用基础]]></title>
  <link href="http://abcdxyzk.github.io/blog/cats/system~fs/atom.xml" rel="self"/>
  <link href="http://abcdxyzk.github.io/"/>
  <updated>2024-07-15T14:01:10+08:00</updated>
  <id>http://abcdxyzk.github.io/</id>
  <author>
    <name><![CDATA[kk]]></name>
    
  </author>
  <generator uri="http://octopress.org/">Octopress</generator>

  
  <entry>
    <title type="html"><![CDATA[查看raid信息]]></title>
    <link href="http://abcdxyzk.github.io/blog/2023/02/01/raid/"/>
    <updated>2023-02-01T14:57:00+08:00</updated>
    <id>http://abcdxyzk.github.io/blog/2023/02/01/raid</id>
    <content type="html"><![CDATA[<p><a href="https://www.bbsmax.com/A/n2d9y8r0dD/">https://www.bbsmax.com/A/n2d9y8r0dD/</a></p>

<p>wmic csproduct get name    查看服务器型号</p>

<p>wmic bios get serialnumber 查看序列号</p>

<hr />

<p><a href="https://blog.csdn.net/suankuang/article/details/106242025">https://blog.csdn.net/suankuang/article/details/106242025</a></p>

<p><a href="https://www.51sjk.com/b19b157342/">https://www.51sjk.com/b19b157342/</a></p>

<p><a href="https://blog.csdn.net/wojiuwangla/article/details/113940417">https://blog.csdn.net/wojiuwangla/article/details/113940417</a></p>

<p><a href="https://www.bbsmax.com/A/KE5QYRo45L/">https://www.bbsmax.com/A/KE5QYRo45L/</a></p>

<p><a href="https://it.cha138.com/shida/show-5212.html">https://it.cha138.com/shida/show-5212.html</a></p>

<h2>linux 查看信息</h2>

<h4>软件raid，禁用</h4>

<pre><code>    cat /proc/mdstat
</code></pre>

<h4>硬件raid</h4>

<p>查看硬件是否支持RAID
<code>
    lspci | grep -i RAID
    lspci | grep -i smart
</code></p>

<p>查看系统是否配置RAID
<code>
    dmesg | grep -i raid
    dmesg | grep -i smart
</code></p>

<p>如上所示，在系统日志中可以看到存在RAID设备，以及设备型号等信息。或者通过以下命令查看:
<code>
    cat /proc/scsi/scsi
</code></p>

<h4>确认RAID卡型号</h4>

<pre><code>    lspci -v -s $(lspci | grep -i raid | awk '{print $1}')

    lspci | grep -i smart
</code></pre>

<p>从上述返回信息得到RAID卡型号：Subsystem: xxx</p>

<h2>根据型号查看服务器RAID磁盘详情</h2>

<h3>HP</h3>

<h4>linux</h4>

<p><a href="https://github.com/abcdxyzk/abcdxyzk.github.io_files/raw/master/system/ssacli-4.21-7.0.x86_64.rpm">ssacli-4.21-7.0.x86_64.rpm</a></p>

<p><a href="https://support.hpe.com/connect/s/softwaredetails?language=zh_CN&amp;softwareId=MTX_521fc533ba8f468f9ad9db20e4">https://support.hpe.com/connect/s/softwaredetails?language=zh_CN&amp;softwareId=MTX_521fc533ba8f468f9ad9db20e4</a></p>

<pre><code>    rpm -ivh ssacli-4.21-7.0.x86_64.rpm

    ssacli ctrl all show config
    ssacli ctrl all show config detail
</code></pre>

<p><a href="https://github.com/abcdxyzk/abcdxyzk.github.io_files/raw/master/system/hpacucli-9.40-12.0.x86_64.rpm">hpacucli-9.40-12.0.x86_64.rpm</a></p>

<p><a href="https://mirror.nforce.com/pub/software/raidtools/">https://mirror.nforce.com/pub/software/raidtools/</a></p>

<pre><code>    rpm -ivh hpacucli-9.40-12.0.x86_64.rpm

    hpacucli ctrl all show config
    hpacucli ctrl all show config detail
</code></pre>

<h4>win</h4>

<h5>Smart Array P410i</h5>

<p><a href="https://support.hpe.com/connect/s/softwaredetails?language=zh_CN&amp;softwareId=MTX_33fe6fcf4fcb4beab8fee4d2dc">https://support.hpe.com/connect/s/softwaredetails?language=zh_CN&amp;softwareId=MTX_33fe6fcf4fcb4beab8fee4d2dc</a></p>

<p><a href="https://github.com/abcdxyzk/abcdxyzk.github.io_files/raw/master/system/HP%20ProLiant%20Array%20Configuration%20Utility%20CLI%20for%20Windows%2064-bit%209.40.12.0.exe">HP ProLiant Array Configuration Utility CLI for Windows 64-bit 9.40.12.0.exe</a></p>

<pre><code>    C:\Documents and Settings&gt;"c:\Program Files\Compaq\Hpacucli\Bin\hpacucli.exe" ctrl all show config
</code></pre>

<p>或者用图形界面 HP Array Configuration Utility 8.70.9.exe</p>

<h5>Smart Array P830i</h5>

<p>如果系统自带了 Smart Storage Administrator CLI 则：</p>

<pre><code>    C:\Windows\system32&gt;"c:\Program Files\HP\hpssacli\bin\hpssacli.exe" ctrl all show config
</code></pre>

<p>不然只能用图形界面 Smart Storage Administrator</p>

<p><a href="https://support.hpe.com/connect/s/softwaredetails?language=zh_CN&amp;softwareId=MTX_f9eb4d247d3b4488b87976b33d">https://support.hpe.com/connect/s/softwaredetails?language=zh_CN&amp;softwareId=MTX_f9eb4d247d3b4488b87976b33d</a></p>

<p><a href="https://support.hpe.com/connect/s/softwaredetails?language=zh_CN&amp;softwareId=MTX_891c6d6803044e5db3e0c2a5ab">https://support.hpe.com/connect/s/softwaredetails?language=zh_CN&amp;softwareId=MTX_891c6d6803044e5db3e0c2a5ab</a></p>

<p>HPE Smart Storage Administrator 2.40.13.0.exe</p>

<p>HPE Smart Storage Administrator 3.40.3.0.exe</p>

<p>HPE Smart Storage Administrator 4.21.7.0.exe</p>

<p><a href="https://support.hpe.com/connect/s/softwaredetails?language=zh_CN&amp;softwareId=MTX_1d00dad72f544c5db131a7a5e4">https://support.hpe.com/connect/s/softwaredetails?language=zh_CN&amp;softwareId=MTX_1d00dad72f544c5db131a7a5e4</a></p>

<p>HPE Smart Storage Administrator CLI for Windows 64-bit 4.21.7.0.exe 装不上。。。</p>

<h5>离线 HPE 智能存储管理员（HPE SSA）</h5>

<p>www.ylys.net/post/946.html</p>

<p><a href="https://support.hpe.com/connect/s/softwaredetails?language=zh_CN&amp;softwareId=MTX_321a88714bff4279abf175b9bd">https://support.hpe.com/connect/s/softwaredetails?language=zh_CN&amp;softwareId=MTX_321a88714bff4279abf175b9bd</a></p>

<p>离线 HPE 智能存储管理员（Offline Array Configuration，HPE SSA）提供可以安装、刻录到 CD/DVD，或者使用面向 Windows 的 HP USB Key 实用程序存储到 USB 闪存盘或 SD 卡的 ISO 镜像。此可交付的内容允许用户在主机操作系统加载前启动到他们可以选择多种配置实用程序（HPE SSA、HPESSACLI 和 HPESSASCRIPTING）的环境。HPE 智能存储管理员（HPE SSA）可帮助您配置、管理、诊断和监控 HP ProLiant 智能阵列管理器，且现在还可支持其他存储设备，如 主机总线适配器（HBAs）、HP 存储控制器，未来还可支持 SCSI Express 驱动器以及 SAS 交换机设备。HPE SSA 更新了 HP 阵列配置实用程序或 ACU 的设计，并可在上线时为多种智能存储计划提供新的特性和功能。HPE SSA 可让您像以前一样配置和管理存储，但是现在配备了更多特性、功能和支持设备。现有 ACU 脚本只需进行较少的变更（如按照顺序调用相应二进制或可执行命令）便可维持兼容性。</p>

<h3>Inspur 等 Broadcom / LSI MegaRAID SAS 9361-8i</h3>

<p><a href="https://github.com/abcdxyzk/abcdxyzk.github.io_files/raw/master/system/megaraid-utils-1.8-2.el7.x86_64.rpm">megaraid-utils-1.8-2.el7.x86_64.rpm</a></p>

<p><a href="https://repo.aerisnetwork.com/stable/centos/7/x86_64/megaraid-utils-1.8-2.el7.x86_64.rpm">https://repo.aerisnetwork.com/stable/centos/7/x86_64/megaraid-utils-1.8-2.el7.x86_64.rpm</a></p>

<p>ln -s /opt/megaraid/megacli /usr/bin/MegaCli</p>

<h4>查看raid 状态</h4>

<pre><code>    MegaCli64 -LdInfo -lAll -aALL

    State               : Degraded（降级）
    State               : Offline（离线）
    State               : Optimal（正常）
    Number Of Drives    : 2  RAID组包含2块磁盘。
</code></pre>

<h4>查看硬盘所有信息</h4>

<pre><code>    /opt/megaraid/megacli -PDList -aALL

    Slot Number:              ---硬盘槽号
    PD Type:                  -----磁盘接口类型
    InquiryData:              -----硬盘的序列号、型号、固件版本
    Raw Size:                 -----磁盘原始大小
    NonCoerced Size:          -----磁盘标准大小
    CoercedSize:              ------磁盘最大可用大小
    Medai Error Count:        ------表示磁盘可能错误，可能是磁盘有坏道，这个值不为0值得注意，数值越大，危险系数越高。
    Other Error Count:        ------表示磁盘可能存在松动，可能需要重新再插入。
    Predictive Failure Count: -----预测故障计数
</code></pre>

<h4>查看硬盘数量以及有无损坏</h4>

<pre><code>    /opt/megaraid/megacli -PDList -aALL

    Firmware state: Online, Spun Up 磁盘正常
    Firmware state: Unconfigured(good), Spun Up 磁盘已安装，但未启用
    Firmware state: Unconfigured(bad) 故障
    Firmware state: Failed 故障
    Firmware state: Rebuild 重建，一般在更换磁盘时显示
</code></pre>

<h4>查看raid级别, 由哪些硬盘组成的</h4>

<pre><code>    /opt/megaraid/megacli -LdPdInfo -aALL

    raid级别:
        RAIDLevel : Primary-0, Secondary-0, RAID Level Qualifier-0     这就是raid0           
        0 0 0 是raid0    
        1 0 0 是raid1  
        5 0 3 是raid5  
        1 3 0 是raid10
        raid1 还需要结合Span Depth的值来判断
        Span Depth : 2 表示共2个RAID1盘组做成了RAID10，1表示1个RAID1盘组
        还有一种情况：Primary-1， Secondary-3， RAID LevelQualifier-0 也是表示 RAID-10;

    也可以这么显示raid级别，输入就会返回，这种的基本准确

    MegaCli64 -ShowSummary -aALL | grep "RAID Level"
</code></pre>

<h4>win</h4>

<p><a href="https://www.intel.com/content/www/us/en/download/19041/intel-raid-web-console-3-rwc3-for-windows.html">https://www.intel.com/content/www/us/en/download/19041/intel-raid-web-console-3-rwc3-for-windows.html</a></p>

<p>storcli <a href="https://github.com/abcdxyzk/abcdxyzk.github.io_files/raw/master/system/Intel_StorCLI_007.1907.0000.0000.zip">Intel_StorCLI_007.1907.0000.0000.zip</a></p>

<p>MegaCli <a href="https://github.com/abcdxyzk/abcdxyzk.github.io_files/raw/master/system/Win_CliKL_8.04.07.zip">Win_CliKL_8.04.07.zip</a></p>

<p><a href="https://www.cnblogs.com/luxiaodai/p/9878747.html">https://www.cnblogs.com/luxiaodai/p/9878747.html</a></p>

<p><a href="https://www.dianjilingqu.com/187111.html">https://www.dianjilingqu.com/187111.html</a></p>

<p>MegaCli 是LSI公司官方提供的SCSI卡管理工具，由于LSI被收购变成了现在的Broadcom，所以现在想下载MegaCli，需要去Broadcom官网查找Legacy产品支持，</p>

<p>现在官方有storcli，storcli已经基本代替了megacli，整合了LSI和3ware所有产品。</p>

<pre><code>    storcli64 show [all]  显示raid卡相关信息、raid卡高级软件信息

    storcli64 /c0 show    显示控制器0的信息
</code></pre>

<h3>Adaptec</h3>

<p><a href="https://storage.microsemi.com/en-us/support/raid/sas_raid/asr-8805/">https://storage.microsemi.com/en-us/support/raid/sas_raid/asr-8805/</a></p>

<p><a href="https://www.cnblogs.com/my-show-time/p/14701882.html">https://www.cnblogs.com/my-show-time/p/14701882.html</a></p>

<p>linux <a href="https://github.com/abcdxyzk/abcdxyzk.github.io_files/raw/master/system/Arcconf-3.07-23850.x86_64.rpm">Arcconf-3.07-23850.x86_64.rpm</a></p>

<p>window <a href="https://github.com/abcdxyzk/abcdxyzk.github.io_files/raw/master/system/arcconf_v3_07_23850_win.zip">arcconf_v3_07_23850_win.zip</a></p>

<h4>arcconf</h4>

<pre><code>    arcconf LIST                #查询整列卡信息
    arcconf GETCONFIG 1 AD      # 查询 Controller #1 的适配器信息
    arcconf GETCONFIG 1 LD      # 查询 Controller #1 的逻辑设备信息
    arcconf GETCONFIG 1 PD      # 查询 Controller #1 的物理设备信息
    arcconf GETCONFIG 1 AR      # 查询 Controller #1 的阵列信息
    arcconf GETCONFIG 1 AL      # 查询 Controller #1 的所有信息
    arcconf GETCONFIG 1 LD|grep 'Logical Device number'     # 查询 Controller #1 的所有逻辑设备编号
    arcconf GETCONFIG 1 LD|grep 'Logical Device name'       # 查询 Controller #1 的所有逻辑设备名称
    arcconf GETCONFIG 1 PD|grep 'Device #'                  # 查询 Controller #1 的所有物理设备编号
    arcconf GETCONFIG 1 LD|grep -E 'Logical Device number|Device:|Slot:'                # 查询 Controller #1 的所有逻辑设备对应的物理设备
    arcconf GETCONFIG 1 LD|grep -E 'Logical Device number|Device:|Slot:'                # 查询 Controller #1 的所有逻辑设备对应的物理设备
    arcconf GETCONFIG 1 LD|grep -E 'Logical Device number|RAID level|Device:|Slot:'     # 查询 Controller #1 的所有逻辑设备的RAID level以及物理设备
    arcconf GETCONFIG 1 LD|grep -E 'Logical Device number|Logical Device name|RAID level|Device:|Slot:'     # 查询 Controller #1 的所有逻辑设备的关键信息
</code></pre>

<h3>LSI的阵列卡2008/3008</h3>

<p><a href="https://docs.broadcom.com/docs/SAS3IRCU_P16.zip_p">https://docs.broadcom.com/docs/SAS3IRCU_P16.zip_p</a></p>

<p>linux,window <a href="https://github.com/abcdxyzk/abcdxyzk.github.io_files/raw/master/system/SAS3IRCU_P16.zip">SAS3IRCU_P16.zip</a></p>

<pre><code>    lspci | grep -i SAS
</code></pre>

<pre><code>    sas3ircu list   #查看所有控制器
    sas3ircu 0 display  #查看控制器0下所有硬盘信息
    sas3ircu 0 status  #查看控制器0的状态
</code></pre>

<h3>LSI SAS2108/2208/3108阵列卡</h3>

<p>storcli64</p>

<p><a href="https://iknow.lenovo.com.cn/detail/dc_178452.html">https://iknow.lenovo.com.cn/detail/dc_178452.html</a></p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[LVM 扩容]]></title>
    <link href="http://abcdxyzk.github.io/blog/2023/01/01/lvm-extend/"/>
    <updated>2023-01-01T16:25:00+08:00</updated>
    <id>http://abcdxyzk.github.io/blog/2023/01/01/lvm-extend</id>
    <content type="html"><![CDATA[<p><a href="https://www.cnblogs.com/yy9knsg/p/16552494.html">https://www.cnblogs.com/yy9knsg/p/16552494.html</a></p>

<p><a href="https://tool.4xseo.com/article/200995.html">https://tool.4xseo.com/article/200995.html</a></p>

<pre><code>    pvdisplay

    vgdisplay

    lvdisplay
</code></pre>

<h4>初始化分区</h4>

<pre><code>    fdisk /dev/vdx
    n

    t
    L
    选 8e LVM分区


    pvcreate /dev/vdx1
</code></pre>

<h4>将分区加入到虚拟卷组名</h4>

<pre><code>    # vgextend 虚拟卷组名 新增的分区

    vgextend centos /dev/vdx1
</code></pre>

<h4>再次查看卷组情况</h4>

<pre><code>    vgdisplay
</code></pre>

<h4>查看当前磁盘情况</h4>

<pre><code>    df -h
    记下需要扩展的文件系统名，例如 /dev/mapper/centos-root

    lvdisplay
    记下需要扩展的文件系统名，例如 /dev/centos/root
</code></pre>

<p>两个是一样的</p>

<pre><code>    ls /dev/centos/root -l
    lrwxrwxrwx. 1 root root 7 Dec 20 20:11 /dev/centos/root -&gt; ../dm-0

    ls -l /dev/mapper/centos-root 
    lrwxrwxrwx. 1 root root 7 Dec 20 20:11 /dev/mapper/centos-root -&gt; ../dm-0
</code></pre>

<h4>扩容已有的卷组容量</h4>

<pre><code>    lvextend -L +需要扩展的容量 需要扩展的文件系统名 

    lvextend -L +29G /dev/mapper/centos-root
</code></pre>

<h4>以上只是卷的扩容，然后我们需要将文件系统扩容</h4>

<pre><code>    cat /etc/fstab | grep centos-root

    /dev/mapper/centos-root /                       xfs     defaults        0 0
</code></pre>

<p>这里可以看到，文件系统是xfs，所以需要xfs的命令来扩展磁盘空间</p>

<pre><code>    xfs_growfs 文件系统名

    xfs_growfs /dev/mapper/centos-root
</code></pre>

<p>df -h 可以看到，现在已经扩容成功了！</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[磁盘 partx，lsblk，blkid，partprobe]]></title>
    <link href="http://abcdxyzk.github.io/blog/2021/07/21/partx-lsblk/"/>
    <updated>2021-07-21T14:00:00+08:00</updated>
    <id>http://abcdxyzk.github.io/blog/2021/07/21/partx-lsblk</id>
    <content type="html"><![CDATA[<p><a href="https://blog.csdn.net/qq_36462472/article/details/84106868">https://blog.csdn.net/qq_36462472/article/details/84106868</a></p>

<h3>总结</h3>

<p>在使用fdisk命令创建分区后，可以使用partx和partprobe使系统内核加载分区信息，然后使用lsblk或partx -s 设备名 查看修改后的设备分区信息，给分区做上文件系统后，可以使用blkid命令查看设备信息，以及其文件系统等信息。</p>

<p>使用<code>partx -s /</code> <code>partx -l</code> 查看分区信息如果出错，可能是信息未被登记，可使用partx -a 设备名 来添加，再进行查看。</p>

<h3>patrx</h3>

<p>修改磁盘分区表后，无需重启，用partx命令告诉内核，分区已改动，内核可以读入新的分区表信息</p>

<p>/proc/partitions 记录了系统中所有硬盘及其上面的分区，包括已挂载和未挂载的。</p>

<p>有些硬盘没有记录分区信息，可能是没有分区，也可能是未记录</p>

<p>对于分区完成，但是尚未挂载的硬盘分区，partx告诉内核去做登记，已备挂载。</p>

<p>partx告诉内核去识别，登记某个硬盘上的分区信息。并不是加载，只是识别并记录而已，或者删除某个分区的信息。</p>

<pre><code>    [root@localhost ~]# partx --help

    Usage:
     partx [-a|-d|-s|-u] [--nr &lt;n:m&gt; | &lt;partition&gt;] &lt;disk&gt;

    Options:
     -a, --add            add specified partitions or all of them
     -d, --delete         delete specified partitions or all of them
     -s, --show           list partitions

     -u, --update         update specified partitions or all of them
     -b, --bytes          print SIZE in bytes rather than in human readable format
     -g, --noheadings     don't print headings for --show
     -n, --nr &lt;n:m&gt;       specify the range of partitions (e.g. --nr 2:4)
     -o, --output &lt;type&gt;  define which output columns to use
     -P, --pairs          use key="value" output format
     -r, --raw            use raw output format
     -t, --type &lt;type&gt;    specify the partition type (dos, bsd, solaris, etc.)
     -v, --verbose        verbose mode

     -h, --help     display this help and exit
     -V, --version  output version information and exit

    Available columns (for --show, --raw or --pairs):
             NR  partition number
          START  start of the partition in sectors
            END  end of the partition in sectors
        SECTORS  number of sectors
           SIZE  human readable size
           NAME  partition name
           UUID  partition UUID
           TYPE  partition type hex or uuid
          FLAGS  partition flags
         SCHEME  partition table type (dos, gpt, ...)

    For more details see partx(8).
</code></pre>

<pre><code>    partx命令：
        -a 设备： 登记某块盘上的所有分区信息。如果分区信息有记录，则报错。
        -d 设备： 删除内核中关于某磁盘的所有分区的记录。（不是卸载）
        -s 设备 ：显示磁盘的分区信息
</code></pre>

<p>通过partx工具让内核重读磁盘分区表信息：</p>

<pre><code>    partx -d /dev/sdb  #因为内核中存在部分未调整磁盘的信息，故先将所有信息清零
    partx -a /dev/sdb  #添加调整后的磁盘分区信息
    partx -s /dev/sdb  #显示磁盘分区信息

    NR   START       END   SECTORS SIZE NAME UUID
     1    2048   2099199   2097152   1G      
     2 2099200 419430399 417331200 199G
</code></pre>

<h3>lsblk命令</h3>

<p>列出所有可用块设备的信息，而且还能显示他们之间的依赖关系，但是它不会列出RAM盘的信息。块设备有硬盘，闪存盘，CD-ROM等等。</p>

<p>lsblk -f 也可以查看 UUID</p>

<p>lsblk和df的区别：</p>

<p>lsblk 查看的是block device，也就是逻辑磁盘的大小</p>

<p>df 查看的是file system，也就是文件系统层的磁盘大小，并且已挂载</p>

<pre><code>    [root@localhost ~]# lsblk -f
    NAME            FSTYPE      LABEL           UUID                                   MOUNTPOINT
    sda                                                                                
    ├─sda1          xfs                         f19cfd60-9c16-4ef9-bebf-a173e11ff163   /boot
    └─sda2          LVM2_member                 ZTRWNx-aK5p-U1by-k0ek-B66L-hIzo-i69WzG 
      ├─centos-root xfs                         1c43a251-c82f-47f2-ac60-5674f8590883   /
      ├─centos-swap swap                        77b30510-cc6c-40e6-a739-57d44fc0f751   [SWAP]
      └─centos-home xfs                         7dcba2d9-4955-4f54-886a-4687969e84dd   /home
    sr0             iso9660     VBox_GAs_6.1.16 2020-10-15-14-48-48-14
</code></pre>

<pre><code>    NAME ：这是块设备名。
    MAJ:MIN ：本栏显示主要和次要设备号。
    RM ：本栏显示设备是否可移动设备。注意，在本例中设备sdb和sr0的RM值等于1，这说明他们是可移动设备。
    SIZE ：本栏列出设备的容量大小信息。例如298.1G表明该设备大小为298.1GB，而1K表明该设备大小为1KB。
    RO ：该项表明设备是否为只读。在本案例中，所有设备的RO值为0，表明他们不是只读的。
    TYPE ：本栏显示块设备是否是磁盘或磁盘上的一个分区。在本例中，sda和sdb是磁盘，而sr0是只读存储（rom）。
    MOUNTPOINT ：本栏指出设备挂载的挂载点。
</code></pre>

<h3>blkid命令</h3>

<p>显示关于可用块设备的信息，他可以识别一个块设备内容的类别（如文件系统，交换区）以及从内容的元数据（如卷标或UUID字段）中获取属性（如tokens和键值对）。它主要有两类作用：用指定的键值对搜索一个设备，或是显示一个或多个设备的键值对。</p>

<p>不添加任何参数直接运行blkid将会输出所有可用的设备，他们的通用唯一识别码（UUID），文件系统类型以及卷标（如果有设置过）</p>

<pre><code>    [root@localhost ~]# blkid
    /dev/sr0: UUID="2020-10-15-14-48-48-14" LABEL="VBox_GAs_6.1.16" TYPE="iso9660" 
    /dev/sda1: UUID="f19cfd60-9c16-4ef9-bebf-a173e11ff163" TYPE="xfs" 
    /dev/sda2: UUID="ZTRWNx-aK5p-U1by-k0ek-B66L-hIzo-i69WzG" TYPE="LVM2_member" 
    /dev/mapper/centos-root: UUID="1c43a251-c82f-47f2-ac60-5674f8590883" TYPE="xfs" 
    /dev/mapper/centos-swap: UUID="77b30510-cc6c-40e6-a739-57d44fc0f751" TYPE="swap" 
    /dev/mapper/centos-home: UUID="7dcba2d9-4955-4f54-886a-4687969e84dd" TYPE="xfs"
</code></pre>

<h3>partprobe</h3>

<p>通知系统分区表的变化</p>

<p>使用fdisk或其他命令创建一个新的分区，然后使用partprobe命令重新读取分区表。这个命令执行完毕后不会输出任何返回信息。</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[xfs文件系统修复 xfs_repair]]></title>
    <link href="http://abcdxyzk.github.io/blog/2021/07/20/xfs_repair/"/>
    <updated>2021-07-20T16:53:00+08:00</updated>
    <id>http://abcdxyzk.github.io/blog/2021/07/20/xfs_repair</id>
    <content type="html"><![CDATA[<p><a href="https://blog.csdn.net/theoldsod2000/article/details/105988902/">https://blog.csdn.net/theoldsod2000/article/details/105988902/</a></p>

<p>因为断电等原因可能无法开机，提示
<code>
    Failed to start Remount Root and Kenal File System
</code></p>

<p>可以通过xfs_repair命令进行修复。</p>

<pre><code>    [root@localhost ~]# xfs_repair
    Usage: xfs_repair [options] device

    Options:
      -f           The device is a file
      -L           Force log zeroing. Do this as a last resort.
      -l logdev    Specifies the device where the external log resides.
      -m maxmem    Maximum amount of memory to be used in megabytes.
      -n           No modify mode, just checks the filesystem for damage.
      -P           Disables prefetching.
      -r rtdev     Specifies the device where the realtime section resides.
      -v           Verbose output.
      -c subopts   Change filesystem parameters - use xfs_admin.
      -o subopts   Override default behaviour, refer to man page.
      -t interval  Reporting interval in seconds.
      -d           Repair dangerously.
      -V           Reports version and exits.
</code></pre>

<p>xfs_repair最重要的是指定要修复的设备</p>

<p>如果是LVM管理分区的</p>

<p>可以通过 ls -l   /dev/mapper 来查看可用的设备。</p>

<p>一般可以看到2到3个链接文件，centos-home -> ../dm-1, centos-root->../dm-0</p>

<p>执行xfs_repair /dev/dm-0 正常情况下，这个分区就修复好了，再接着执行 xfs_repair  /dev/dm-1，正常情况下，这个分区也会修复好。</p>

<p>如果不是LVM分区管理的，可以 通过 ls /dev  查看，一般会有sda,sda1,sda2.</p>

<p>可以执行 xfs_repair /dev/sda1  和 xfs_repair /dev/sda2 进行修复。</p>

<p>如果修复失败，可以加上  -L  参数，这样可能会丢失部分数据。</p>

<p>修复的过程中可能会出错，提示找不到superblock。</p>

<p>下面这篇文章很清楚的讲述了superblock，inode，block的关系，可以帮助我们理解</p>

<p> <a href="https://blog.csdn.net/Ohmyberry/article/details/80427492">https://blog.csdn.net/Ohmyberry/article/details/80427492</a></p>

<p> dm是device mapper的意思,主要涉及的linux下卷的管理。卷管理通过映射的方法建立了逻辑卷。每个逻辑卷相当于一个分区。</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Linux下挂载lvm 重名问题]]></title>
    <link href="http://abcdxyzk.github.io/blog/2021/07/20/LVM2/"/>
    <updated>2021-07-20T16:47:00+08:00</updated>
    <id>http://abcdxyzk.github.io/blog/2021/07/20/LVM2</id>
    <content type="html"><![CDATA[<p><a href="https://blog.51cto.com/songxj/269661">https://blog.51cto.com/songxj/269661</a></p>

<p>linux下使用新硬盘安装系统，安装好以后再挂载原来的硬盘，分区格式全为系统默认分区，系统默认使用的是lvm格式，并且默认的卷都是 VolGroup00</p>

<p>使用 pvs 查看显示如下：
<code>
    [root@localhost ~]# pvs
    PV VG Fmt Attr PSize PFree
    /dev/sda2 VolGroup00 lvm2 a- 136.62G 0
    /dev/sdb2 VolGroup00 lvm2 a- 136.62G 0
</code>
发现可以正确认别到两个VG，但是同名，如何挂载呢？</p>

<h4>解决办法是，将原来的VG更名，解决冲突即可挂载。</h4>

<p>重命名格式为：
<code>
    vgrename VolGroup00 VolGroup01
</code>
此时会提示：
<code>
    [root@localhost ~]# vgrename VolGroup00 VolGroup01
    Found more than one VG called VolGroup00. Please supply VG uuid.
</code>
原因是存在两个 VolGroup00，修改的方法他已经提示了要指定 VG uuid即可。</p>

<p>查看VG uuid的命令为：
<code>
    [root@localhost ~]# vgs -v
    Finding all volume groups
    Finding volume group "VolGroup00"
    Finding volume group "VolGroup00"
    VG Attr Ext #PV #LV #SN VSize VFree VG UUID
    VolGroup00 wz--n- 32.00M 1 2 0 136.62G 0 dcHa6G-abU2-Xfq8-EPBm-jBLj-sf18-O5uH0U
    VolGroup00 wz--n- 32.00M 1 2 0 136.62G 0 OF8g7h-PQJB-9D9z-yPxn-1kfY-Advq-YbNHJ9
</code></p>

<p>查到VG uuid以后，再次执行改名：
<code>
    [root@localhost ~]# vgrename OF8g7h-PQJB-9D9z-yPxn-1kfY-Advq-YbNHJ9 VolGroup01
    Volume group "VolGroup00" still has active LVs
</code></p>

<p>修改成功以后，再执行：lvscan
<code>
    [root@localhost ~]# lvscan
    inactive '/dev/VolGroup01/LogVol00' [130.84 GB] inherit
    inactive '/dev/VolGroup01/LogVol01' [5.78 GB] inherit
    ACTIVE '/dev/VolGroup00/LogVol00' [130.84 GB] inherit
    ACTIVE '/dev/VolGroup00/LogVol01' [5.78 GB] inherit
</code></p>

<p>可以看到新修改的VolGroup01是inactive状态。</p>

<p>再使用vgchange 加载 VolGroup01
<code>
    [root@localhost ~]# vgchange -ay /dev/VolGroup01
    2 logical volume(s) in volume group "VolGroup01" now active
</code></p>

<p>最后 mount 就可以
<code>
    [root@localhost ~]# mount /dev/VolGroup01/LogVol00 /mnt/old
</code></p>

<p>至此，全部完成。</p>
]]></content>
  </entry>
  
</feed>
