<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

  <title><![CDATA[Category: tools | kk Blog —— 通用基础]]></title>
  <link href="http://abcdxyzk.github.io/blog/cats/tools/atom.xml" rel="self"/>
  <link href="http://abcdxyzk.github.io/"/>
  <updated>2024-04-26T14:38:06+08:00</updated>
  <id>http://abcdxyzk.github.io/</id>
  <author>
    <name><![CDATA[kk]]></name>
    
  </author>
  <generator uri="http://octopress.org/">Octopress</generator>

  
  <entry>
    <title type="html"><![CDATA[centos7下httpd服务对tmp目录操作]]></title>
    <link href="http://abcdxyzk.github.io/blog/2024/04/26/tools-apache2-tmp/"/>
    <updated>2024-04-26T14:34:00+08:00</updated>
    <id>http://abcdxyzk.github.io/blog/2024/04/26/tools-apache2-tmp</id>
    <content type="html"><![CDATA[<p><a href="https://blog.csdn.net/jsbba/article/details/105627202">https://blog.csdn.net/jsbba/article/details/105627202</a></p>

<p>在centos7下操作tmp目录出现各种找到不文件等问题，明白文件就在/tmp目录下，权限也有就是读取不到，原因是使用了private tmp</p>

<pre><code>    cat /usr/lib/systemd/system/httpd.service
</code></pre>

<p>找到以下配置</p>

<pre><code>    PrivateTmp=true
</code></pre>

<p>在默认未true时 这个服务对应的tmp目录会虚拟到/tmp/systemd-private-xxxxx-httpd.service-xxxx/这个里面的/tmp文件夹</p>

<p>可以直接讲true改成false</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[nginx 禁用代理缓冲]]></title>
    <link href="http://abcdxyzk.github.io/blog/2024/04/26/nginx-proxy-buffer/"/>
    <updated>2024-04-26T14:16:00+08:00</updated>
    <id>http://abcdxyzk.github.io/blog/2024/04/26/nginx-proxy-buffer</id>
    <content type="html"><![CDATA[<p><a href="https://www.saoniuhuo.com/question/detail-2752805.html">https://www.saoniuhuo.com/question/detail-2752805.html</a></p>

<p>浏览器中收到这些错误：</p>

<pre><code>    Firefox中的: NS_ERROR_NET_PARTIAL_TRANSFER

    Chrome: net::ERR_HTTP2_PROTOCOL_ERROR 200
</code></pre>

<h4>禁用代理缓冲：</h4>

<pre><code>    location ~ ^/rails/active_storage/disk {
        ...
        proxy_set_header X-Forwarded-For $proxy_add_x_forwarded_for;
        proxy_buffering off;
        ...
    }
</code></pre>

<p>这样就解决了问题</p>

<p><a href="https://www.pianshen.com/article/2410401164/">https://www.pianshen.com/article/2410401164/</a></p>

<h4>缓冲控制</h4>

<p>如果禁止缓冲，那么当Nginx一收到后端的反馈就同时传给客户端。</p>

<p>nginx 不会从被代理的服务器读取整个反馈信息。</p>

<p>nginx可从服务器一次接收的最大数据大小由  proxy_buffer_size 控制。
<code>
    proxy_buffering    off;
    proxy_buffer_size  128k;
    proxy_buffers 100  128k;
</code></p>

<p>相关参数</p>

<p>proxy_buffer_size</p>

<p>语法: proxy_buffer_size the_size</p>

<p>默认值: proxy_buffer_size 4k/8k</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[nginx配置多个域名, http https共用配置]]></title>
    <link href="http://abcdxyzk.github.io/blog/2024/03/01/nginx-proxy/"/>
    <updated>2024-03-01T20:14:00+08:00</updated>
    <id>http://abcdxyzk.github.io/blog/2024/03/01/nginx-proxy</id>
    <content type="html"><![CDATA[<p><a href="https://www.cnblogs.com/dayq/p/17488471.html">https://www.cnblogs.com/dayq/p/17488471.html</a></p>

<h4>0. user</h4>

<pre><code>    useradd nginx -G nginx

    chown -R nginx:nginx /var/log/nginx/*
</code></pre>

<h4>1. nginx</h4>

<p>vim /usr/local/openresty/nginx/conf/nginx.conf</p>

<p>域名 <code>s1.com</code>  <code>*.s1.com</code> 建议分开写两个?</p>

<p>如果需要多个域名共用端口则复制多个</p>

<p>增加回源地址 Proxy: &ldquo;$proxy_host&rdquo; &ldquo;$upstream_addr&rdquo;</p>

<pre><code>    user nginx;
    worker_processes auto;

    ......

    http {
        log_format  main  '$fmt_localtime $request_time $server_addr $server_port $remote_addr $remote_port $status $body_bytes_sent $request_method $server_protocol'
                  ' "$host" "$uri" "$query_string" "$http_referer" "$http_user_agent" "$ssl_protocol" "$ssl_cipher" "-" "$remote_user" "$http_x_forwarded_for"'
                  ' Proxy: $upstream_response_time $proxy_host $upstream_addr $upstream_status $upstream_response_length';
        access_log  /var/log/nginx/access.log  main;

        map $host $fmt_localtime {
            default '';
        }
        log_by_lua_block {
            ngx.var.fmt_localtime = ngx.localtime();
        }

        sendfile        on;
        tcp_nopush      on;
        tcp_nodelay     on;
        keepalive_timeout   65;
        types_hash_max_size 4096;
        #gzip  on;


        include     mime.types;
        default_type    application/octet-stream;


        server {
            listen  80;
            listen  443 ssl;
            server_name s1.com;

            ssl_certificate     /var/www/s1.com.pem;
            ssl_certificate_key /var/www/s1.com.key;

            client_max_body_size 200m;

            proxy_http_version 1.1;
            proxy_set_header Connection "";
            proxy_set_header Host $http_host;
            proxy_set_header X-Forwarded-For $proxy_add_x_forwarded_for;
            proxy_buffering off

            location / {
                proxy_pass https://192.168.1.11:11;
            }

            error_page   500 502 503 504  /50x.html;
            location = /50x.html {
                root   html;
            }
        }

        server {
            listen  80;
            listen  443 ssl;
            server_name *.s1.com;

            ssl_certificate     /var/www/s1.com.pem;
            ssl_certificate_key /var/www/s1.com.key;

            client_max_body_size 200m;

            proxy_http_version 1.1;
            proxy_set_header Connection "";
            proxy_set_header Host $http_host;
            proxy_set_header X-Forwarded-For $proxy_add_x_forwarded_for;
            proxy_buffering off

            location / {
                proxy_pass https://192.168.1.11:11;
            }

            error_page   500 502 503 504  /50x.html;
            location = /50x.html {
                root   html;
            }
        }



        server {
            listen  80;
            listen  443 ssl;
            server_name s2.com;

            ssl_certificate     /var/www/s2.com.pem;
            ssl_certificate_key /var/www/s2.com.key;

            client_max_body_size 200m;

            proxy_http_version 1.1;
            proxy_set_header Connection "";
            proxy_set_header Host $http_host;
            proxy_set_header X-Forwarded-For $proxy_add_x_forwarded_for;
            proxy_buffering off

            location / {
                proxy_pass https://192.168.2.22:22;
            }

            error_page   500 502 503 504  /50x.html;
            location = /50x.html {
                root   html;
            }
        }

        server {
            listen  80;
            listen  443 ssl;
            server_name *.s2.com;

            ssl_certificate     /var/www/s2.com.pem;
            ssl_certificate_key /var/www/s2.com.key;

            client_max_body_size 200m;

            proxy_http_version 1.1;
            proxy_set_header Connection "";
            proxy_set_header Host $http_host;
            proxy_set_header X-Forwarded-For $proxy_add_x_forwarded_for;
            proxy_buffering off

            location / {
                proxy_pass https://192.168.2.22:22;
            }

            error_page   500 502 503 504  /50x.html;
            location = /50x.html {
                root   html;
            }
        }
    }
</code></pre>

<h4>2. log 配置</h4>

<p>vim /etc/logrotate.d/nginx
<code>
    /var/log/nginx/*.log {
        create 0640 nginx root
        weekly
        rotate 100
        missingok
        notifempty
        delaycompress
        sharedscripts
        postrotate
            /bin/kill -USR1 `cat /run/nginx.pid 2&gt;/dev/null` 2&gt;/dev/null || true
        endscript
    }
</code></p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Vim 在处理长字符串时变得非常慢]]></title>
    <link href="http://abcdxyzk.github.io/blog/2024/02/26/vim-syntax-off/"/>
    <updated>2024-02-26T20:22:00+08:00</updated>
    <id>http://abcdxyzk.github.io/blog/2024/02/26/vim-syntax-off</id>
    <content type="html"><![CDATA[<p><a href="https://www.coder.work/article/6946837">https://www.coder.work/article/6946837</a></p>

<p>语法高亮是通过正则表达式定义的，匹配会消耗大量资源，尤其是在长行和大缓冲区上。</p>

<pre><code>    :syntax off
</code></pre>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[mysqldump 参数 net-buffer-length]]></title>
    <link href="http://abcdxyzk.github.io/blog/2023/12/10/mysqldump-len/"/>
    <updated>2023-12-10T16:43:00+08:00</updated>
    <id>http://abcdxyzk.github.io/blog/2023/12/10/mysqldump-len</id>
    <content type="html"><![CDATA[<p><a href="https://blog.csdn.net/yexiaomodemo/article/details/111050882">https://blog.csdn.net/yexiaomodemo/article/details/111050882</a></p>

<h4>用处一：</h4>

<p>比如设置成 &ndash;net-buffer-length=10m ,那么一旦你使用到还原时，你的数据一次commit提交是默认1m 提交时的10倍速度</p>

<h4>用处二：</h4>

<p>比如设置成 &ndash;net-buffer-length=10m ,小表估计就是一个insert就完事了，导入时效率会很高。当你备份文件有5G 10G了，那个时候这些参数非常有用</p>
]]></content>
  </entry>
  
</feed>
