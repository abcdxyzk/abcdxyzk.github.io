<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

  <title><![CDATA[Category: tools~mysql | kk Blog —— 通用基础]]></title>
  <link href="http://abcdxyzk.github.io/blog/cats/tools~mysql/atom.xml" rel="self"/>
  <link href="http://abcdxyzk.github.io/"/>
  <updated>2023-01-24T19:27:19+08:00</updated>
  <id>http://abcdxyzk.github.io/</id>
  <author>
    <name><![CDATA[kk]]></name>
    
  </author>
  <generator uri="http://octopress.org/">Octopress</generator>

  
  <entry>
    <title type="html"><![CDATA[4个替代phpMyAdmin的工具]]></title>
    <link href="http://abcdxyzk.github.io/blog/2023/01/20/mysql-web/"/>
    <updated>2023-01-20T16:31:00+08:00</updated>
    <id>http://abcdxyzk.github.io/blog/2023/01/20/mysql-web</id>
    <content type="html"><![CDATA[<p><a href="https://blog.csdn.net/weixin_34392906/article/details/92377986">https://blog.csdn.net/weixin_34392906/article/details/92377986</a></p>

<p>phpMyAdmin是管理MySQL数据库最流行的Web界面。但也有许多其他的工具，我们可代替phpMyAdmin的使用。</p>

<h4>1. Adminer</h4>

<p>Adminer是我的第一选择使用的，而不是phpMyAdmin。 Adminer是单一的PHP脚本，它可以在文档根目录轻松上传，没有任何安装或配置，访问就可用。</p>

<p>Adminer还可以用来管理SQL服务器，Oracle，PostgreSQL等等。 <a href="http://www.adminer.org/">下载Adminer</a></p>

<h4>2. MyWebSQL</h4>

<p>MyWebSQL是一个最终的台式机替代品，他在Web上管理你的MySQL数据库。</p>

<p>它的界面像自己喜欢的桌面应用程序，你不需要不断切换网页，以简单的做好事情。</p>

<p>只需登录到您的数据库和管理数据库，如果你是在您的桌面上工作！ <a href="http://mywebsql.net/">下载MyWebSQL</a></p>

<h4>3. phpMiniAdmin</h4>

<p>phpMiniAdmin是快速和容易管理MySQL数据库，是phpMyAdmin轻量级的选择。</p>

<p>phpminiadmin是写在只有大小为10KB+，它可以轻松上传到Web服务器的文档根目录，并在Web浏览器访问PHP。 <a href="http://phpminiadmin.sourceforge.net/">下载phpMiniAdmin</a></p>

<h4>4. SQL Buddy</h4>

<p>SQL Buddy是用于MySQL管理的一个很棒的工具，phpMyAdmin的一个替代品。</p>

<p>它超级容易建立，还有一个漂亮的界面。 <a href="http://sqlbuddy.com/">下载SQL Buddy</a></p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[phpMyAdmin web管理mysql]]></title>
    <link href="http://abcdxyzk.github.io/blog/2023/01/20/mysql-phpMyAdmin/"/>
    <updated>2023-01-20T16:24:00+08:00</updated>
    <id>http://abcdxyzk.github.io/blog/2023/01/20/mysql-phpMyAdmin</id>
    <content type="html"><![CDATA[<p><a href="http://t.zoukankan.com/ioveNature-p-6477758.html">http://t.zoukankan.com/ioveNature-p-6477758.html</a></p>

<p>安装MySQL数据库后，用户即可在命令行提示符下进行创建数据库和数据表等各种操作，但这种方法非常麻烦，而且需要有专业的SQL语言知识。PHP官方开发了一个可视化图形管理工具phpMyAdmin，该工具可以运行在各种版本的PHP及MySQL下。通过phpMyAdmin完全可以对数据库进行各种操作，如建立，复制和删除数据等。</p>

<p>phpMyAdmin为初学者提供了图形化的操作界面，这样MySQL数据库的操作就不必再命令提示符下通过命令实现，从而大大提高了开发的效率。用户可以在官方网站 www.phpmyadmin.net 上免费下载到最新版本。</p>

<p><a href="https://github.com/abcdxyzk/abcdxyzk.github.io_files/raw/master/tools/phpMyAdmin-5.2.0-all-languages.zip">phpMyAdmin-5.2.0-all-languages.zip</a></p>

<h3>一、操作数据库</h3>

<p>打开 192.168.0.123/phpMyAdmin 输入数据库的用户名和密码，可成功登陆phpMyAdmin。</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[mysql union all 比较两个表不同的数据]]></title>
    <link href="http://abcdxyzk.github.io/blog/2023/01/03/mysql-union-all/"/>
    <updated>2023-01-03T16:57:00+08:00</updated>
    <id>http://abcdxyzk.github.io/blog/2023/01/03/mysql-union-all</id>
    <content type="html"><![CDATA[<p><a href="https://blog.csdn.net/JustDI0209/article/details/122492293">https://blog.csdn.net/JustDI0209/article/details/122492293</a></p>

<p><a href="https://blog.csdn.net/u010931123/article/details/82425580">https://blog.csdn.net/u010931123/article/details/82425580</a></p>

<pre><code>    select * from (select * from rs.zzdmk union all select * from rs2.zzdmk) t group by pbf, sxh HAVING count(*)=1;
</code></pre>

<p>count( * ) = 1 为两张表数据不同的地方（只有一条结果），count( * ) = 2 为两张表数据相同的地方。</p>

<h4>union和union all的区别</h4>

<p>union会自动压缩多个结果集合中的重复结果，而union all则将所有的结果全部显示出来，不管是不是重复。</p>

<h4>Union</h4>

<p>对两个结果集进行并集操作，不包括重复行，同时进行默认规则的排序；</p>

<p>UNION在进行表链接后会筛选掉重复的记录，所以在表链接后会对所产生的结果集进行排序运算，删除重复的记录再返回结果。</p>

<p>实际大部分应用中是不会产生重复的记录，最常见的是过程表与历史表UNION</p>

<h4>Union All</h4>

<p>对两个结果集进行并集操作，包括重复行，不进行排序；</p>

<p>如果返回的两个结果集中有重复的数据，那么返回的结果集就会包含重复的数据了。</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[mysql查询时排除某个字段]]></title>
    <link href="http://abcdxyzk.github.io/blog/2023/01/03/mysql-cols/"/>
    <updated>2023-01-03T16:51:00+08:00</updated>
    <id>http://abcdxyzk.github.io/blog/2023/01/03/mysql-cols</id>
    <content type="html"><![CDATA[<p><a href="http://www.yayihouse.com/yayishuwu/chapter/2676">http://www.yayihouse.com/yayishuwu/chapter/2676</a></p>

<p>如果使用<code>*</code> 就把所有字段查出来了了，如果把要查询的字段一个个写出来又太多。</p>

<p>解决思路就是先使用以下sql生成你的查询sql语句，然后在代码中执行生成的sql就行了，</p>

<p>其中 rs 数据库名，zzja,zzjb 表名，id 就是要排除的字段名。</p>

<pre><code>    SELECT CONCAT('select ', GROUP_CONCAT(COLUMN_NAME), ' from rs.', TABLE_NAME, ' where zgh in ("222");') as str FROM information_schema.COLUMNS WHERE TABLE_SCHEMA='rs' AND table_name in ('zzjb','zzja') and COLUMN_NAME!='id' group by table_name;

    SELECT CONCAT('insert into ', TABLE_NAME, '(', GROUP_CONCAT(COLUMN_NAME), ') select ', GROUP_CONCAT(COLUMN_NAME), ' from rs.', TABLE_NAME, ' where zgh in ("222");') as str FROM information_schema.COLUMNS WHERE TABLE_SCHEMA='rs' AND table_name in ('zzjb','zzja') and COLUMN_NAME!='id' group by table_name;
</code></pre>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[sql中exists和except用法介绍,代替in]]></title>
    <link href="http://abcdxyzk.github.io/blog/2022/11/06/mysql-exists/"/>
    <updated>2022-11-06T11:33:00+08:00</updated>
    <id>http://abcdxyzk.github.io/blog/2022/11/06/mysql-exists</id>
    <content type="html"><![CDATA[<p><a href="https://www.jb51.net/article/230899.htm">https://www.jb51.net/article/230899.htm</a></p>

<h3>一、exists</h3>

<p>相对于 inner join，exists 性能要好一些，当它找到第一个符合条件的记录时，就会立即停止搜索返回 TRUE。</p>

<p>EXISTS = IN，意思相同不过语法上有点点区别，好像使用 IN 效率要差点，应该是不会执行索引的原因。</p>

<p><img src="/images/tools/20221106-1.jpg" alt="" /></p>

<h4>1.1 说明</h4>

<p>EXISTS（包括 NOT EXISTS）子句的返回值是一个 BOOL 值。EXISTS 内部有一个子查询语句（SELECT &hellip; FROM&hellip;），我将其称为 EXIST 的内查询语句。其内查询语句返回一个结果集。</p>

<p>EXISTS 子句根据其内查询语句的结果集空或者非空，返回一个布尔值。</p>

<p>exists：强调的是是否返回结果集，不要求知道返回什么，</p>

<p>比如：
<code>
    select name from student where sex = 'm' and mark exists(select 1 from grade where ...)
</code>
只要 exists 引导的子句有结果集返回，那么 exists 这个条件就算成立了，大家注意返回的字段始终为 1，如果改成
<code>
    select 2 from grade where ...
</code>
那么返回的字段就是 2，这个数字没有意义。</p>

<p>所以 exists 子句不在乎返回什么，而是在乎是不是有结果集返回。</p>

<h4>1.2 示例</h4>

<pre><code>    --EXISTS
    select name from family_member where group_level &gt; 0
        and exists(select 1 from family_grade where family_member.name = family_grade.name and grade &gt; 90)

    --result:
    name
    cherrie

    --NOT EXISTS
    select name from family_member where group_level &gt; 0
        and not exists(select 1 from family_grade where family_member.name = family_grade.name and grade &gt; 90)

    --result:
    name
    mazey
    rabbit
</code></pre>

<h4>1.3 intersect/2017-07-21</h4>

<p>intersect 的作用与 exists 类似。</p>

<pre><code>--intersect
    select name from family_member where group_level &gt; 0
        intersect select name from family_grade where grade &gt; 90

    --result:
    name
    cherrie
</code></pre>

<h3>二、except</h3>

<h4>2.1 说明</h4>

<p>查询结果上 EXCEPT = NOT EXISTS，INTERSECT = EXISTS，但是 EXCEPT/INTERSECT 的「查询开销」会比 NOT EXISTS/EXISTS 大很多。</p>

<p>except 自动去重复，not in/not exists不会。</p>

<h4>2.2 示例</h4>

<pre><code>    --except
    select name from family_member where group_level &gt; 0
        except(select name from family_grade)

    --result:
    name
    rabbit

    --NOT EXISTS
    select name from family_member where group_level &gt; 0
        and not exists(select name from family_grade where family_member.name = family_grade.name)

    --result:
    name
    rabbit
    rabbit
</code></pre>

<h3>三、测试数据</h3>

<p>其中验证 except 去重复功能时在 family_member 中新增一个 rabbit。</p>

<pre><code>    -- ----------------------------
    -- Table structure for family_grade
    -- ----------------------------
    DROP TABLE [mazeytop].[family_grade]
    GO

    CREATE TABLE [mazeytop].[family_grade] (
        [id] int NOT NULL ,
        [name] varchar(20) NULL ,
        [grade] int NULL
    )
    GO

    -- ----------------------------
    -- Records of family_grade
    -- ----------------------------
    INSERT INTO [mazeytop].[family_grade] ([id], [name], [grade]) VALUES (N'1', N'mazey', N'70')
    GO
    GO

    INSERT INTO [mazeytop].[family_grade] ([id], [name], [grade]) VALUES (N'2', N'cherrie', N'93')
    GO
    GO

    -- ----------------------------
    -- Table structure for family_member
    -- ----------------------------
    DROP TABLE [mazeytop].[family_member]
    GO

    CREATE TABLE [mazeytop].[family_member] (
        [id] int NOT NULL ,
        [name] varchar(20) NULL ,
        [sex] varchar(20) NULL ,
        [age] int NULL ,
        [group_level] int NULL
    )
    GO

    -- ----------------------------
    -- Records of family_member
    -- ----------------------------
    INSERT INTO [mazeytop].[family_member] ([id], [name], [sex], [age], [group_level]) VALUES (N'1', N'mazey', N'male', N'23', N'1')
    GO
    GO
    INSERT INTO [mazeytop].[family_member] ([id], [name], [sex], [age], [group_level]) VALUES (N'2', N'cherrie', N'female', N'22', N'2')
    GO
    GO
    INSERT INTO [mazeytop].[family_member] ([id], [name], [sex], [age], [group_level]) VALUES (N'3', N'rabbit', N'female', N'15', N'3')
    GO
    GO
    INSERT INTO [mazeytop].[family_member] ([id], [name], [sex], [age], [group_level]) VALUES (N'4', N'rabbit', N'female', N'15', N'3')
    GO
    GO

    -- ----------------------------
    -- Table structure for family_part
    -- ----------------------------
    DROP TABLE [mazeytop].[family_part]
    GO

    CREATE TABLE [mazeytop].[family_part] (
        [id] int NOT NULL ,
        [group] int NULL ,
        [group_name] varchar(20) NULL
    )
    GO

    -- ----------------------------
    -- Records of family_part
    -- ----------------------------
    INSERT INTO [mazeytop].[family_part] ([id], [group], [group_name]) VALUES (N'1', N'1', N'父亲')
    GO
    GO
    INSERT INTO [mazeytop].[family_part] ([id], [group], [group_name]) VALUES (N'2', N'2', N'母亲')
    GO
    GO
    INSERT INTO [mazeytop].[family_part] ([id], [group], [group_name]) VALUES (N'3', N'3', N'女儿')
    GO
    GO

    -- ----------------------------
    -- Indexes structure for table family_grade
    -- ----------------------------

    -- ----------------------------
    -- Primary Key structure for table family_grade
    -- ----------------------------
    ALTER TABLE [mazeytop].[family_grade] ADD PRIMARY KEY ([id])
    GO

    -- ----------------------------
    -- Indexes structure for table family_member
    -- ----------------------------

    -- ----------------------------
    -- Primary Key structure for table family_member
    -- ----------------------------
    ALTER TABLE [mazeytop].[family_member] ADD PRIMARY KEY ([id])
    GO

    -- ----------------------------
    -- Indexes structure for table family_part
    -- ----------------------------

    -- ----------------------------
    -- Primary Key structure for table family_part
    -- ----------------------------
    ALTER TABLE [mazeytop].[family_part] ADD PRIMARY KEY ([id])
    GO
</code></pre>
]]></content>
  </entry>
  
</feed>
