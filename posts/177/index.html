
<!DOCTYPE html>
<!--[if IEMobile 7 ]><html class="no-js iem7"><![endif]-->
<!--[if lt IE 9]><html class="no-js lte-ie8"><![endif]-->
<!--[if (gt IE 8)|(gt IEMobile 7)|!(IEMobile)|!(IE)]><!--><html class="no-js" lang="en"><!--<![endif]-->
<head>
  <meta charset="utf-8">
  <title>kk Blog —— 通用基础</title>

  <link href="/favicon.png" rel="icon">
  <link href="/stylesheets/screen.css" media="screen, projection" rel="stylesheet" type="text/css">
  <link href="/atom.xml" rel="alternate" title="kk Blog —— 通用基础" type="application/atom+xml">
  <script src="/javascripts/modernizr-2.0.js"></script>
  <script src="/javascripts/libs/jquery.min.js"></script>
<!--  <script>!window.jQuery && document.write(unescape('%3Cscript src="/javascripts/libs/jquery.min.js"%3E%3C/script%3E'))</script> -->
  <script src="/javascripts/octopress.js" type="text/javascript"></script>
  <script src="/javascripts/category.js" type="text/javascript"></script>

<script async src="https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js?client=ca-pub-8245190595992760"
     crossorigin="anonymous"></script>

</head>

<body   >
  <header role="banner"><hgroup>
  <h1><a href="/">kk Blog —— 通用基础</a></h1>
  
    <h2><br>date [-d @int|str] [+%s|"+%F %T"]<br>netstat -ltunp<br>sar -n DEV 1</h2>
  
  <div class="hwx" style='text-align: left; position: absolute; margin-top: -130px; white-space: nowrap;'>
	  <img src="/images/wx_ok.png" width=130px; height=130px;>
	  <img src="/images/ali_ok.png" width=130px; height=130px; style="margin-left:30px;">
  </div>
</hgroup>

</header>
  <nav role="navigation" style='white-space: nowrap; min-width=1120px;'><form action="/search" method="get">
    <input class="search" name="query" id="query" type="text" placeholder="search..." style="height:1.5em;">
    <input id="btnSubmit" value="search" type="submit">
</form>
<script type="text/javascript">

function StringToAscii(str) {
	return str.charCodeAt(0).toString(16);
}

function AsciiToString(asccode) {
	return String.fromCharCode(asccode);
}

function UrlDecode(zipStr) {
	var uzipStr = '';
	for (var i = 0; i < zipStr.length; i += 1) {
		var chr = zipStr.charAt(i);
		if (chr === '+') {
			uzipStr += ' ';
		} else if (chr === '%') {
			var asc = zipStr.substring(i + 1, i + 3);
			if (parseInt('0x' + asc) > 0x7f) {
				uzipStr += decodeURI('%' + asc.toString() + zipStr.substring(i+3, i+9).toString());
				i += 8;
			} else {
				uzipStr += AsciiToString(parseInt('0x' + asc));
				i += 2;
			}
		} else {
			uzipStr += chr;
		}
	}
	return uzipStr;
}

/*
var query = GetRequest("query");
if (query != null) {
	document.getElementById("query").value = UrlDecode(query);
}
*/

var query = window.location.search.substring(1);
var vars = query.split("&");
for (var i = 0; i < vars.length; i ++) {
	var pair = vars[i].split("=");
	if (pair[0] == 'query') {
		document.getElementById('query').value = UrlDecode(pair[1]);
		break;
	}
}

</script>

<!-- Start of Site Search 360 Scripts -->
<!-- Search 360 达到次数后要收费，换成静态索引
<script type="text/javascript">
var ss360Config = {
    siteId: "abcdxyzk.github.io",
    searchBox: {
        selector: "input#query",
        searchButton: "input#query+input[type='submit']"
    }
}
</script>
<script src="https://cdn.sitesearch360.com/v13/sitesearch360-v13.min.js" async></script>
-->
<!-- End of Site Search 360 Scripts -->

<ul class="subscription" data-subscription="rss">
<li>
</li>
  <li><a href="/atom.xml" rel="subscribe-rss">RSS</a></li>
  
</ul>
  
  
<ul class="main-navigation">
  <li><a href="/">Blog</a></li>
  <li><a href="/blog/archives">Archives</a></li>
  <li><a href="/download">Download</a></li>
  <li><a href="/search">Search</a></li>
  <li><a href="/about">About</a></li>
</ul>

</nav>
  <div id="main">
    <div id="content">
      <div class="blog-index">
  
  
  
    <article>
      
  <header>
    
      <h2 class="entry-title"><a href="/blog/2015/06/09/kernel-net-accept/">socket接收连接 sys_accept</a></h2>
    
    
      <p class="meta">
        




<time class='entry-date' datetime='2015-06-09T17:10:00+08:00'><span class='date'>2015-06-09</span> <span class='time'>17:10:00</span></time>
        
      </p>
    
  </header>


  <div class="entry-content"><p><a href="http://linux.chinaunix.net/techdoc/net/">http://linux.chinaunix.net/techdoc/net/</a></p>

<p><a href="http://linux.chinaunix.net/techdoc/net/2008/12/30/1055672.shtml">http://linux.chinaunix.net/techdoc/net/2008/12/30/1055672.shtml</a></p>

<p>这一节我们开始分析如何接收TCP的socket的连接请求，象以前的分析章节一样我们先看练习中的用户界面</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>accept(server_sockfd, （struct sockaddr *)&client_address, client_len);</span></code></pre></td></tr></table></div></figure>


<p>还是以前的分析方法，这里要注意第二个参数，client_address，它是在我们的测试程序中另外声明用于保存客户端socket地址的数据结构变量。其他二个参数无需多说。还是按照以前的方式我们直接看sys_socketcall()函数的代码部分</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>case SYS_ACCEPT:
</span><span class='line'>&#9;err = sys_accept(a0, (struct sockaddr __user *)a1,
</span><span class='line'>&#9;&#9; (int __user *)a[2]);
</span><span class='line'>&#9;break;</span></code></pre></td></tr></table></div></figure>


<p>显然是进入sys_accept()这个函数</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
<span class='line-number'>16</span>
<span class='line-number'>17</span>
<span class='line-number'>18</span>
<span class='line-number'>19</span>
<span class='line-number'>20</span>
<span class='line-number'>21</span>
<span class='line-number'>22</span>
<span class='line-number'>23</span>
<span class='line-number'>24</span>
<span class='line-number'>25</span>
<span class='line-number'>26</span>
<span class='line-number'>27</span>
<span class='line-number'>28</span>
<span class='line-number'>29</span>
<span class='line-number'>30</span>
<span class='line-number'>31</span>
<span class='line-number'>32</span>
<span class='line-number'>33</span>
<span class='line-number'>34</span>
<span class='line-number'>35</span>
<span class='line-number'>36</span>
<span class='line-number'>37</span>
<span class='line-number'>38</span>
<span class='line-number'>39</span>
<span class='line-number'>40</span>
<span class='line-number'>41</span>
<span class='line-number'>42</span>
<span class='line-number'>43</span>
<span class='line-number'>44</span>
<span class='line-number'>45</span>
<span class='line-number'>46</span>
<span class='line-number'>47</span>
<span class='line-number'>48</span>
<span class='line-number'>49</span>
<span class='line-number'>50</span>
<span class='line-number'>51</span>
<span class='line-number'>52</span>
<span class='line-number'>53</span>
<span class='line-number'>54</span>
<span class='line-number'>55</span>
<span class='line-number'>56</span>
<span class='line-number'>57</span>
<span class='line-number'>58</span>
<span class='line-number'>59</span>
<span class='line-number'>60</span>
<span class='line-number'>61</span>
<span class='line-number'>62</span>
<span class='line-number'>63</span>
<span class='line-number'>64</span>
<span class='line-number'>65</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>sys_socketcall()--&gt;sys_accept()
</span><span class='line'>asmlinkage long sys_accept(int fd, struct sockaddr __user *upeer_sockaddr,
</span><span class='line'>&#9;&#9;&#9; int __user *upeer_addrlen)
</span><span class='line'>{
</span><span class='line'>&#9;struct socket *sock, *newsock;
</span><span class='line'>&#9;struct file *newfile;
</span><span class='line'>&#9;int err, len, newfd, fput_needed;
</span><span class='line'>&#9;char address[MAX_SOCK_ADDR];
</span><span class='line'>&#9;sock = sockfd_lookup_light(fd, &err, &fput_needed);
</span><span class='line'>&#9;if (!sock)
</span><span class='line'>&#9;&#9;goto out;
</span><span class='line'>&#9;err = -ENFILE;
</span><span class='line'>&#9;if (!(newsock = sock_alloc()))
</span><span class='line'>&#9;&#9;goto out_put;
</span><span class='line'>&#9;newsock-&gt;type = sock-&gt;type;
</span><span class='line'>&#9;newsock-&gt;ops = sock-&gt;ops;
</span><span class='line'>&#9;/*
</span><span class='line'>&#9; * We don't need try_module_get here, as the listening socket (sock)
</span><span class='line'>&#9; * has the protocol module (sock-&gt;ops-&gt;owner) held.qinjian
</span><span class='line'>&#9; */
</span><span class='line'>&#9;__module_get(newsock-&gt;ops-&gt;owner);
</span><span class='line'>&#9;newfd = sock_alloc_fd(&newfile);
</span><span class='line'>&#9;if (unlikely(newfd  0)) {
</span><span class='line'>&#9;&#9;err = newfd;
</span><span class='line'>&#9;&#9;sock_release(newsock);
</span><span class='line'>&#9;&#9;goto out_put;
</span><span class='line'>&#9;}
</span><span class='line'>&#9;err = sock_attach_fd(newsock, newfile);
</span><span class='line'>&#9;if (err  0)
</span><span class='line'>&#9;&#9;goto out_fd_simple;
</span><span class='line'>&#9;err = security_socket_accept(sock, newsock);
</span><span class='line'>&#9;if (err)
</span><span class='line'>&#9;&#9;goto out_fd;
</span><span class='line'>&#9;err = sock-&gt;ops-&gt;accept(sock, newsock, sock-&gt;file-&gt;f_flags);
</span><span class='line'>&#9;if (err  0)
</span><span class='line'>&#9;&#9;goto out_fd;
</span><span class='line'>&#9;if (upeer_sockaddr) {
</span><span class='line'>&#9;&#9;if (newsock-&gt;ops-&gt;getname(newsock, (struct sockaddr *)address,
</span><span class='line'>&#9;&#9;&#9;&#9;&#9; &len, 2)  0) {
</span><span class='line'>&#9;&#9;&#9;err = -ECONNABORTED;
</span><span class='line'>&#9;&#9;&#9;goto out_fd;
</span><span class='line'>&#9;&#9;}
</span><span class='line'>&#9;&#9;err = move_addr_to_user(address, len, upeer_sockaddr,
</span><span class='line'>&#9;&#9;&#9;&#9;&#9;upeer_addrlen);
</span><span class='line'>&#9;&#9;if (err  0)
</span><span class='line'>&#9;&#9;&#9;goto out_fd;
</span><span class='line'>&#9;}
</span><span class='line'>&#9;/* File flags are not inherited via accept() unlike another OSes.QJ */
</span><span class='line'>&#9;fd_install(newfd, newfile);
</span><span class='line'>&#9;err = newfd;
</span><span class='line'>&#9;security_socket_post_accept(sock, newsock);
</span><span class='line'>out_put:
</span><span class='line'>&#9;fput_light(sock-&gt;file, fput_needed);
</span><span class='line'>out:
</span><span class='line'>&#9;return err;
</span><span class='line'>out_fd_simple:
</span><span class='line'>&#9;sock_release(newsock);
</span><span class='line'>&#9;put_filp(newfile);
</span><span class='line'>&#9;put_unused_fd(newfd);
</span><span class='line'>&#9;goto out_put;
</span><span class='line'>out_fd:
</span><span class='line'>&#9;fput(newfile);
</span><span class='line'>&#9;put_unused_fd(newfd);
</span><span class='line'>&#9;goto out_put;
</span><span class='line'>}</span></code></pre></td></tr></table></div></figure>


<p>这个函数总的作用就是使服务端的socket能够创建与客户端连接的“子连接”，也就是会利用服务器端的socket创建一个新的能与客户端建立连接的socket，而且会把新连接的socket的id号，返回到我们测试程序中的client_sockfd，同时也把客户端的socket地址保存在client_address中，函数中首先会进入sockfd_lookup_light（）中找到我们服务器端的socket，这个函数前面章节中用到多次了不再进入细细分析了，接着函数中调用sock_alloc（）函数创建一个新的socket,此后为这个新创建的socket分配一个可用的文件号，然后能过sock_attach_fd使其与文件号挂钩。最重要的当属这句代码</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>err = sock-&gt;ops-&gt;accept(sock, newsock, sock-&gt;file-&gt;f_flags);</span></code></pre></td></tr></table></div></figure>


<p>这部分开始入手分析TCP的socket是如何执行的，这里会进入inet_stream_ops中执行，可能有些朋友是直接阅读本文的，最好是看一下前面的章节理清是如何进入这个函数的，我们这里不再重复了。</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>const struct proto_ops inet_stream_ops = {
</span><span class='line'>&#9;。。。。。。
</span><span class='line'>&#9;.accept         = inet_accept,
</span><span class='line'>&#9;。。。。。。
</span><span class='line'>};</span></code></pre></td></tr></table></div></figure>


<p>我们再次看一下af_inet.c中的这个数据结构，很显然进入了inet_accept()函数</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
<span class='line-number'>16</span>
<span class='line-number'>17</span>
<span class='line-number'>18</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>sys_socketcall()--&gt;sys_accept()--&gt;inet_accept()
</span><span class='line'>int inet_accept(struct socket *sock, struct socket *newsock, int flags)
</span><span class='line'>{
</span><span class='line'>&#9;struct sock *sk1 = sock-&gt;sk;
</span><span class='line'>&#9;int err = -EINVAL;
</span><span class='line'>&#9;struct sock *sk2 = sk1-&gt;sk_prot-&gt;accept(sk1, flags, &err);
</span><span class='line'>&#9;if (!sk2)
</span><span class='line'>&#9;&#9;goto do_err;
</span><span class='line'>&#9;lock_sock(sk2);
</span><span class='line'>&#9;BUG_TRAP((1  sk2-&gt;sk_state) &
</span><span class='line'>&#9;&#9; (TCPF_ESTABLISHED | TCPF_CLOSE_WAIT | TCPF_CLOSE));
</span><span class='line'>&#9;sock_graft(sk2, newsock);
</span><span class='line'>&#9;newsock-&gt;state = SS_CONNECTED;
</span><span class='line'>&#9;err = 0;
</span><span class='line'>&#9;release_sock(sk2);
</span><span class='line'>do_err:
</span><span class='line'>&#9;return err;
</span><span class='line'>}</span></code></pre></td></tr></table></div></figure>


<p>进入这个函数的时候已经找到了我们前面建立的socket结构，而newsock是我们新分配建立的socket结构，我们看到上面函数中执行了</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>struct sock *sk2 = sk1-&gt;sk_prot-&gt;accept(sk1, flags, &err);</span></code></pre></td></tr></table></div></figure>


<p>进而进入了钩子函数中执行，那里的struct proto tcp_prot结构变量可以看到</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>struct proto tcp_prot = {
</span><span class='line'>&#9;。。。。。。
</span><span class='line'>&#9;.accept            = inet_csk_accept,
</span><span class='line'>&#9;。。。。。。
</span><span class='line'>};</span></code></pre></td></tr></table></div></figure>


<p>很显然是执行的inet_csk_accept（）函数</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
<span class='line-number'>16</span>
<span class='line-number'>17</span>
<span class='line-number'>18</span>
<span class='line-number'>19</span>
<span class='line-number'>20</span>
<span class='line-number'>21</span>
<span class='line-number'>22</span>
<span class='line-number'>23</span>
<span class='line-number'>24</span>
<span class='line-number'>25</span>
<span class='line-number'>26</span>
<span class='line-number'>27</span>
<span class='line-number'>28</span>
<span class='line-number'>29</span>
<span class='line-number'>30</span>
<span class='line-number'>31</span>
<span class='line-number'>32</span>
<span class='line-number'>33</span>
<span class='line-number'>34</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>sys_socketcall()--&gt;sys_accept()--&gt;inet_accept()--&gt;inet_csk_accept()
</span><span class='line'>struct sock *inet_csk_accept(struct sock *sk, int flags, int *err)
</span><span class='line'>{
</span><span class='line'>&#9;struct inet_connection_sock *icsk = inet_csk(sk);
</span><span class='line'>&#9;struct sock *newsk;
</span><span class='line'>&#9;int error;
</span><span class='line'>&#9;lock_sock(sk);
</span><span class='line'>&#9;/* We need to make sure that this socket is listening,
</span><span class='line'>&#9; * and that it has something pending.qinjian
</span><span class='line'>&#9; */
</span><span class='line'>&#9;error = -EINVAL;
</span><span class='line'>&#9;if (sk-&gt;sk_state != TCP_LISTEN)
</span><span class='line'>&#9;&#9;goto out_err;
</span><span class='line'>&#9;/* Find already established connection */
</span><span class='line'>&#9;if (reqsk_queue_empty(&icsk-&gt;icsk_accept_queue)) {
</span><span class='line'>&#9;&#9;long timeo = sock_rcvtimeo(sk, flags & O_NONBLOCK);
</span><span class='line'>&#9;&#9;/* If this is a non blocking socket don't sleep */
</span><span class='line'>&#9;&#9;error = -EAGAIN;
</span><span class='line'>&#9;&#9;if (!timeo)
</span><span class='line'>&#9;&#9;&#9;goto out_err;
</span><span class='line'>&#9;&#9;error = inet_csk_wait_for_connect(sk, timeo);
</span><span class='line'>&#9;&#9;if (error)
</span><span class='line'>&#9;&#9;&#9;goto out_err;
</span><span class='line'>&#9;}
</span><span class='line'>&#9;newsk = reqsk_queue_get_child(&icsk-&gt;icsk_accept_queue, sk);
</span><span class='line'>&#9;BUG_TRAP(newsk-&gt;sk_state != TCP_SYN_RECV);
</span><span class='line'>out:
</span><span class='line'>&#9;release_sock(sk);
</span><span class='line'>&#9;return newsk;
</span><span class='line'>out_err:
</span><span class='line'>&#9;newsk = NULL;
</span><span class='line'>&#9;*err = error;
</span><span class='line'>&#9;goto out;
</span><span class='line'>}</span></code></pre></td></tr></table></div></figure>


<p>象往常叙述的一样首先是在sock中取得struct inet_connection_sock结构,然后判断一下sock的状态是否已经处于监听状态，如果没有处于监听状态的话就不能接收了，只好出错返回了。接着是检查icsk中的icsk_accept_queue请求队列是否为空，因为我们练习中还未启动客户端程序，所以此时还没有连接请求到来，这个队列现在是空的，所以进入if语句，sock_rcvtimeo（）是根据是否允许“阻塞”即等待，而取得sock结构中的sk_rcvtimeo时间值，然后根据这个值进入inet_csk_wait_for_connect（）函数中</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
<span class='line-number'>16</span>
<span class='line-number'>17</span>
<span class='line-number'>18</span>
<span class='line-number'>19</span>
<span class='line-number'>20</span>
<span class='line-number'>21</span>
<span class='line-number'>22</span>
<span class='line-number'>23</span>
<span class='line-number'>24</span>
<span class='line-number'>25</span>
<span class='line-number'>26</span>
<span class='line-number'>27</span>
<span class='line-number'>28</span>
<span class='line-number'>29</span>
<span class='line-number'>30</span>
<span class='line-number'>31</span>
<span class='line-number'>32</span>
<span class='line-number'>33</span>
<span class='line-number'>34</span>
<span class='line-number'>35</span>
<span class='line-number'>36</span>
<span class='line-number'>37</span>
<span class='line-number'>38</span>
<span class='line-number'>39</span>
<span class='line-number'>40</span>
<span class='line-number'>41</span>
<span class='line-number'>42</span>
<span class='line-number'>43</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>sys_socketcall()--&gt;sys_accept()--&gt;inet_accept()--&gt;inet_csk_accept()--&gt;inet_csk_wait_for_connect()
</span><span class='line'>static int inet_csk_wait_for_connect(struct sock *sk, long timeo)
</span><span class='line'>{
</span><span class='line'>&#9;struct inet_connection_sock *icsk = inet_csk(sk);
</span><span class='line'>&#9;DEFINE_WAIT(wait);
</span><span class='line'>&#9;int err;
</span><span class='line'>&#9;/*
</span><span class='line'>&#9; * True wake-one mechanism for incoming connections: only
</span><span class='line'>&#9; * one process gets woken up, not the 'whole herd'.
</span><span class='line'>&#9; * Since we do not 'race & poll' for established sockets
</span><span class='line'>&#9; * anymore, the common case will execute the loop only once.
</span><span class='line'>&#9; *
</span><span class='line'>&#9; * Subtle issue: "add_wait_queue_exclusive()" will be added
</span><span class='line'>&#9; * after any current non-exclusive waiters, and we know that
</span><span class='line'>&#9; * it will always _stay_ after any new non-exclusive waiters
</span><span class='line'>&#9; * because all non-exclusive waiters are added at the
</span><span class='line'>&#9; * beginning of the wait-queue. As such, it's ok to "drop"
</span><span class='line'>&#9; * our exclusiveness temporarily when we get woken up without
</span><span class='line'>&#9; * having to remove and re-insert us on the wait queue.wumingxiaozu
</span><span class='line'>&#9; */
</span><span class='line'>&#9;for (;;) {
</span><span class='line'>&#9;&#9;prepare_to_wait_exclusive(sk-&gt;sk_sleep, &wait,
</span><span class='line'>&#9;&#9;&#9;&#9;&#9; TASK_INTERRUPTIBLE);
</span><span class='line'>&#9;&#9;release_sock(sk);
</span><span class='line'>&#9;&#9;if (reqsk_queue_empty(&icsk-&gt;icsk_accept_queue))
</span><span class='line'>&#9;&#9;&#9;timeo = schedule_timeout(timeo);
</span><span class='line'>&#9;&#9;lock_sock(sk);
</span><span class='line'>&#9;&#9;err = 0;
</span><span class='line'>&#9;&#9;if (!reqsk_queue_empty(&icsk-&gt;icsk_accept_queue))
</span><span class='line'>&#9;&#9;&#9;break;
</span><span class='line'>&#9;&#9;err = -EINVAL;
</span><span class='line'>&#9;&#9;if (sk-&gt;sk_state != TCP_LISTEN)
</span><span class='line'>&#9;&#9;&#9;break;
</span><span class='line'>&#9;&#9;err = sock_intr_errno(timeo);
</span><span class='line'>&#9;&#9;if (signal_pending(current))
</span><span class='line'>&#9;&#9;&#9;break;
</span><span class='line'>&#9;&#9;err = -EAGAIN;
</span><span class='line'>&#9;&#9;if (!timeo)
</span><span class='line'>&#9;&#9;&#9;break;
</span><span class='line'>&#9;}
</span><span class='line'>&#9;finish_wait(sk-&gt;sk_sleep, &wait);
</span><span class='line'>&#9;return err;
</span><span class='line'>}</span></code></pre></td></tr></table></div></figure>


<p>函数首先是调用了宏来声明一个等待队列</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>#define DEFINE_WAIT(name)                                \
</span><span class='line'>wait_queue_t name = {                                    \
</span><span class='line'>&#9;.private      = current,                             \
</span><span class='line'>&#9;.func         = autoremove_wake_function,            \
</span><span class='line'>&#9;.task_list    = LIST_HEAD_INIT((name).task_list),    \
</span><span class='line'>}</span></code></pre></td></tr></table></div></figure>


<p>关于等待队列的具体概念我们留在以后专门的章节中论述，这里可以看出是根据当前进程而建立的名为wait的等待队列，接着函数中调用了</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
<span class='line-number'>16</span>
<span class='line-number'>17</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>sys_socketcall()--&gt;sys_accept()--&gt;inet_accept()--&gt;inet_csk_accept()--&gt;inet_csk_wait_for_connect()--&gt;prepare_to_wait_exclusive()
</span><span class='line'>void
</span><span class='line'>prepare_to_wait_exclusive(wait_queue_head_t *q, wait_queue_t *wait, int state)
</span><span class='line'>{
</span><span class='line'>&#9;unsigned long flags;
</span><span class='line'>&#9;wait-&gt;flags |= WQ_FLAG_EXCLUSIVE;
</span><span class='line'>&#9;spin_lock_irqsave(&q-&gt;lock, flags);
</span><span class='line'>&#9;if (list_empty(&wait-&gt;task_list))
</span><span class='line'>&#9;&#9;__add_wait_queue_tail(q, wait);
</span><span class='line'>&#9;/*
</span><span class='line'>&#9; * don't alter the task state if this is just going to
</span><span class='line'>&#9;  * queue an async wait queue callback wumingxiaozu
</span><span class='line'>&#9; */
</span><span class='line'>&#9;if (is_sync_wait(wait))
</span><span class='line'>&#9;&#9;set_current_state(state);
</span><span class='line'>&#9;spin_unlock_irqrestore(&q-&gt;lock, flags);
</span><span class='line'>}</span></code></pre></td></tr></table></div></figure>


<p>接着要把这里创建的wait，即当前进程的这里的等待队列挂入sk中的sk_sleep队列，这样我们可以理解到多个进程都可以对一个socket并发的连接，这个函数与我们所说的等待队列部分内容是密切相关的，我们只简单的叙述一下，函数中主要是将我们上面建立的等待队列插入到这里的sock结构中的sk_sleep所指定的等待队列头中，此后再次调用reqsk_queue_empty（）函数检查一下icsk_accept_queue是否为空，如果还为空就说明没有连接请求到来，开始睡眠等待了，schedule_timeout（）这个函数与时钟密切相关，所以请朋友们参考其他资料，这里是根据我们上面得到的定时时间来进入睡眠的。</p>

<p>当从这个函数返回时，再次锁住sock防止其他进程打扰，然后这里还是判断一下icsk_accept_queue是否为空，如果还为空的话就要跳出for循环了，醒来后还要检查一下是否是因为信号而醒来的，如果有信号就要处理信号signal_pending（），最后如果睡眠的时间已经用完了也会跳出循环，跳出循环后就要将这里的等待队列从sock中的sk_sleep中摘链。</p>

<p>我们回到inet_csk_accept（）函数中继续往下看，如果这时队列icsk_accept_queue不为空，即有连接请求到来怎么办呢，继续看下面的代码</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>newsk = reqsk_queue_get_child(&icsk-&gt;icsk_accept_queue, sk);</span></code></pre></td></tr></table></div></figure>


<p>这里看到是进入了reqsk_queue_get_child函数中</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>sys_socketcall()--&gt;sys_accept()--&gt;inet_accept()--&gt;inet_csk_accept()--&gt;reqsk_queue_get_child()
</span><span class='line'>static inline struct sock *reqsk_queue_get_child(struct request_sock_queue *queue,
</span><span class='line'>&#9;&#9;&#9;&#9;&#9;&#9; struct sock *parent)
</span><span class='line'>{
</span><span class='line'>&#9;struct request_sock *req = reqsk_queue_remove(queue);
</span><span class='line'>&#9;struct sock *child = req-&gt;sk;
</span><span class='line'>&#9;BUG_TRAP(child != NULL);
</span><span class='line'>&#9;sk_acceptq_removed(parent);
</span><span class='line'>&#9;__reqsk_free(req);
</span><span class='line'>&#9;return child;
</span><span class='line'>}</span></code></pre></td></tr></table></div></figure>


<p>函数中首先是调用了reqsk_queue_remove（）从队列中摘下一个已经到来的request_sock结构</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>sys_socketcall()--&gt;sys_accept()--&gt;inet_accept()--&gt;inet_csk_accept()--&gt;reqsk_queue_get_child()--&gt;reqsk_queue_remove()
</span><span class='line'>static inline struct request_sock *reqsk_queue_remove(struct request_sock_queue *queue)
</span><span class='line'>{
</span><span class='line'>&#9;struct request_sock *req = queue-&gt;rskq_accept_head;
</span><span class='line'>&#9;BUG_TRAP(req != NULL);
</span><span class='line'>&#9;queue-&gt;rskq_accept_head = req-&gt;dl_next;
</span><span class='line'>&#9;if (queue-&gt;rskq_accept_head == NULL)
</span><span class='line'>&#9;&#9;queue-&gt;rskq_accept_tail = NULL;
</span><span class='line'>&#9;return req;
</span><span class='line'>}</span></code></pre></td></tr></table></div></figure>


<p>很明显上面函数中是从队列的rskq_accept_head摘下一个已经到来的request_sock这个结构是从客户端请求连接时挂入的，reqsk_queue_get_child（）函数在这里把request_sock中载运的sock结构返回到inet_csk_accept中的局部变量newsk使用。而sk_acceptq_removed是递减我们服务器端sock中的sk_ack_backlog。</p>

<p>然后__reqsk_free释放掉request_sock结构。回到inet_csk_accept函数中，然后返回我们间接从icsk->icsk_accept_queue队列中获得了与客户端密切相关的sock结构。这个与客户端密切相关的结构是由我们服务器端在响应底层驱动的数据包过程中建立的，我们将在后边讲解完客户端的连接请求把这一过程补上，这里假设我们已经接收到了客户端的数据包并且服务器端为此专门建了这个与客户端数据包相联系的sock结构，接着返回到inet_accept()函数中，接着调用sock_graft（）函数，注意参数sock_graft(sk2, newsock);sk2是我们上边叙述的与客户端密切相关的sock结构，是从接收队列中获得的。</p>

<p>而newsock，则是我们服务器端为了这个代表客户端的sock结构而准备的新的socket。我们以前说过，socket结构在具体应用上分为二部分，另一部分是这里的sock结构，因为sock是与具体的协议即以前所说的规程的相关，所以变化比较大，而socket比较通用，所以我们上面通过socket_alloc()只是分配了通用部分的socket结构，并没有建立对应协议的sock结构，那么我们分配的新的socket的所需要的sock是从哪里来的呢，我们可以在代码中看到他是取的代表客户端的sock结构，与我们新建的socket挂入的，看一下这个关键的函数</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>sys_socketcall()--&gt;sys_accept()--&gt;inet_accept()--&gt;sock_graft()
</span><span class='line'>static inline void sock_graft(struct sock *sk, struct socket *parent)
</span><span class='line'>{
</span><span class='line'>&#9;write_lock_bh(&sk-&gt;sk_callback_lock);
</span><span class='line'>&#9;sk-&gt;sk_sleep = &parent-&gt;wait;
</span><span class='line'>&#9;parent-&gt;sk = sk;
</span><span class='line'>&#9;sk-&gt;sk_socket = parent;
</span><span class='line'>&#9;security_sock_graft(sk, parent);
</span><span class='line'>&#9;write_unlock_bh(&sk-&gt;sk_callback_lock);
</span><span class='line'>}</span></code></pre></td></tr></table></div></figure>


<p>上面传递的参数是</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>sock_graft(sk2, newsock);</span></code></pre></td></tr></table></div></figure>


<p>sk2是代表我们客户端的sock，newsock是我们服务器端的新socket，可以看出上面的sock_graft,graft是嫁接的意思，从函数面上就可以理解了，然后其内部就是将服务器端新建的socket与客户端的sock“挂钩了”，从此以后，这个socket就是服务器端与客户端通讯的桥梁了。这样回到上面的inet_accept函数时，我们看到将newsock->state = SS_CONNECTED;也就是状态改变成了连接状态，而以前的服务器的socket并没有任何的状态改变，那个socket继续覆行他的使命“孵化”新的socket。回到我们的sys_accept()函数中下面接着看，我们在练习中看到需要获得客户端的地址，在那个章节中我们又走到了</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>newsock-&gt;ops-&gt;getname(newsock, (struct sockaddr )address, &len, 2)</span></code></pre></td></tr></table></div></figure>


<p>这要看我们在sys_accpet()函数中新创建的newsock的ops钩子结构了，很明显我们在sys_accept()函数中看到了newsock->ops = sock->ops;所以newsock是使用的已经建立的服务器端的inet_stream_ops结构变量，我们可以在这个结构中看到</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>const struct proto_ops inet_stream_ops = {
</span><span class='line'>&#9;。。。。。。
</span><span class='line'>&#9;.getname     = inet_getname,
</span><span class='line'>&#9;。。。。。。
</span><span class='line'>};</span></code></pre></td></tr></table></div></figure>


<p>因此进入了inet_getname()函数，这个函数在/net/ipv4/af_inet.c中的683行处。</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
<span class='line-number'>16</span>
<span class='line-number'>17</span>
<span class='line-number'>18</span>
<span class='line-number'>19</span>
<span class='line-number'>20</span>
<span class='line-number'>21</span>
<span class='line-number'>22</span>
<span class='line-number'>23</span>
<span class='line-number'>24</span>
<span class='line-number'>25</span>
<span class='line-number'>26</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>sys_accept()--&gt;inet_getname()
</span><span class='line'>int inet_getname(struct socket *sock, struct sockaddr *uaddr,
</span><span class='line'>&#9;&#9;&#9;int *uaddr_len, int peer)
</span><span class='line'>{
</span><span class='line'>&#9;struct sock *sk        = sock-&gt;sk;
</span><span class='line'>&#9;struct inet_sock *inet    = inet_sk(sk);
</span><span class='line'>&#9;struct sockaddr_in *sin    = (struct sockaddr_in *)uaddr;
</span><span class='line'>&#9;sin-&gt;sin_family = AF_INET;
</span><span class='line'>&#9;if (peer) {
</span><span class='line'>&#9;&#9;if (!inet-&gt;dport ||
</span><span class='line'>&#9;&#9; (((1  sk-&gt;sk_state) & (TCPF_CLOSE | TCPF_SYN_SENT)) &&
</span><span class='line'>&#9;&#9; peer == 1))
</span><span class='line'>&#9;&#9;&#9;return -ENOTCONN;
</span><span class='line'>&#9;&#9;sin-&gt;sin_port = inet-&gt;dport;
</span><span class='line'>&#9;&#9;sin-&gt;sin_addr.s_addr = inet-&gt;daddr;
</span><span class='line'>&#9;} else {
</span><span class='line'>&#9;&#9;__be32 addr = inet-&gt;rcv_saddr;
</span><span class='line'>&#9;&#9;if (!addr)
</span><span class='line'>&#9;&#9;&#9;addr = inet-&gt;saddr;
</span><span class='line'>&#9;&#9;sin-&gt;sin_port = inet-&gt;sport;
</span><span class='line'>&#9;&#9;sin-&gt;sin_addr.s_addr = addr;
</span><span class='line'>&#9;}
</span><span class='line'>&#9;memset(sin-&gt;sin_zero, 0, sizeof(sin-&gt;sin_zero));
</span><span class='line'>&#9;*uaddr_len = sizeof(*sin);
</span><span class='line'>&#9;return 0;
</span><span class='line'>}</span></code></pre></td></tr></table></div></figure>


<p>在上面的代码中，关键的是这二句</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>sin-&gt;sin_port = inet-&gt;dport;
</span><span class='line'>sin-&gt;sin_addr.s_addr = inet-&gt;daddr;</span></code></pre></td></tr></table></div></figure>


<p>这里直接将我们练习中的准备接收的数组address转换成tcp的地址结构struct sockaddr_in指针，然后直接用上面二句赋值了，我们看到他是使用的我们刚刚提到的从icsk->icsk_accept_queue接收队列中得到的sock进而得到了inet_sock专用于INET的sock结构</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
<span class='line-number'>16</span>
<span class='line-number'>17</span>
<span class='line-number'>18</span>
<span class='line-number'>19</span>
<span class='line-number'>20</span>
<span class='line-number'>21</span>
<span class='line-number'>22</span>
<span class='line-number'>23</span>
<span class='line-number'>24</span>
<span class='line-number'>25</span>
<span class='line-number'>26</span>
<span class='line-number'>27</span>
<span class='line-number'>28</span>
<span class='line-number'>29</span>
<span class='line-number'>30</span>
<span class='line-number'>31</span>
<span class='line-number'>32</span>
<span class='line-number'>33</span>
<span class='line-number'>34</span>
<span class='line-number'>35</span>
<span class='line-number'>36</span>
<span class='line-number'>37</span>
<span class='line-number'>38</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>struct inet_sock {
</span><span class='line'>&#9;/* sk and pinet6 has to be the first two members of inet_sock */
</span><span class='line'>&#9;struct sock        sk;
</span><span class='line'>#if defined(CONFIG_IPV6) || defined(CONFIG_IPV6_MODULE)
</span><span class='line'>&#9;struct ipv6_pinfo    *pinet6;
</span><span class='line'>#endif
</span><span class='line'>&#9;/* Socket demultiplex comparisons on incoming packets.wumingxiaozu */
</span><span class='line'>&#9;__be32               daddr;
</span><span class='line'>&#9;__be32               rcv_saddr;
</span><span class='line'>&#9;__be16               dport;
</span><span class='line'>&#9;__u16                num;
</span><span class='line'>&#9;__be32               saddr;
</span><span class='line'>&#9;__s16                uc_ttl;
</span><span class='line'>&#9;__u16                cmsg_flags;
</span><span class='line'>&#9;struct ip_options    *opt;
</span><span class='line'>&#9;__be16               sport;
</span><span class='line'>&#9;__u16                id;
</span><span class='line'>&#9;__u8                 tos;
</span><span class='line'>&#9;__u8                 mc_ttl;
</span><span class='line'>&#9;__u8                 pmtudisc;
</span><span class='line'>&#9;__u8                 recverr:1,
</span><span class='line'>&#9;                     is_icsk:1,
</span><span class='line'>&#9;                     freebind:1,
</span><span class='line'>&#9;                     hdrincl:1,
</span><span class='line'>&#9;                     mc_loop:1;
</span><span class='line'>&#9;int                  mc_index;
</span><span class='line'>&#9;__be32               mc_addr;
</span><span class='line'>&#9;struct ip_mc_socklist    *mc_list;
</span><span class='line'>&#9;struct {
</span><span class='line'>&#9;&#9;unsigned int        flags;
</span><span class='line'>&#9;&#9;unsigned int        fragsize;
</span><span class='line'>&#9;&#9;struct ip_options   *opt;
</span><span class='line'>&#9;&#9;struct dst_entry    *dst;
</span><span class='line'>&#9;&#9;int                 length; /* Total length of all frames */
</span><span class='line'>&#9;&#9;__be32              addr;
</span><span class='line'>&#9;&#9;struct flowi        fl;
</span><span class='line'>&#9;} cork;
</span><span class='line'>};</span></code></pre></td></tr></table></div></figure>


<p>这个结构中的头一个变量就是sock结构，所以这里直接将sock的地址做为inet_sock结构的开始是完全可以的，这也就是inet_sk()这个函数的主要作用</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>sys_accept()--&gt;inet_getname()--&gt;inet_sk()
</span><span class='line'>static inline struct inet_sock *inet_sk(const struct sock *sk)
</span><span class='line'>{
</span><span class='line'>&#9;return (struct inet_sock *)sk;
</span><span class='line'>}</span></code></pre></td></tr></table></div></figure>


<p>那么可能会有朋友问我们只是从icsk->icsk_accept_queue接收队列中间接得到了sock结构指针并没有看到inet_sock结构指针啊？请朋友们相信我们在后边叙述完了客户端的连接请求过程后会把这部分给补上的，所以这里的inet_sock肯定是在服务器的底层驱动相关的部分完成的，我们将在完成客户端的连接后分析这部分的关键内容。所以我们看到这里将inet_sock结构中的请求方即客户端的端口和地址间接设置进了应用程序的地址结构变量client_address就取得了客户端的地址，这个过程是在sys_accept()中使用</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>err = move_addr_to_user(address, len, upeer_sockaddr,
</span><span class='line'>&#9;&#9;&#9;&#9;upeer_addrlen);</span></code></pre></td></tr></table></div></figure>


<p>将客户端的socket地址复制给我们的应用程序界面。我们上边已经通过inet_getname（）函数复制客户端的地址到address数组中了，这样通过move_addr_to_user()函数后，我们程序界面上client_address就得到了客户端的socket地址。接着我们看到函数执行了fd_install（）函数，即为新创建的socket分配一个文件号和file结构，有关没有详述的函数请朋友们参考深入理解LINUX内核第三版中的介绍，自己阅读暂且做为一种练习吧。 朋友们看到这里可以结合一下我们的地图，因为截止到现在我们都是围绕着地图中的服务器角度来分析的，接下来的章节我们将转换到客户端的角度来分析。</p>
</div>
  
  


    </article>
  
  
    <article>
      
  <header>
    
      <h2 class="entry-title"><a href="/blog/2015/06/03/kernel-net-rps/">Receive packet steering patch详解</a></h2>
    
    
      <p class="meta">
        




<time class='entry-date' datetime='2015-06-03T15:39:00+08:00'><span class='date'>2015-06-03</span> <span class='time'>15:39:00</span></time>
        
      </p>
    
  </header>


  <div class="entry-content"><p><a href="http://simohayha.iteye.com/blog/720850">http://simohayha.iteye.com/blog/720850</a></p>

<p>Receive packet steering简称rps，是google贡献给linux kernel的一个patch，主要的功能是解决多核情况下，网络协议栈的软中断的负载均衡。这里的负载均衡也就是指能够将软中断均衡的放在不同的cpu核心上运行。</p>

<p>简介在这里：<br/>
<a href="http://lwn.net/Articles/362339/">http://lwn.net/Articles/362339/</a></p>

<p>linux现在网卡的驱动支持两种模式，一种是NAPI，一种是非NAPI模式，这两种模式的区别，我前面的blog都有介绍，这里就再次简要的介绍下。</p>

<p>在NAPI中，中断收到数据包后调用__napi_schedule调度软中断，然后软中断处理函数中会调用注册的poll回掉函数中调用netif_receive_skb将数据包发送到3层，没有进行任何的软中断负载均衡。</p>

<p>在非NAPI中，中断收到数据包后调用netif_rx，这个函数会将数据包保存到input_pkt_queue，然后调度软中断，这里为了兼容NAPI的驱动，他的poll方法默认是process_backlog，最终这个函数会从input_pkt_queue中取得数据包然后发送到3层。</p>

<p>通过比较我们可以看到，不管是NAPI还是非NAPI的话都无法做到软中断的负载均衡，因为软中断此时都是运行在在硬件中断相应的cpu上。也就是说如果始终是cpu0相应网卡的硬件中断，那么始终都是cpu0在处理软中断，而此时cpu1就被浪费了，因为无法并行的执行多个软中断。</p>

<p>google的这个patch的基本原理是这样的,根据数据包的源地址，目的地址以及目的和源端口(这里它是将两个端口组合成一个4字节的无符数进行计算的，后面会看到)计算出一个hash值，然后根据这个hash值来选择软中断运行的cpu，从上层来看，也就是说将每个连接和cpu绑定，并通过这个hash值，来均衡软中断在多个cpu上。</p>

<p>这个介绍比较简单，我们来看代码是如何实现的。</p>

<p>它这里主要是hook了两个内核的函数，一个是netif_rx主要是针对非NAPI的驱动，一个是netif_receive_skb这个主要是针对NAPI的驱动，这两个函数我前面blog都有介绍过，想了解可以看我前面的blog，现在这里我只介绍打过patch的实现。</p>

<p>在看netif_rx和netif_receive_skb之前，我们先来看这个patch中两个重要的函数get_rps_cpu和enqueue_to_backlog，我们一个个看。</p>

<p>先来看相关的两个数据结构，首先是netdev_rx_queue，它表示对应的接收队列，因为有的网卡可能硬件上就支持多队列的模式，此时对应就会有多个rx队列，这个结构是挂载在net_device中的，也就是每个网络设备最终都会有一个或者多个rx队列。这个结构在sys文件系统中的表示类似这样的/sys/class/net/<device>/queues/rx-<n> 几个队列就是rx-n.</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>struct netdev_rx_queue {
</span><span class='line'>&#9;// 保存了当前队列的rps map
</span><span class='line'>&#9;struct rps_map *rps_map;
</span><span class='line'>&#9;// 对应的kobject
</span><span class='line'>&#9;struct kobject kobj;
</span><span class='line'>&#9;// 指向第一个rx队列
</span><span class='line'>&#9;struct netdev_rx_queue *first;
</span><span class='line'>&#9;// 引用计数
</span><span class='line'>&#9;atomic_t count;
</span><span class='line'>} ____cacheline_aligned_in_smp;</span></code></pre></td></tr></table></div></figure>


<p>然后就是rps_map，其实这个也就是保存了能够执行数据包的cpu。</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>struct rps_map {
</span><span class='line'>&#9;// cpu的个数，也就是cpus数组的个数
</span><span class='line'>&#9;unsigned int len;
</span><span class='line'>&#9;// RCU锁
</span><span class='line'>&#9;struct rcu_head rcu;
</span><span class='line'>&#9;// 保存了cpu的id.
</span><span class='line'>&#9;u16 cpus[0];
</span><span class='line'>};</span></code></pre></td></tr></table></div></figure>


<p>看完上面的结构，我们来看函数的实现。
get_rps_cpu主要是通过传递进来的skb然后来选择这个skb所应该被处理的cpu。它的逻辑很简单，就是通过skb计算hash，然后通过hash从对应的队列的rps_mapping中取得对应的cpu id。</p>

<p>这里有个要注意的就是这个hash值是可以交给硬件网卡去计算的，作者自己说是最好交由硬件去计算这个hash值，因为如果是软件计算的话会导致CPU 缓存不命中，带来一定的性能开销。</p>

<p>还有就是rps_mapping这个值是可以通过sys 文件系统设置的，位置在这里：
/sys/class/net/<device>/queues/rx-<n>/rps_cpus 。</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
<span class='line-number'>16</span>
<span class='line-number'>17</span>
<span class='line-number'>18</span>
<span class='line-number'>19</span>
<span class='line-number'>20</span>
<span class='line-number'>21</span>
<span class='line-number'>22</span>
<span class='line-number'>23</span>
<span class='line-number'>24</span>
<span class='line-number'>25</span>
<span class='line-number'>26</span>
<span class='line-number'>27</span>
<span class='line-number'>28</span>
<span class='line-number'>29</span>
<span class='line-number'>30</span>
<span class='line-number'>31</span>
<span class='line-number'>32</span>
<span class='line-number'>33</span>
<span class='line-number'>34</span>
<span class='line-number'>35</span>
<span class='line-number'>36</span>
<span class='line-number'>37</span>
<span class='line-number'>38</span>
<span class='line-number'>39</span>
<span class='line-number'>40</span>
<span class='line-number'>41</span>
<span class='line-number'>42</span>
<span class='line-number'>43</span>
<span class='line-number'>44</span>
<span class='line-number'>45</span>
<span class='line-number'>46</span>
<span class='line-number'>47</span>
<span class='line-number'>48</span>
<span class='line-number'>49</span>
<span class='line-number'>50</span>
<span class='line-number'>51</span>
<span class='line-number'>52</span>
<span class='line-number'>53</span>
<span class='line-number'>54</span>
<span class='line-number'>55</span>
<span class='line-number'>56</span>
<span class='line-number'>57</span>
<span class='line-number'>58</span>
<span class='line-number'>59</span>
<span class='line-number'>60</span>
<span class='line-number'>61</span>
<span class='line-number'>62</span>
<span class='line-number'>63</span>
<span class='line-number'>64</span>
<span class='line-number'>65</span>
<span class='line-number'>66</span>
<span class='line-number'>67</span>
<span class='line-number'>68</span>
<span class='line-number'>69</span>
<span class='line-number'>70</span>
<span class='line-number'>71</span>
<span class='line-number'>72</span>
<span class='line-number'>73</span>
<span class='line-number'>74</span>
<span class='line-number'>75</span>
<span class='line-number'>76</span>
<span class='line-number'>77</span>
<span class='line-number'>78</span>
<span class='line-number'>79</span>
<span class='line-number'>80</span>
<span class='line-number'>81</span>
<span class='line-number'>82</span>
<span class='line-number'>83</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>static int get_rps_cpu(struct net_device *dev, struct sk_buff *skb)
</span><span class='line'>{
</span><span class='line'>&#9;struct ipv6hdr *ip6;
</span><span class='line'>&#9;struct iphdr *ip;
</span><span class='line'>&#9;struct netdev_rx_queue *rxqueue;
</span><span class='line'>&#9;struct rps_map *map;
</span><span class='line'>&#9;int cpu = -1;
</span><span class='line'>&#9;u8 ip_proto;
</span><span class='line'>&#9;u32 addr1, addr2, ports, ihl;
</span><span class='line'>&#9;// rcu锁
</span><span class='line'>&#9;rcu_read_lock();
</span><span class='line'>&#9;// 取得设备对应的rx 队列
</span><span class='line'>&#9;if (skb_rx_queue_recorded(skb)) {
</span><span class='line'>&#9;..........................................
</span><span class='line'>&#9;&#9;rxqueue = dev-&gt;_rx + index;
</span><span class='line'>&#9;} else
</span><span class='line'>&#9;&#9;rxqueue = dev-&gt;_rx;
</span><span class='line'>
</span><span class='line'>&#9;if (!rxqueue-&gt;rps_map)
</span><span class='line'>&#9;&#9;goto done;
</span><span class='line'>&#9;// 如果硬件已经计算，则跳过计算过程
</span><span class='line'>&#9;if (skb-&gt;rxhash)
</span><span class='line'>&#9;&#9;goto got_hash; /* Skip hash computation on packet header */
</span><span class='line'>
</span><span class='line'>&#9;switch (skb-&gt;protocol) {
</span><span class='line'>&#9;case __constant_htons(ETH_P_IP):
</span><span class='line'>&#9;&#9;if (!pskb_may_pull(skb, sizeof(*ip)))
</span><span class='line'>&#9;&#9;&#9;goto done;
</span><span class='line'>&#9;&#9;// 得到计算hash的几个值
</span><span class='line'>&#9;&#9;ip = (struct iphdr *) skb-&gt;data;
</span><span class='line'>&#9;&#9;ip_proto = ip-&gt;protocol;
</span><span class='line'>&#9;&#9;// 两个地址
</span><span class='line'>&#9;&#9;addr1 = ip-&gt;saddr;
</span><span class='line'>&#9;&#9;addr2 = ip-&gt;daddr;
</span><span class='line'>&#9;&#9;// 得到ip头
</span><span class='line'>&#9;&#9;ihl = ip-&gt;ihl;
</span><span class='line'>&#9;&#9;break;
</span><span class='line'>&#9;case __constant_htons(ETH_P_IPV6):
</span><span class='line'>&#9;&#9;..........................................
</span><span class='line'>&#9;&#9;break;
</span><span class='line'>&#9;default:
</span><span class='line'>&#9;&#9;goto done;
</span><span class='line'>&#9;}
</span><span class='line'>&#9;ports = 0;
</span><span class='line'>&#9;switch (ip_proto) {
</span><span class='line'>&#9;case IPPROTO_TCP:
</span><span class='line'>&#9;case IPPROTO_UDP:
</span><span class='line'>&#9;case IPPROTO_DCCP:
</span><span class='line'>&#9;case IPPROTO_ESP:
</span><span class='line'>&#9;case IPPROTO_AH:
</span><span class='line'>&#9;case IPPROTO_SCTP:
</span><span class='line'>&#9;case IPPROTO_UDPLITE:
</span><span class='line'>&#9;&#9;if (pskb_may_pull(skb, (ihl * 4) + 4))
</span><span class='line'>&#9;&#9;// 我们知道tcp头的前4个字节就是源和目的端口，因此这里跳过ip头得到tcp头的前4个字节
</span><span class='line'>&#9;&#9;&#9;ports = *((u32 *) (skb-&gt;data + (ihl * 4)));
</span><span class='line'>&#9;&#9;break;
</span><span class='line'>
</span><span class='line'>&#9;default:
</span><span class='line'>&#9;&#9;break;
</span><span class='line'>&#9;}
</span><span class='line'>&#9;// 计算hash
</span><span class='line'>&#9;skb-&gt;rxhash = jhash_3words(addr1, addr2, ports, hashrnd);
</span><span class='line'>&#9;if (!skb-&gt;rxhash)
</span><span class='line'>&#9;&#9;skb-&gt;rxhash = 1;
</span><span class='line'>
</span><span class='line'>got_hash:
</span><span class='line'>&#9;// 通过rcu得到对应rps map
</span><span class='line'>&#9;map = rcu_dereference(rxqueue-&gt;rps_map);
</span><span class='line'>&#9;if (map) {
</span><span class='line'>&#9;&#9;// 取得对应的cpu
</span><span class='line'>&#9;&#9;u16 tcpu = map-&gt;cpus[((u64) skb-&gt;rxhash * map-&gt;len) &gt;&gt; 32];
</span><span class='line'>&#9;&#9;// 如果cpu是online的，则返回计算出的这个cpu，否则跳出循环。
</span><span class='line'>&#9;&#9;if (cpu_online(tcpu)) {
</span><span class='line'>&#9;&#9;&#9;cpu = tcpu;
</span><span class='line'>&#9;&#9;&#9;goto done;
</span><span class='line'>&#9;&#9;}
</span><span class='line'>&#9;}
</span><span class='line'>
</span><span class='line'>done:
</span><span class='line'>&#9;rcu_read_unlock();
</span><span class='line'>&#9;// 如果上面失败，则返回-1.
</span><span class='line'>&#9;return cpu;
</span><span class='line'>}</span></code></pre></td></tr></table></div></figure>


<p>然后是enqueue_to_backlog这个方法，首先我们知道在每个cpu都有一个softnet结构，而他有一个input_pkt_queue的队列，以前这个主要是用于非NAPi的驱动的，而这个patch则将这个队列也用与NAPI的处理中了。也就是每个cpu现在都会有一个input_pkt_queue队列，用于保存需要处理的数据包队列。这个队列作用现在是，如果发现不属于当前cpu处理的数据包，则我们可以直接将数据包挂载到他所属的cpu的input_pkt_queue中。</p>

<p>enqueue_to_backlog接受一个skb和cpu为参数，通过cpu来判断skb如何处理。要么加入所属的input_pkt_queue中，要么schecule 软中断。</p>

<p>还有个要注意就是我们知道NAPI为了兼容非NAPI模式，有个backlog的napi_struct结构，也就是非NAPI驱动会schedule backlog这个napi结构，而在enqueue_to_backlog中则是利用了这个结构，也就是它会schedule backlog，因为它会将数据放到input_pkt_queue中，而backlog的pool方法process_backlog就是从input_pkt_queue中取得数据然后交给上层处理。</p>

<p>这里还有一个会用到结构就是 rps_remote_softirq_cpus，它主要是保存了当前cpu上需要去另外的cpu schedule 软中断的cpu 掩码。因为我们可能将要处理的数据包放到了另外的cpu的input queue上，因此我们需要schedule 另外的cpu上的napi(也就是软中断),所以我们需要保存对应的cpu掩码，以便于后面遍历，然后schedule。</p>

<p>而这里为什么mask有两个元素，注释写的很清楚：</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>/*
</span><span class='line'> * This structure holds the per-CPU mask of CPUs for which IPIs are scheduled
</span><span class='line'> * to be sent to kick remote softirq processing.  There are two masks since
</span><span class='line'> * the sending of IPIs must be done with interrupts enabled.  The select field
</span><span class='line'> * indicates the current mask that enqueue_backlog uses to schedule IPIs.
</span><span class='line'> * select is flipped before net_rps_action is called while still under lock,
</span><span class='line'> * net_rps_action then uses the non-selected mask to send the IPIs and clears
</span><span class='line'> * it without conflicting with enqueue_backlog operation.
</span><span class='line'> */
</span><span class='line'>struct rps_remote_softirq_cpus {
</span><span class='line'>&#9;// 对应的cpu掩码
</span><span class='line'>&#9;cpumask_t mask[2];
</span><span class='line'>&#9;// 表示应该使用的数组索引
</span><span class='line'>&#9;int select;
</span><span class='line'>};</span></code></pre></td></tr></table></div></figure>




<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
<span class='line-number'>16</span>
<span class='line-number'>17</span>
<span class='line-number'>18</span>
<span class='line-number'>19</span>
<span class='line-number'>20</span>
<span class='line-number'>21</span>
<span class='line-number'>22</span>
<span class='line-number'>23</span>
<span class='line-number'>24</span>
<span class='line-number'>25</span>
<span class='line-number'>26</span>
<span class='line-number'>27</span>
<span class='line-number'>28</span>
<span class='line-number'>29</span>
<span class='line-number'>30</span>
<span class='line-number'>31</span>
<span class='line-number'>32</span>
<span class='line-number'>33</span>
<span class='line-number'>34</span>
<span class='line-number'>35</span>
<span class='line-number'>36</span>
<span class='line-number'>37</span>
<span class='line-number'>38</span>
<span class='line-number'>39</span>
<span class='line-number'>40</span>
<span class='line-number'>41</span>
<span class='line-number'>42</span>
<span class='line-number'>43</span>
<span class='line-number'>44</span>
<span class='line-number'>45</span>
<span class='line-number'>46</span>
<span class='line-number'>47</span>
<span class='line-number'>48</span>
<span class='line-number'>49</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>static int enqueue_to_backlog(struct sk_buff *skb, int cpu)
</span><span class='line'>{
</span><span class='line'>&#9;struct softnet_data *queue;
</span><span class='line'>&#9;unsigned long flags;
</span><span class='line'>&#9;// 取出传递进来的cpu的softnet-data结构
</span><span class='line'>&#9;queue = &per_cpu(softnet_data, cpu);
</span><span class='line'>
</span><span class='line'>&#9;local_irq_save(flags);
</span><span class='line'>&#9;__get_cpu_var(netdev_rx_stat).total++;
</span><span class='line'>&#9;// 自旋锁
</span><span class='line'>&#9;spin_lock(&queue-&gt;input_pkt_queue.lock);
</span><span class='line'>&#9;// 如果保存的队列还没到上限
</span><span class='line'>&#9;if (queue-&gt;input_pkt_queue.qlen &lt;= netdev_max_backlog) {
</span><span class='line'>&#9;// 如果当前队列的输入队列长度不为空
</span><span class='line'>&#9;&#9;if (queue-&gt;input_pkt_queue.qlen) {
</span><span class='line'>enqueue:
</span><span class='line'>&#9;&#9;&#9;// 将数据包加入到input_pkt_queue中,这里会有一个小问题，我们后面再说。
</span><span class='line'>&#9;&#9;&#9;__skb_queue_tail(&queue-&gt;input_pkt_queue, skb);
</span><span class='line'>&#9;&#9;&#9;spin_unlock_irqrestore(&queue-&gt;input_pkt_queue.lock,
</span><span class='line'>&#9;&#9;&#9;&#9;flags);
</span><span class='line'>&#9;&#9;&#9;return NET_RX_SUCCESS;
</span><span class='line'>&#9;&#9;}
</span><span class='line'>
</span><span class='line'>&#9;&#9;/* Schedule NAPI for backlog device */
</span><span class='line'>&#9;&#9;// 如果可以调度软中断
</span><span class='line'>&#9;&#9;if (napi_schedule_prep(&queue-&gt;backlog)) {
</span><span class='line'>&#9;&#9;&#9;// 首先判断数据包该不该当前的cpu处理
</span><span class='line'>&#9;&#9;&#9;if (cpu != smp_processor_id()) {
</span><span class='line'>&#9;&#9;&#9;&#9;// 如果不该，
</span><span class='line'>&#9;&#9;&#9;&#9;struct rps_remote_softirq_cpus *rcpus =
</span><span class='line'>&#9;&#9;&#9;&#9;&#9;&__get_cpu_var(rps_remote_softirq_cpus);
</span><span class='line'>
</span><span class='line'>&#9;&#9;&#9;&#9;cpu_set(cpu, rcpus-&gt;mask[rcpus-&gt;select]);
</span><span class='line'>&#9;&#9;&#9;&#9;__raise_softirq_irqoff(NET_RX_SOFTIRQ);
</span><span class='line'>&#9;&#9;&#9;} else
</span><span class='line'>&#9;&#9;&#9;&#9;// 如果就是应该当前cpu处理，则直接schedule 软中断，这里可以看到传递进去的是backlog
</span><span class='line'>&#9;&#9;&#9;&#9;__napi_schedule(&queue-&gt;backlog);
</span><span class='line'>&#9;&#9;}
</span><span class='line'>&#9;&#9;goto enqueue;
</span><span class='line'>&#9;}
</span><span class='line'>
</span><span class='line'>&#9;spin_unlock(&queue-&gt;input_pkt_queue.lock);
</span><span class='line'>
</span><span class='line'>&#9;__get_cpu_var(netdev_rx_stat).dropped++;
</span><span class='line'>&#9;local_irq_restore(flags);
</span><span class='line'>
</span><span class='line'>&#9;kfree_skb(skb);
</span><span class='line'>&#9;return NET_RX_DROP;
</span><span class='line'>}</span></code></pre></td></tr></table></div></figure>


<p>这里会有一个小问题，那就是假设此时一个属于cpu0的包进入处理，此时我们运行在cpu1,此时将数据包加入到input队列，然后cpu0上面刚好又来了一个cpu0需要处理的数据包，此时由于qlen不为0则又将数据包加入到input队列中，我们会发现cpu0上的napi没机会进行调度了。</p>

<p>google的patch对这个是这样处理的，在软中断处理函数中当数据包处理完毕，会调用net_rps_action来调度前面保存到其他cpu上的input队列。</p>

<p>下面就是代码片断（net_rx_action）</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>// 得到对应的rcpus.
</span><span class='line'>rcpus = &__get_cpu_var(rps_remote_softirq_cpus);
</span><span class='line'>&#9;select = rcpus-&gt;select;
</span><span class='line'>&#9;// 翻转select，防止和enqueue_backlog冲突
</span><span class='line'>&#9;rcpus-&gt;select ^= 1;
</span><span class='line'>
</span><span class='line'>&#9;// 打开中断，此时下面的调度才会起作用.
</span><span class='line'>&#9;local_irq_enable();
</span><span class='line'>&#9;// 这个函数里面调度对应的远程cpu的napi.
</span><span class='line'>&#9;net_rps_action(&rcpus-&gt;mask[select]);</span></code></pre></td></tr></table></div></figure>


<p>然后就是net_rps_action，这个函数很简单，就是遍历所需要处理的cpu，然后调度napi</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>static void net_rps_action(cpumask_t *mask)
</span><span class='line'>{
</span><span class='line'>&#9;int cpu;
</span><span class='line'>
</span><span class='line'>&#9;/* Send pending IPI's to kick RPS processing on remote cpus. */
</span><span class='line'>&#9;// 遍历
</span><span class='line'>&#9;for_each_cpu_mask_nr(cpu, *mask) {
</span><span class='line'>&#9;&#9;struct softnet_data *queue = &per_cpu(softnet_data, cpu);
</span><span class='line'>&#9;&#9;if (cpu_online(cpu))
</span><span class='line'>&#9;&#9;&#9;// 到对应的cpu调用csd方法。
</span><span class='line'>&#9;&#9;&#9;__smp_call_function_single(cpu, &queue-&gt;csd, 0);
</span><span class='line'>&#9;}
</span><span class='line'>&#9;// 清理mask
</span><span class='line'>&#9;cpus_clear(*mask);
</span><span class='line'>}</span></code></pre></td></tr></table></div></figure>


<p>上面我们看到会调用csd方法，而上面的csd回掉就是被初始化为trigger_softirq函数。</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>static void trigger_softirq(void *data)
</span><span class='line'>{
</span><span class='line'>&#9;struct softnet_data *queue = data;
</span><span class='line'>&#9;// 调度napi可以看到依旧是backlog 这个napi结构体。
</span><span class='line'>&#9;__napi_schedule(&queue-&gt;backlog);
</span><span class='line'>&#9;__get_cpu_var(netdev_rx_stat).received_rps++;
</span><span class='line'>}</span></code></pre></td></tr></table></div></figure>


<p>上面的函数都分析完毕了，剩下的就很简单了。</p>

<p>首先来看netif_rx如何被修改的，它被修改的很简单，首先是得到当前skb所应该被处理的cpu id，然后再通过比较这个cpu和当前正在处理的cpu id进行比较来做不同的处理。</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
<span class='line-number'>16</span>
<span class='line-number'>17</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>int netif_rx(struct sk_buff *skb)
</span><span class='line'>{
</span><span class='line'>&#9;int cpu;
</span><span class='line'>
</span><span class='line'>&#9;/* if netpoll wants it, pretend we never saw it */
</span><span class='line'>&#9;if (netpoll_rx(skb))
</span><span class='line'>&#9;&#9;return NET_RX_DROP;
</span><span class='line'>
</span><span class='line'>&#9;if (!skb-&gt;tstamp.tv64)
</span><span class='line'>&#9;&#9;net_timestamp(skb);
</span><span class='line'>&#9;// 得到cpu id。
</span><span class='line'>&#9;cpu = get_rps_cpu(skb-&gt;dev, skb);
</span><span class='line'>&#9;if (cpu &lt; 0)
</span><span class='line'>&#9;&#9;cpu = smp_processor_id();
</span><span class='line'>&#9;// 通过cpu进行队列不同的处理
</span><span class='line'>&#9;return enqueue_to_backlog(skb, cpu);
</span><span class='line'>}</span></code></pre></td></tr></table></div></figure>


<p>然后是netif_receive_skb,这里patch将内核本身的这个函数改写为__netif_receive_skb。然后当返回值小于0,则说明不需要对队列进行处理，此时直接发送到3层。</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>int netif_receive_skb(struct sk_buff *skb)
</span><span class='line'>{
</span><span class='line'>&#9;int cpu;
</span><span class='line'>
</span><span class='line'>&#9;cpu = get_rps_cpu(skb-&gt;dev, skb);
</span><span class='line'>
</span><span class='line'>&#9;if (cpu &lt; 0)
</span><span class='line'>&#9;&#9;return __netif_receive_skb(skb);
</span><span class='line'>&#9;else
</span><span class='line'>&#9;&#9;return enqueue_to_backlog(skb, cpu);
</span><span class='line'>}</span></code></pre></td></tr></table></div></figure>


<p>最后来总结一下，可以看到input_pkt_queue是一个FIFO的队列，而且如果当qlen有值的时候，也就是在另外的cpu有数据包放到input_pkt_queue中，则当前cpu不会调度napi，而是将数据包放到input_pkt_queue中，然后等待trigger_softirq来调度napi。</p>

<p>因此这个patch完美的解决了软中断在多核下的均衡问题，并且没有由于是同一个连接会map到相同的cpu，并且input_pkt_queue的使用，因此乱序的问题也不会出现。</p>
</div>
  
  


    </article>
  
  
    <article>
      
  <header>
    
      <h2 class="entry-title"><a href="/blog/2015/06/03/kernel-net-mem/">内核协议栈tcp层的内存管理</a></h2>
    
    
      <p class="meta">
        




<time class='entry-date' datetime='2015-06-03T14:25:00+08:00'><span class='date'>2015-06-03</span> <span class='time'>14:25:00</span></time>
        
      </p>
    
  </header>


  <div class="entry-content"><p><a href="http://simohayha.iteye.com/blog/532450">http://simohayha.iteye.com/blog/532450</a></p>

<p><a href="http://www.ibm.com/developerworks/cn/linux/l-hisock.html#table1">http://www.ibm.com/developerworks/cn/linux/l-hisock.html#table1</a></p>

<p><a href="http://blog.csdn.net/russell_tao/article/details/18711023">http://blog.csdn.net/russell_tao/article/details/18711023</a></p>

<p>我们先来看tcp内存管理相关的几个内核参数,这些都能通过proc文件系统来修改:</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>// 内核写buf的最大值.
</span><span class='line'>extern __u32 sysctl_wmem_max;
</span><span class='line'>// 协议栈读buf的最大值
</span><span class='line'>extern __u32 sysctl_rmem_max;</span></code></pre></td></tr></table></div></figure>


<p>这两个值在/proc/sys/net/core 下。这里要注意，这两个值的单位是字节。</p>

<p>它们的初始化在sk_init里面,这里可以看到这两个值的大小是依赖于num_physpages的，而这个值应该是物理页数。也就是说这两个值依赖于物理内存：</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>void __init sk_init(void)
</span><span class='line'>{
</span><span class='line'>&#9;if (num_physpages &lt;= 4096) {
</span><span class='line'>&#9;&#9;sysctl_wmem_max = 32767;
</span><span class='line'>&#9;&#9;sysctl_rmem_max = 32767;
</span><span class='line'>&#9;&#9;sysctl_wmem_default = 32767;
</span><span class='line'>&#9;&#9;sysctl_rmem_default = 32767;
</span><span class='line'>&#9;} else if (num_physpages &gt;= 131072) {
</span><span class='line'>&#9;&#9;sysctl_wmem_max = 131071;
</span><span class='line'>&#9;&#9;sysctl_rmem_max = 131071;
</span><span class='line'>&#9;}
</span><span class='line'>}</span></code></pre></td></tr></table></div></figure>


<p>而我通过搜索源码，只有设置套接口选项的时候，才会用到这两个值，也就是setsockopt，optname为SO_SNDBUF或者SO_RCVBUF时，来限制设置的值:</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>case SO_SNDBUF:
</span><span class='line'>&#9;&#9;if (val &gt; sysctl_wmem_max)
</span><span class='line'>&#9;&#9;&#9;val = sysctl_wmem_max;</span></code></pre></td></tr></table></div></figure>


<p>接下来就是整个tcp协议栈的socket的buf限制(也就是所有的socket).
这里要注意，这个东西的单位都是以页为单位的，我们下面就会看到。</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>其中sysctl_tcp_mem[0]表示整个tcp sock的buf限制.
</span><span class='line'>sysctl_tcp_mem[1]也就是tcp sock内存使用的警戒线.
</span><span class='line'>sysctl_tcp_mem[2]也就是tcp sock内存使用的hard limit,当超过这个限制,我们就要禁止再分配buf.
</span><span class='line'>extern int sysctl_tcp_mem[3];</span></code></pre></td></tr></table></div></figure>


<p>接下来就是针对每个sock的读写buf限制。</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>// 其中依次为最小buf,中等buf,以及最大buf.
</span><span class='line'>extern int sysctl_tcp_wmem[3];
</span><span class='line'>extern int sysctl_tcp_rmem[3];</span></code></pre></td></tr></table></div></figure>


<h4>tcp_init</h4>

<p>这几个值的初始化在tcp_init里面，这里就能清晰的看到sysctl_tcp_mem的单位是页。而sysctl_tcp_wmem和sysctl_tcp_rmem的单位是字节。</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
<span class='line-number'>16</span>
<span class='line-number'>17</span>
<span class='line-number'>18</span>
<span class='line-number'>19</span>
<span class='line-number'>20</span>
<span class='line-number'>21</span>
<span class='line-number'>22</span>
<span class='line-number'>23</span>
<span class='line-number'>24</span>
<span class='line-number'>25</span>
<span class='line-number'>26</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>void __init tcp_init(void)
</span><span class='line'>{
</span><span class='line'>&#9;.................................
</span><span class='line'>&#9;// nr_pages就是页。
</span><span class='line'>&#9;nr_pages = totalram_pages - totalhigh_pages;
</span><span class='line'>&#9;limit = min(nr_pages, 1UL&lt;&lt;(28-PAGE_SHIFT)) &gt;&gt; (20-PAGE_SHIFT);
</span><span class='line'>&#9;limit = (limit * (nr_pages &gt;&gt; (20-PAGE_SHIFT))) &gt;&gt; (PAGE_SHIFT-11);
</span><span class='line'>&#9;limit = max(limit, 128UL);
</span><span class='line'>&#9;sysctl_tcp_mem[0] = limit / 4 * 3;
</span><span class='line'>&#9;sysctl_tcp_mem[1] = limit;
</span><span class='line'>&#9;sysctl_tcp_mem[2] = sysctl_tcp_mem[0] * 2;
</span><span class='line'>
</span><span class='line'>&#9;/* Set per-socket limits to no more than 1/128 the pressure threshold */
</span><span class='line'>&#9;// 转换为字节。
</span><span class='line'>&#9;limit = ((unsigned long)sysctl_tcp_mem[1]) &lt;&lt; (PAGE_SHIFT - 7);
</span><span class='line'>&#9;max_share = min(4UL*1024*1024, limit);
</span><span class='line'>
</span><span class='line'>&#9;sysctl_tcp_wmem[0] = SK_MEM_QUANTUM;
</span><span class='line'>&#9;sysctl_tcp_wmem[1] = 16*1024;
</span><span class='line'>&#9;sysctl_tcp_wmem[2] = max(64*1024, max_share);
</span><span class='line'>
</span><span class='line'>&#9;sysctl_tcp_rmem[0] = SK_MEM_QUANTUM;
</span><span class='line'>&#9;sysctl_tcp_rmem[1] = 87380;
</span><span class='line'>&#9;sysctl_tcp_rmem[2] = max(87380, max_share);
</span><span class='line'>&#9;................................
</span><span class='line'>}</span></code></pre></td></tr></table></div></figure>


<p>然后就是读写buf的最小值</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>#define SOCK_MIN_SNDBUF 2048
</span><span class='line'>#define SOCK_MIN_RCVBUF 256</span></code></pre></td></tr></table></div></figure>


<p>最后就是当前tcp协议栈已经分配了的buf的总大小。这里要注意，这个值也是以页为单位的。</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>atomic_t tcp_memory_allocated</span></code></pre></td></tr></table></div></figure>


<p>而上面的这些值如何与协议栈关联起来呢，我们来看tcp_prot结构，可以看到这些值的地址都被放到对应的tcp_prot的域。</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>struct proto tcp_prot = {
</span><span class='line'>&#9;.name = "TCP",
</span><span class='line'>&#9;.owner = THIS_MODULE,
</span><span class='line'>&#9;...................................................
</span><span class='line'>&#9;.enter_memory_pressure = tcp_enter_memory_pressure,
</span><span class='line'>&#9;.sockets_allocated = &tcp_sockets_allocated,
</span><span class='line'>&#9;.orphan_count = &tcp_orphan_count,
</span><span class='line'>&#9;.memory_allocated = &tcp_memory_allocated,
</span><span class='line'>&#9;.memory_pressure = &tcp_memory_pressure,
</span><span class='line'>&#9;.sysctl_mem = sysctl_tcp_mem,
</span><span class='line'>&#9;.sysctl_wmem = sysctl_tcp_wmem,
</span><span class='line'>&#9;.sysctl_rmem = sysctl_tcp_rmem,
</span><span class='line'>&#9;........................................................
</span><span class='line'>};</span></code></pre></td></tr></table></div></figure>


<p>而对应的sock域中的几个值，这几个域非常重要，我们来看他们表示的含义</p>

<p>sk_rcvbuf和sk_sndbuf,这两个值分别代表每个sock的读写buf的最大限制</p>

<p>sk_rmem_alloc和sk_wmem_alloc这两个值分别代表已经提交的数据包的字节数。</p>

<p>读buf意味着进入tcp层的数据大小，而当数据提交给用户空间之后，这个值会相应的减去提交的大小（也就类似写buf的sk_wmem_queued)。</p>

<p>写buf意味着提交给ip层。可以看到这个值的增加是在tcp_transmit_skb中进行的。</p>

<p>而sk_wmem_queued也就代表skb的写队列write_queue的大小。</p>

<p>还有一个sk_forward_alloc，这个值表示一个预分配置，也就是整个tcp协议栈的内存cache，第一次为一个缓冲区分配buf的时候，我们不会直接分配精确的大小，而是按页来分配，而分配的大小就是这个值，下面我们会看到这个。并且这个值初始是0.</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>struct sock {
</span><span class='line'>&#9;int sk_rcvbuf;
</span><span class='line'>&#9;atomic_t sk_rmem_alloc;
</span><span class='line'>&#9;atomic_t sk_wmem_alloc;
</span><span class='line'>&#9;int sk_forward_alloc;
</span><span class='line'>&#9;..........................
</span><span class='line'>&#9;int sk_sndbuf;
</span><span class='line'>&#9;// 这个表示写buf已经分配的字节长度
</span><span class='line'>&#9;int sk_wmem_queued;
</span><span class='line'>&#9;...........................
</span><span class='line'>}</span></code></pre></td></tr></table></div></figure>


<p>sk_sndbuf和sk_rcvbuf,这两个的初始化在这里：</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>static int tcp_v4_init_sock(struct sock *sk)
</span><span class='line'>{
</span><span class='line'>&#9;..................................
</span><span class='line'>&#9;sk-&gt;sk_sndbuf = sysctl_tcp_wmem[1];
</span><span class='line'>&#9;sk-&gt;sk_rcvbuf = sysctl_tcp_rmem[1];
</span><span class='line'>&#9;..........................
</span><span class='line'>}</span></code></pre></td></tr></table></div></figure>


<p>而当进入establish状态之后,sock会自己调整sndbuf和rcvbuf.他是通过tcp_init_buffer_space来进行调整的.这个函数会调用tcp_fixup_rcvbuf和tcp_fixup_sndbuf来调整读写buf的大小.</p>

<p>这里有用到sk_userlock这个标记，这个标记主要就是用来标记SO_SNDBUF 和SO_RCVBUF套接口选项是否被设置。而是否设置对应的值为：</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>#define SOCK_SNDBUF_LOCK 1
</span><span class='line'>#define SOCK_RCVBUF_LOCK  2</span></code></pre></td></tr></table></div></figure>


<p>我们可以看下面的设置SO_SNDBUF 和SO_RCVBUF的代码片断：</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>// 首先设置sk_userlocks.
</span><span class='line'>sk-&gt;sk_userlocks |= SOCK_SNDBUF_LOCK;
</span><span class='line'>if ((val * 2) &lt; SOCK_MIN_SNDBUF)
</span><span class='line'>&#9;sk-&gt;sk_sndbuf = SOCK_MIN_SNDBUF;
</span><span class='line'>else
</span><span class='line'>&#9;sk-&gt;sk_sndbuf = val * 2;</span></code></pre></td></tr></table></div></figure>


<p>因此内核里面的处理是这样的，如果用户已经通过套接字选项设置了读或者写buf的大小，那么这里将不会调整读写buf的大小，否则就进入tcp_fixup_XXX来调整大小。</p>

<p>还有一个要注意的就是MAX_TCP_HEADER，这个值表示了TCP + IP + link layer headers 以及option的长度。</p>

<p>我们来看代码。</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>static void tcp_init_buffer_space(struct sock *sk)
</span><span class='line'>{
</span><span class='line'>&#9;struct tcp_sock *tp = tcp_sk(sk);
</span><span class='line'>&#9;int maxwin;
</span><span class='line'>
</span><span class='line'>&#9;// 判断sk_userlocks，来决定是否需要fix缓冲区大小。
</span><span class='line'>&#9;if (!(sk-&gt;sk_userlocks & SOCK_RCVBUF_LOCK))
</span><span class='line'>&#9;&#9;tcp_fixup_rcvbuf(sk);
</span><span class='line'>&#9;if (!(sk-&gt;sk_userlocks & SOCK_SNDBUF_LOCK))
</span><span class='line'>&#9;&#9;tcp_fixup_sndbuf(sk);
</span><span class='line'>......................................
</span><span class='line'>
</span><span class='line'>}</span></code></pre></td></tr></table></div></figure>


<p>接下来来看这两个函数如何来调整读写buf的大小，不过这里还有些疑问，就是为什么是要和3<em>sndmem以及4</em>rcvmem：</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
<span class='line-number'>16</span>
<span class='line-number'>17</span>
<span class='line-number'>18</span>
<span class='line-number'>19</span>
<span class='line-number'>20</span>
<span class='line-number'>21</span>
<span class='line-number'>22</span>
<span class='line-number'>23</span>
<span class='line-number'>24</span>
<span class='line-number'>25</span>
<span class='line-number'>26</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>static void tcp_fixup_sndbuf(struct sock *sk)
</span><span class='line'>{
</span><span class='line'>&#9;// 首先通过mss，tcp头，以及sk_buff的大小，得到一个最小范围的sndmem。
</span><span class='line'>&#9;int sndmem = tcp_sk(sk)-&gt;rx_opt.mss_clamp + MAX_TCP_HEADER + 16 +sizeof(struct sk_buff);
</span><span class='line'>
</span><span class='line'>&#9;// 然后取sysctl_tcp_wmem[2]和3倍的sndmem之间的最小值。
</span><span class='line'>&#9;if (sk-&gt;sk_sndbuf &lt; 3 * sndmem)
</span><span class='line'>&#9;&#9;sk-&gt;sk_sndbuf = min(3 * sndmem, sysctl_tcp_wmem[2]);
</span><span class='line'>}
</span><span class='line'>
</span><span class='line'>static void tcp_fixup_rcvbuf(struct sock *sk)
</span><span class='line'>{
</span><span class='line'>&#9;struct tcp_sock *tp = tcp_sk(sk);
</span><span class='line'>&#9;// 这里和上面类似，也是先得到最小的一个rcvmem段。
</span><span class='line'>&#9;int rcvmem = tp-&gt;advmss + MAX_TCP_HEADER + 16 + sizeof(struct sk_buff);
</span><span class='line'>
</span><span class='line'>&#9;/* Try to select rcvbuf so that 4 mss-sized segments
</span><span class='line'>&#9; * will fit to window and corresponding skbs will fit to our rcvbuf.
</span><span class='line'>&#9; * (was 3; 4 is minimum to allow fast retransmit to work.)
</span><span class='line'>&#9; */
</span><span class='line'>&#9;// 这里则是通过sysctl_tcp_adv_win_scale来调整rcvmem的值。
</span><span class='line'>&#9;while (tcp_win_from_space(rcvmem) &lt; tp-&gt;advmss)
</span><span class='line'>&#9;&#9;rcvmem += 128;
</span><span class='line'>&#9;if (sk-&gt;sk_rcvbuf &lt; 4 * rcvmem)
</span><span class='line'>&#9;&#9;sk-&gt;sk_rcvbuf = min(4 * rcvmem, sysctl_tcp_rmem[2]);
</span><span class='line'>}</span></code></pre></td></tr></table></div></figure>


<p>ok，看完初始化，我们来看协议栈具体如何管理内存的，先来看发送端，发送端的主要实现是在tcp_sendmsg里面，这个函数我们前面已经详细的分析过了，我们这次只分析里面几个与内存相关的东西。</p>

<p>来看代码片断：</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
<span class='line-number'>16</span>
<span class='line-number'>17</span>
<span class='line-number'>18</span>
<span class='line-number'>19</span>
<span class='line-number'>20</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>int tcp_sendmsg(struct kiocb *iocb, struct socket *sock, struct msghdr *msg,
</span><span class='line'>&#9;&#9;size_t size)
</span><span class='line'>{
</span><span class='line'>&#9;..................................
</span><span class='line'>
</span><span class='line'>&#9;if (copy &lt;= 0) {
</span><span class='line'>new_segment:
</span><span class='line'>&#9;&#9;if (!sk_stream_memory_free(sk))
</span><span class='line'>&#9;&#9;&#9;goto wait_for_sndbuf;
</span><span class='line'>
</span><span class='line'>&#9;&#9;skb = sk_stream_alloc_skb(sk, select_size(sk),
</span><span class='line'>&#9;&#9;sk-&gt;sk_allocation);
</span><span class='line'>&#9;&#9;if (sk-&gt;sk_route_caps & NETIF_F_ALL_CSUM)
</span><span class='line'>&#9;&#9;&#9;skb-&gt;ip_summed = CHECKSUM_PARTIAL;
</span><span class='line'>
</span><span class='line'>&#9;&#9;skb_entail(sk, skb);
</span><span class='line'>&#9;&#9;copy = size_goal;
</span><span class='line'>&#9;&#9;max = size_goal;
</span><span class='line'>&#9;..................
</span><span class='line'>}</span></code></pre></td></tr></table></div></figure>


<p>可以看到这里第一个sk_stream_memory_free用来判断是否还有空间来供我们分配，如果没有则跳到wait_for_sndbuf来等待buf的释放。</p>

<p>然后如果有空间供我们分配，则调用sk_stream_alloc_skb来分配一个skb，然后这个大小的选择是通过select_size。</p>

<p>最后调用skb_entail来更新相关的域。</p>

<p>现在我们就来详细看上面的四个函数,先来看第一个：</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>static inline int sk_stream_memory_free(struct sock *sk)
</span><span class='line'>{
</span><span class='line'>&#9;return sk-&gt;sk_wmem_queued &lt; sk-&gt;sk_sndbuf;
</span><span class='line'>}</span></code></pre></td></tr></table></div></figure>


<p>sk_stream_memory_free实现很简单，就是判断当前已经分配的写缓冲区的大小(sk_wmem_queued)是否小于当前写缓冲区(sk_sndbuf)的最大限制。</p>

<p>然后是skb_entail，这个函数主要是当我们分配完buf后，进行一些相关域的更新，以及添加skb到writequeue。</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
<span class='line-number'>16</span>
<span class='line-number'>17</span>
<span class='line-number'>18</span>
<span class='line-number'>19</span>
<span class='line-number'>20</span>
<span class='line-number'>21</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>static inline void skb_entail(struct sock *sk, struct sk_buff *skb)
</span><span class='line'>{
</span><span class='line'>&#9;struct tcp_sock *tp = tcp_sk(sk);
</span><span class='line'>&#9;struct tcp_skb_cb *tcb = TCP_SKB_CB(skb);
</span><span class='line'>&#9;............................
</span><span class='line'>&#9;skb_header_release(skb);
</span><span class='line'>&#9;tcp_add_write_queue_tail(sk, skb);
</span><span class='line'>&#9;// 增加sk_wmem_queued.
</span><span class='line'>&#9;sk-&gt;sk_wmem_queued += skb-&gt;truesize;
</span><span class='line'>&#9;// 这里调整sk_forward_alloc的大小，也就是预分配buf的大小(减小).
</span><span class='line'>&#9;sk_mem_charge(sk, skb-&gt;truesize);
</span><span class='line'>&#9;if (tp-&gt;nonagle & TCP_NAGLE_PUSH)
</span><span class='line'>&#9;&#9;tp-&gt;nonagle &= ~TCP_NAGLE_PUSH;
</span><span class='line'>}
</span><span class='line'>// 这个函数很简单，就是将sk_forward_alloc - size.
</span><span class='line'>static inline void sk_mem_charge(struct sock *sk, int size)
</span><span class='line'>{
</span><span class='line'>&#9;if (!sk_has_account(sk))
</span><span class='line'>&#9;&#9;return;
</span><span class='line'>&#9;sk-&gt;sk_forward_alloc -= size;
</span><span class='line'>}</span></code></pre></td></tr></table></div></figure>


<p>然后是select_size，在看这个之前我们先来坎SKB_MAX_HEAD的实现.
SKB_MAX_HEAD主要是得到要分配的tcp数据段（不包括头)在一页中最大为多少。</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>#define SKB_WITH_OVERHEAD(X) \
</span><span class='line'>&#9;((X) - SKB_DATA_ALIGN(sizeof(struct skb_shared_info)))
</span><span class='line'>#define SKB_MAX_ORDER(X, ORDER) \
</span><span class='line'>&#9;SKB_WITH_OVERHEAD((PAGE_SIZE &lt;&lt; (ORDER)) - (X))
</span><span class='line'>#define SKB_MAX_HEAD(X)    (SKB_MAX_ORDER((X), 0))</span></code></pre></td></tr></table></div></figure>


<p>我们带入代码来看，我们下面的代码是SKB_MAX_HEAD(MAX_TCP_HEADER)，展开这个宏可以看到就是PAGE_SIZE-MAX_TCP_HEADER-SKB_DATA_ALIGN(sizeof(struct skb_shared_info).其实也就是一页还能容纳多少tcp的数据。</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
<span class='line-number'>16</span>
<span class='line-number'>17</span>
<span class='line-number'>18</span>
<span class='line-number'>19</span>
<span class='line-number'>20</span>
<span class='line-number'>21</span>
<span class='line-number'>22</span>
<span class='line-number'>23</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>static inline int select_size(struct sock *sk)
</span><span class='line'>{
</span><span class='line'>&#9;struct tcp_sock *tp = tcp_sk(sk);
</span><span class='line'>&#9;// 首先取得存储的mss。
</span><span class='line'>&#9;int tmp = tp-&gt;mss_cache;
</span><span class='line'>
</span><span class='line'>&#9;// 然后判断是否使用scatter–gather(前面blog有介绍)
</span><span class='line'>&#9;if (sk-&gt;sk_route_caps & NETIF_F_SG) {
</span><span class='line'>&#9;&#9;if (sk_can_gso(sk))
</span><span class='line'>&#9;&#9;&#9;tmp = 0;
</span><span class='line'>&#9;&#9;else {
</span><span class='line'>&#9;&#9;&#9;// 然后开始计算buf的长度。
</span><span class='line'>&#9;&#9;&#9;int pgbreak = SKB_MAX_HEAD(MAX_TCP_HEADER);
</span><span class='line'>
</span><span class='line'>&#9;&#9;&#9;// 如果mss大于pgbreak,那么说明我们一页放不下当前需要的tcp数据，因此我们将会在skb的页区域分配，而skb的页区域是有限制的，因此tmp必须小于这个值。
</span><span class='line'>&#9;&#9;&#9;if (tmp &gt;= pgbreak &&
</span><span class='line'>&#9;&#9;&#9;&#9;&#9;tmp &lt;= pgbreak + (MAX_SKB_FRAGS - 1) * PAGE_SIZE)
</span><span class='line'>&#9;&#9;&#9;&#9;tmp = pgbreak;
</span><span class='line'>&#9;&#9;}
</span><span class='line'>&#9;}
</span><span class='line'>
</span><span class='line'>&#9;return tmp;
</span><span class='line'>}</span></code></pre></td></tr></table></div></figure>


<h4>sk_stream_alloc_skb</h4>

<p>接下来来看sk_stream_alloc_skb的实现。</p>

<p>1 它会调用alloc_skb_fclone来分配内存，这个函数就不详细分析了，我们只需要知道它会从slab里分配一块内存，而大小为size+max_header(上面的分析我们知道slect_size只计算数据段).</p>

<p>2 如果分配成功，则调用sk_wmem_schedule来判断我们所分配的skb的大小是否精确，是的话，就调整指针，然后返回。</p>

<p>3 否则调用tcp_enter_memory_pressure设置标志进入TCP memory pressure zone。然后再调用sk_stream_moderate_sndbuf调整sndbuf(缩小sndbuf)。</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
<span class='line-number'>16</span>
<span class='line-number'>17</span>
<span class='line-number'>18</span>
<span class='line-number'>19</span>
<span class='line-number'>20</span>
<span class='line-number'>21</span>
<span class='line-number'>22</span>
<span class='line-number'>23</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>struct sk_buff *sk_stream_alloc_skb(struct sock *sk, int size, gfp_t gfp)
</span><span class='line'>{
</span><span class='line'>&#9;struct sk_buff *skb;
</span><span class='line'>
</span><span class='line'>&#9;// 4字节对其
</span><span class='line'>&#9;size = ALIGN(size, 4);
</span><span class='line'>&#9;// 分配skb。
</span><span class='line'>&#9;skb = alloc_skb_fclone(size + sk-&gt;sk_prot-&gt;max_header, gfp);
</span><span class='line'>&#9;if (skb) {
</span><span class='line'>&#9;&#9;// 得到精确的大小。
</span><span class='line'>&#9;&#9;if (sk_wmem_schedule(sk, skb-&gt;truesize)) {
</span><span class='line'>&#9;&#9;&#9;// 返回skb。
</span><span class='line'>&#9;&#9;&#9;skb_reserve(skb, skb_tailroom(skb) - size);
</span><span class='line'>&#9;&#9;&#9;&#9;return skb;
</span><span class='line'>&#9;&#9;}
</span><span class='line'>&#9;&#9;__kfree_skb(skb);
</span><span class='line'>&#9;} else {
</span><span class='line'>&#9;&#9;// 否则设置全局标记进入pressure zone
</span><span class='line'>&#9;&#9;sk-&gt;sk_prot-&gt;enter_memory_pressure(sk);
</span><span class='line'>&#9;&#9;sk_stream_moderate_sndbuf(sk);
</span><span class='line'>&#9;}
</span><span class='line'>&#9;return NULL;
</span><span class='line'>}</span></code></pre></td></tr></table></div></figure>


<p>ok,现在就来看上面的几个函数的实现。先来看几个简单的。</p>

<p>首先是tcp_enter_memory_pressure,这个函数很简单，就是判断全局标记tcp_memory_pressure,然后设置这个标记。这个标记主要是用来通知其他模块调整的，比如窗口大小等等，详细的话自己搜索这个值，就知道了。</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>void tcp_enter_memory_pressure(struct sock *sk)
</span><span class='line'>{
</span><span class='line'>&#9;if (!tcp_memory_pressure) {
</span><span class='line'>&#9;&#9;NET_INC_STATS(sock_net(sk), LINUX_MIB_TCPMEMORYPRESSURES);
</span><span class='line'>&#9;&#9;// 设置压力标志。
</span><span class='line'>&#9;&#9;tcp_memory_pressure = 1;
</span><span class='line'>&#9;}
</span><span class='line'>}</span></code></pre></td></tr></table></div></figure>


<p>然后是sk_stream_moderate_sndbuf，这个函数也是要使用sk_userlocks,来判断是否已经被用户设置了。可以看到如果我们自己设置过了snd_buf的话，内核就不会帮我们调整它的大小了。</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>static inline void sk_stream_moderate_sndbuf(struct sock *sk)
</span><span class='line'>{
</span><span class='line'>&#9;if (!(sk-&gt;sk_userlocks & SOCK_SNDBUF_LOCK)) {
</span><span class='line'>&#9;&#9;// 它的大小调整为大于最小值，小于sk-&gt;sk_wmem_queued &gt;&gt; 1。
</span><span class='line'>&#9;&#9;sk-&gt;sk_sndbuf = min(sk-&gt;sk_sndbuf, sk-&gt;sk_wmem_queued &gt;&gt; 1);
</span><span class='line'>&#9;&#9;sk-&gt;sk_sndbuf = max(sk-&gt;sk_sndbuf, SOCK_MIN_SNDBUF);
</span><span class='line'>&#9;}
</span><span class='line'>}</span></code></pre></td></tr></table></div></figure>


<h4>sk_wmem_schedule</h4>

<p>最后来看最核心的一个函数sk_wmem_schedule，这个函数只是对<code>__sk_mem_schedule</code>的简单封装。这里要知道传递进来的size是skb->truesize，也就是所分配的skb的真实大小。并且第一次进入这个函数，也就是分配第一个缓冲区包时，sk_forward_alloc是为0的，也就是说，第一次必然会执行<code>__sk_mem_schedule</code>函数。</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>static inline int sk_wmem_schedule(struct sock *sk, int size)
</span><span class='line'>{
</span><span class='line'>&#9;if (!sk_has_account(sk))
</span><span class='line'>&#9;&#9;return 1;
</span><span class='line'>&#9;// 先比较size(也就是skb-&gt;truesize)和预分配的内存大小。如果小于等于预分配的大小，则直接返回，否则调用__sk_mem_schedule进行调整。
</span><span class='line'>&#9;return size &lt;= sk-&gt;sk_forward_alloc ||
</span><span class='line'>&#9;&#9;__sk_mem_schedule(sk, size, SK_MEM_SEND);
</span><span class='line'>}</span></code></pre></td></tr></table></div></figure>


<p>来看<code>__sk_mem_schedule</code>，这个函数的功能注释写的很清楚：</p>

<p>increase sk_forward_alloc and memory_allocated</p>

<p>然后来看源码。这里在看之前，我们要知道，协议栈通过读写buf的使用量，划分了3个区域，或者说标志。不同标志进行不同处理。这里的区域的划分是通过sysctl_tcp_mem，也就是prot->sysctl_mem这个数组进行的。</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
<span class='line-number'>16</span>
<span class='line-number'>17</span>
<span class='line-number'>18</span>
<span class='line-number'>19</span>
<span class='line-number'>20</span>
<span class='line-number'>21</span>
<span class='line-number'>22</span>
<span class='line-number'>23</span>
<span class='line-number'>24</span>
<span class='line-number'>25</span>
<span class='line-number'>26</span>
<span class='line-number'>27</span>
<span class='line-number'>28</span>
<span class='line-number'>29</span>
<span class='line-number'>30</span>
<span class='line-number'>31</span>
<span class='line-number'>32</span>
<span class='line-number'>33</span>
<span class='line-number'>34</span>
<span class='line-number'>35</span>
<span class='line-number'>36</span>
<span class='line-number'>37</span>
<span class='line-number'>38</span>
<span class='line-number'>39</span>
<span class='line-number'>40</span>
<span class='line-number'>41</span>
<span class='line-number'>42</span>
<span class='line-number'>43</span>
<span class='line-number'>44</span>
<span class='line-number'>45</span>
<span class='line-number'>46</span>
<span class='line-number'>47</span>
<span class='line-number'>48</span>
<span class='line-number'>49</span>
<span class='line-number'>50</span>
<span class='line-number'>51</span>
<span class='line-number'>52</span>
<span class='line-number'>53</span>
<span class='line-number'>54</span>
<span class='line-number'>55</span>
<span class='line-number'>56</span>
<span class='line-number'>57</span>
<span class='line-number'>58</span>
<span class='line-number'>59</span>
<span class='line-number'>60</span>
<span class='line-number'>61</span>
<span class='line-number'>62</span>
<span class='line-number'>63</span>
<span class='line-number'>64</span>
<span class='line-number'>65</span>
<span class='line-number'>66</span>
<span class='line-number'>67</span>
<span class='line-number'>68</span>
<span class='line-number'>69</span>
<span class='line-number'>70</span>
<span class='line-number'>71</span>
<span class='line-number'>72</span>
<span class='line-number'>73</span>
<span class='line-number'>74</span>
<span class='line-number'>75</span>
<span class='line-number'>76</span>
<span class='line-number'>77</span>
<span class='line-number'>78</span>
<span class='line-number'>79</span>
<span class='line-number'>80</span>
<span class='line-number'>81</span>
<span class='line-number'>82</span>
<span class='line-number'>83</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>// 页的大小
</span><span class='line'>#define SK_MEM_QUANTUM ((int)PAGE_SIZE)
</span><span class='line'>
</span><span class='line'>int __sk_mem_schedule(struct sock *sk, int size, int kind)
</span><span class='line'>{
</span><span class='line'>&#9;struct proto *prot = sk-&gt;sk_prot;
</span><span class='line'>&#9;// 首先得到size占用几个内存页。
</span><span class='line'>&#9;int amt = sk_mem_pages(size);
</span><span class='line'>&#9;int allocated;
</span><span class='line'>&#9;// 更新sk_forward_alloc，可以看到这个值是页的大小的倍数。
</span><span class='line'>&#9;sk-&gt;sk_forward_alloc += amt * SK_MEM_QUANTUM;
</span><span class='line'>
</span><span class='line'>&#9;// amt+memory_allocated也就是当前的总得内存使用量加上将要分配的内存的话，现在的tcp协议栈的总得内存使用量。（可以看到是以页为单位的。
</span><span class='line'>&#9;allocated = atomic_add_return(amt, prot-&gt;memory_allocated);
</span><span class='line'>
</span><span class='line'>&#9;// 然后开始判断，将会落入哪一个区域。通过上面的分析我们知道sysctl_mem也就是sysctl_tcp_mem.
</span><span class='line'>
</span><span class='line'>&#9;// 先判断是否小于等于内存最小使用限额。
</span><span class='line'>&#9;if (allocated &lt;= prot-&gt;sysctl_mem[0]) {
</span><span class='line'>&#9;&#9;// 这里取消memory_pressure，然后返回。
</span><span class='line'>&#9;&#9;if (prot-&gt;memory_pressure && *prot-&gt;memory_pressure)
</span><span class='line'>&#9;&#9;&#9;*prot-&gt;memory_pressure = 0;
</span><span class='line'>&#9;&#9;return 1;
</span><span class='line'>&#9;}
</span><span class='line'>
</span><span class='line'>&#9;// 然后判断Under pressure。
</span><span class='line'>&#9;if (allocated &gt; prot-&gt;sysctl_mem[1])
</span><span class='line'>&#9;&#9;// 大于sysctl_mem[1]说明，已经进入pressure，一次你需要调用tcp_enter_memory_pressure来设置标志。
</span><span class='line'>&#9;&#9;if (prot-&gt;enter_memory_pressure)
</span><span class='line'>&#9;&#9;&#9;prot-&gt;enter_memory_pressure(sk);
</span><span class='line'>
</span><span class='line'>&#9;// 如果超过的hard limit。则进入另外的处理。
</span><span class='line'>&#9;if (allocated &gt; prot-&gt;sysctl_mem[2])
</span><span class='line'>&#9;&#9;goto suppress_allocation;
</span><span class='line'>
</span><span class='line'>&#9;// 判断类型，这里只有两种类型，读和写。总的内存大小判断完，这里开始判断单独的sock的读写内存。
</span><span class='line'>&#9;if (kind == SK_MEM_RECV) {
</span><span class='line'>&#9;&#9;if (atomic_read(&sk-&gt;sk_rmem_alloc) &lt; prot-&gt;sysctl_rmem[0])
</span><span class='line'>&#9;&#9;&#9;return 1;
</span><span class='line'>&#9;} else { /* SK_MEM_SEND */
</span><span class='line'>&#9;&#9;// 这里当为tcp的时候，写队列的大小只有当对端数据确认后才会更新，因此我们要用sk_wmem_queued来判断。
</span><span class='line'>&#9;&#9;if (sk-&gt;sk_type == SOCK_STREAM) {
</span><span class='line'>&#9;&#9;&#9;if (sk-&gt;sk_wmem_queued &lt; prot-&gt;sysctl_wmem[0])
</span><span class='line'>&#9;&#9;&#9;&#9;return 1;
</span><span class='line'>&#9;&#9;} else if (atomic_read(&sk-&gt;sk_wmem_alloc) &lt;
</span><span class='line'>&#9;&#9;&#9;   prot-&gt;sysctl_wmem[0])
</span><span class='line'>&#9;&#9;&#9;&#9;return 1;
</span><span class='line'>&#9;}
</span><span class='line'>
</span><span class='line'>&#9;// 程序到达这里说明总的内存大小在sysctl_mem[0]和sysctl_mem[2]之间，因此我们再次判断memory_pressure
</span><span class='line'>&#9;if (prot-&gt;memory_pressure) {
</span><span class='line'>&#9;&#9;int alloc;
</span><span class='line'>
</span><span class='line'>&#9;&#9;// 如果没有在memory_pressure区域，则我们直接返回1。
</span><span class='line'>&#9;&#9;if (!*prot-&gt;memory_pressure)
</span><span class='line'>&#9;&#9;&#9;return 1;
</span><span class='line'>&#9;&#9;// 这个其实也就是计算整个系统分配的socket的多少。
</span><span class='line'>&#9;&#9;alloc = percpu_counter_read_positive(prot-&gt;sockets_allocated);
</span><span class='line'>&#9;&#9;// 这里假设其余的每个sock所占用的buf都和当前的sock一样大的时候，如果他们的总和小于sysctl_mem[2],也就是hard limit。那么我们也认为这次内存请求是成功的。
</span><span class='line'>&#9;&#9;if (prot-&gt;sysctl_mem[2] &gt; alloc *
</span><span class='line'>&#9;&#9;&#9;sk_mem_pages(sk-&gt;sk_wmem_queued +
</span><span class='line'>&#9;&#9;&#9; atomic_read(&sk-&gt;sk_rmem_alloc) +
</span><span class='line'>&#9;&#9;&#9;&#9; sk-&gt;sk_forward_alloc))
</span><span class='line'>&#9;&#9;&#9;return 1;
</span><span class='line'>&#9;}
</span><span class='line'>
</span><span class='line'>suppress_allocation:
</span><span class='line'>
</span><span class='line'>&#9;// 到达这里说明，我们超过了hard limit或者说处于presure 区域。
</span><span class='line'>&#9;if (kind == SK_MEM_SEND && sk-&gt;sk_type == SOCK_STREAM) {
</span><span class='line'>&#9;&#9;// 调整sk_sndbuf(减小).这个函数前面已经分析过了。
</span><span class='line'>&#9;&#9;sk_stream_moderate_sndbuf(sk);
</span><span class='line'>&#9;&#9;// 然后比较和sk_sndbuf的大小，如果大于的话，就说明下次我们再次要分配buf的时候会在tcp_memory_free阻塞住，因此这次我们返回1.
</span><span class='line'>&#9;&#9;if (sk-&gt;sk_wmem_queued + size &gt;= sk-&gt;sk_sndbuf)
</span><span class='line'>&#9;&#9;&#9;return 1;
</span><span class='line'>&#9;}
</span><span class='line'>
</span><span class='line'>&#9;/* Alas. Undo changes. */
</span><span class='line'>&#9;// 到达这里说明，请求内存是不被接受的，因此undo所有的操作。然后返回0.
</span><span class='line'>&#9;sk-&gt;sk_forward_alloc -= amt * SK_MEM_QUANTUM;
</span><span class='line'>&#9;atomic_sub(amt, prot-&gt;memory_allocated);
</span><span class='line'>&#9;return 0;
</span><span class='line'>}</span></code></pre></td></tr></table></div></figure>


<p>接下来来看个很重要的函数skb_set_owner_w。</p>

<p>顾名思义，这个函数也就是将一个skb和scok关联起来。只不过关联的时候更新sock相应的域。我们来看源码：</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>static inline void skb_set_owner_w(struct sk_buff *skb, struct sock *sk)
</span><span class='line'>{
</span><span class='line'>&#9;skb_orphan(skb);
</span><span class='line'>&#9;// 与传递进来的sock关联起来
</span><span class='line'>&#9;skb-&gt;sk = sk;
</span><span class='line'>&#9;// 设置skb的析构函数
</span><span class='line'>&#9;skb-&gt;destructor = sock_wfree;
</span><span class='line'>&#9;// 更新sk_wmem_alloc域，就是sk_wmem_alloc+truesize.
</span><span class='line'>&#9;atomic_add(skb-&gt;truesize, &sk-&gt;sk_wmem_alloc);
</span><span class='line'>}</span></code></pre></td></tr></table></div></figure>


<p>ok，接下来来看个scok_wfree函数，这个函数做得基本和上面函数相反。这个函数都是被kfree_skb自动调用的。</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>void sock_wfree(struct sk_buff *skb)
</span><span class='line'>{
</span><span class='line'>&#9;struct sock *sk = skb-&gt;sk;
</span><span class='line'>&#9;int res;
</span><span class='line'>
</span><span class='line'>&#9;// 更新sk_wmem_alloc,减去skb的大小。
</span><span class='line'>&#9;res = atomic_sub_return(skb-&gt;truesize, &sk-&gt;sk_wmem_alloc);
</span><span class='line'>&#9;if (!sock_flag(sk, SOCK_USE_WRITE_QUEUE))
</span><span class='line'>&#9;// 唤醒等待队列，也就是唤醒等待内存分配。
</span><span class='line'>&#9;&#9;sk-&gt;sk_write_space(sk);
</span><span class='line'>&#9;if (res == 0)
</span><span class='line'>&#9;&#9;__sk_free(sk);
</span><span class='line'>}</span></code></pre></td></tr></table></div></figure>


<p>而skb_set_owner_w是什么时候被调用呢，我们通过搜索代码可以看到，它是在tcp_transmit_skb中被调用的。而tcp_transmit_skb我们知道是传递数据包到ip层的函数。</p>

<p>而kfree_skb被调用也就是在对端已经确认完我们发送的包后才会被调用来释放skb。</p>

<h4>tcp_rcv_established</h4>

<p>接下来来看接收数据的内存管理。我们主要来看tcp_rcv_established这个函数，我前面的blog已经断断续续的分析过了，因此这里我们只看一些重要的代码片断。</p>

<p>这里我们要知道，代码能到达下面的位置，则说明，数据并没有直接拷贝到用户空间。否则的话，是不会进入下面的片断的。</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
<span class='line-number'>16</span>
<span class='line-number'>17</span>
<span class='line-number'>18</span>
<span class='line-number'>19</span>
<span class='line-number'>20</span>
<span class='line-number'>21</span>
<span class='line-number'>22</span>
<span class='line-number'>23</span>
<span class='line-number'>24</span>
<span class='line-number'>25</span>
<span class='line-number'>26</span>
<span class='line-number'>27</span>
<span class='line-number'>28</span>
<span class='line-number'>29</span>
<span class='line-number'>30</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>if (!eaten) {
</span><span class='line'>&#9;..........................................
</span><span class='line'>
</span><span class='line'>&#9;// 如果skb的大小大于预分配的值,如果大于则要另外处理。
</span><span class='line'>&#9;if ((int)skb-&gt;truesize &gt; sk-&gt;sk_forward_alloc)
</span><span class='line'>&#9;&#9;&#9;goto step5;
</span><span class='line'>&#9;__skb_pull(skb, tcp_header_len);
</span><span class='line'>&#9;__skb_queue_tail(&sk-&gt;sk_receive_queue, skb);
</span><span class='line'>&#9;// 这里关联skb和对应的sk，并且更新相关的域，我们下面会分析这个函数。
</span><span class='line'>&#9;skb_set_owner_r(skb, sk);
</span><span class='line'>&#9;tp-&gt;rcv_nxt = TCP_SKB_CB(skb)-&gt;end_seq;
</span><span class='line'>}
</span><span class='line'>...............................................
</span><span class='line'>
</span><span class='line'>step5:
</span><span class='line'>&#9;if (th-&gt;ack && tcp_ack(sk, skb, FLAG_SLOWPATH) &lt; 0)
</span><span class='line'>&#9;&#9;goto discard;
</span><span class='line'>
</span><span class='line'>&#9;tcp_rcv_rtt_measure_ts(sk, skb);
</span><span class='line'>
</span><span class='line'>&#9;/* Process urgent data. */
</span><span class='line'>&#9;tcp_urg(sk, skb, th);
</span><span class='line'>
</span><span class='line'>&#9;/* step 7: process the segment text */
</span><span class='line'>&#9;// 最核心的函数就是这个。我们接下来会详细分析这个函数。
</span><span class='line'>&#9;tcp_data_queue(sk, skb);
</span><span class='line'>
</span><span class='line'>&#9;tcp_data_snd_check(sk);
</span><span class='line'>&#9;tcp_ack_snd_check(sk);
</span><span class='line'>&#9;return 0;</span></code></pre></td></tr></table></div></figure>


<p>先来看skb_set_owner_r函数，这个函数关联skb和sk其实它和skb_set_owner_w类似：</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>static inline void skb_set_owner_r(struct sk_buff *skb, struct sock *sk)
</span><span class='line'>{
</span><span class='line'>&#9;skb_orphan(skb);
</span><span class='line'>&#9;// 关联sk
</span><span class='line'>&#9;skb-&gt;sk = sk;
</span><span class='line'>&#9;// 设置析构函数
</span><span class='line'>&#9;skb-&gt;destructor = sock_rfree;
</span><span class='line'>&#9;// 更新rmem_alloc
</span><span class='line'>&#9;atomic_add(skb-&gt;truesize, &sk-&gt;sk_rmem_alloc);
</span><span class='line'>&#9;// 改变forward_alloc.
</span><span class='line'>&#9;sk_mem_charge(sk, skb-&gt;truesize);
</span><span class='line'>}</span></code></pre></td></tr></table></div></figure>


<h4>tcp_data_queue</h4>

<p>然后是tcp_data_queue，这个函数主要用来排队接收数据，并update相关的读buf。由于这个函数比较复杂，我们只关心我们感兴趣的部分：</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
<span class='line-number'>16</span>
<span class='line-number'>17</span>
<span class='line-number'>18</span>
<span class='line-number'>19</span>
<span class='line-number'>20</span>
<span class='line-number'>21</span>
<span class='line-number'>22</span>
<span class='line-number'>23</span>
<span class='line-number'>24</span>
<span class='line-number'>25</span>
<span class='line-number'>26</span>
<span class='line-number'>27</span>
<span class='line-number'>28</span>
<span class='line-number'>29</span>
<span class='line-number'>30</span>
<span class='line-number'>31</span>
<span class='line-number'>32</span>
<span class='line-number'>33</span>
<span class='line-number'>34</span>
<span class='line-number'>35</span>
<span class='line-number'>36</span>
<span class='line-number'>37</span>
<span class='line-number'>38</span>
<span class='line-number'>39</span>
<span class='line-number'>40</span>
<span class='line-number'>41</span>
<span class='line-number'>42</span>
<span class='line-number'>43</span>
<span class='line-number'>44</span>
<span class='line-number'>45</span>
<span class='line-number'>46</span>
<span class='line-number'>47</span>
<span class='line-number'>48</span>
<span class='line-number'>49</span>
<span class='line-number'>50</span>
<span class='line-number'>51</span>
<span class='line-number'>52</span>
<span class='line-number'>53</span>
<span class='line-number'>54</span>
<span class='line-number'>55</span>
<span class='line-number'>56</span>
<span class='line-number'>57</span>
<span class='line-number'>58</span>
<span class='line-number'>59</span>
<span class='line-number'>60</span>
<span class='line-number'>61</span>
<span class='line-number'>62</span>
<span class='line-number'>63</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>static void tcp_data_queue(struct sock *sk, struct sk_buff *skb)
</span><span class='line'>{
</span><span class='line'>&#9;struct tcphdr *th = tcp_hdr(skb);
</span><span class='line'>&#9;struct tcp_sock *tp = tcp_sk(sk);
</span><span class='line'>&#9;int eaten = -1;
</span><span class='line'>&#9;.......................................
</span><span class='line'>&#9;// 首先判断skb的开始序列号和我们想要接收的序列号。如果相等开始处理这个数据包(也就是拷贝到用户空间).
</span><span class='line'>&#9;if (TCP_SKB_CB(skb)-&gt;seq == tp-&gt;rcv_nxt) {
</span><span class='line'>&#9;&#9;if (tcp_receive_window(tp) == 0)
</span><span class='line'>&#9;&#9;&#9;goto out_of_window;
</span><span class='line'>
</span><span class='line'>&#9;&#9;// tp的ucopy我前面的blog已经详细分析过了。这里就不解释了。
</span><span class='line'>&#9;&#9;if (tp-&gt;ucopy.task == current &&
</span><span class='line'>&#9;&#9;&#9;tp-&gt;copied_seq == tp-&gt;rcv_nxt && tp-&gt;ucopy.len &&sock_owned_by_user(sk) && !tp-&gt;urg_data)
</span><span class='line'>&#9;&#9;{
</span><span class='line'>&#9;&#9;&#9;// 计算将要拷贝给用户空间的大小。
</span><span class='line'>&#9;&#9;&#9;int chunk = min_t(unsigned int, skb-&gt;len,tp-&gt;ucopy.len);
</span><span class='line'>
</span><span class='line'>&#9;&#9;&#9;// 设置状态，说明我们处于进程上下文。
</span><span class='line'>&#9;&#9;&#9;__set_current_state(TASK_RUNNING);
</span><span class='line'>
</span><span class='line'>&#9;&#9;&#9;local_bh_enable();
</span><span class='line'>&#9;&#9;&#9;// 拷贝skb
</span><span class='line'>&#9;&#9;&#9;if (!skb_copy_datagram_iovec(skb, 0, tp-&gt;ucopy.iov, chunk)) {
</span><span class='line'>&#9;&#9;&#9;&#9;tp-&gt;ucopy.len -= chunk;
</span><span class='line'>&#9;&#9;&#9;&#9;tp-&gt;copied_seq += chunk;
</span><span class='line'>&#9;&#9;&#9;&#9;// 更新eaten，它的默认值为-1.
</span><span class='line'>&#9;&#9;&#9;&#9;eaten = (chunk == skb-&gt;len && !th-&gt;fin);
</span><span class='line'>&#9;&#9;&#9;&#9;tcp_rcv_space_adjust(sk);
</span><span class='line'>&#9;&#9;&#9;}
</span><span class='line'>&#9;&#9;&#9;local_bh_disable();
</span><span class='line'>&#9;&#9;}
</span><span class='line'>
</span><span class='line'>&#9;&#9;// 如果小于0则说明没有拷贝成功，或者说就没有进行拷贝。此时需要更新sock的相关域。
</span><span class='line'>&#9;&#9;if (eaten &lt;= 0) {
</span><span class='line'>queue_and_out:
</span><span class='line'>&#9;&#9;&#9;// 最关键的tcp_try_rmem_schedule函数。接下来会详细分析。
</span><span class='line'>&#9;&#9;&#9;if (eaten &lt; 0 &&
</span><span class='line'>&#9;&#9;          tcp_try_rmem_schedule(sk, skb-&gt;truesize))
</span><span class='line'>&#9;&#9;&#9;&#9;goto drop;
</span><span class='line'>
</span><span class='line'>&#9;&#9;&#9;// 关联skb和sk。到达这里说明tcp_try_rmem_schedule成功，也就是返回0.
</span><span class='line'>&#9;&#9;&#9;skb_set_owner_r(skb, sk);
</span><span class='line'>&#9;&#9;&#9;// 加skb到receive_queue.
</span><span class='line'>&#9;&#9;&#9;__skb_queue_tail(&sk-&gt;sk_receive_queue, skb);
</span><span class='line'>&#9;&#9;}
</span><span class='line'>&#9;&#9;// 更新期待序列号。
</span><span class='line'>&#9;&#9;tp-&gt;rcv_nxt = TCP_SKB_CB(skb)-&gt;end_seq;
</span><span class='line'>&#9;&#9;..............................................
</span><span class='line'>
</span><span class='line'>&#9;&#9;.....................................
</span><span class='line'>
</span><span class='line'>&#9;&#9;tcp_fast_path_check(sk);
</span><span class='line'>
</span><span class='line'>&#9;&#9;if (eaten &gt; 0)
</span><span class='line'>&#9;&#9;&#9;__kfree_skb(skb);
</span><span class='line'>&#9;&#9;else if (!sock_flag(sk, SOCK_DEAD))
</span><span class='line'>&#9;&#9;&#9;sk-&gt;sk_data_ready(sk, 0);
</span><span class='line'>&#9;&#9;return;
</span><span class='line'>&#9;}
</span><span class='line'>&#9;// 下面就是处理乱序包。以后会详细分析。
</span><span class='line'>&#9;......................................
</span><span class='line'>}</span></code></pre></td></tr></table></div></figure>


<h4>tcp_try_rmem_schedule</h4>

<p>接下来我们就来看tcp_try_rmem_schedule这个函数,这个函数如果返回0则说明sk_rmem_schedule返回1,而sk_rmem_schedule和sk_wmem_schedule是一样的。也就是看当前的skb加入后有没有超过读buf的限制。并更新相关的域。：</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
<span class='line-number'>16</span>
<span class='line-number'>17</span>
<span class='line-number'>18</span>
<span class='line-number'>19</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>static inline int tcp_try_rmem_schedule(struct sock *sk, unsigned int size)
</span><span class='line'>{
</span><span class='line'>&#9;// 首先判断rmem_alloc(当前的读buf字节数)是否大于最大buf字节数，如果大于则调用tcp_prune_queue调整分配的buf。否则调用sk_rmem_schedule来调整相关域（sk_forward_alloc）。
</span><span class='line'>&#9;if (atomic_read(&sk-&gt;sk_rmem_alloc) &gt; sk-&gt;sk_rcvbuf ||!sk_rmem_schedule(sk, size)) {
</span><span class='line'>
</span><span class='line'>&#9;&#9;// 调整分配的buf。
</span><span class='line'>&#9;&#9;if (tcp_prune_queue(sk) &lt; 0)
</span><span class='line'>&#9;&#9;&#9;return -1;
</span><span class='line'>&#9;&#9;// 更新sk的相关域。
</span><span class='line'>&#9;&#9;if (!sk_rmem_schedule(sk, size)) {
</span><span class='line'>&#9;&#9;&#9;if (!tcp_prune_ofo_queue(sk))
</span><span class='line'>&#9;&#9;&#9;&#9;return -1;
</span><span class='line'>
</span><span class='line'>&#9;&#9;&#9;if (!sk_rmem_schedule(sk, size))
</span><span class='line'>&#9;&#9;&#9;&#9;return -1;
</span><span class='line'>&#9;&#9;}
</span><span class='line'>&#9;}
</span><span class='line'>&#9;return 0;
</span><span class='line'>}</span></code></pre></td></tr></table></div></figure>


<p>来看sk_rmem_schedule，这个函数很简单，就是封装了<code>__sk_mem_schedule</code>。而这个函数我们上面已经分析过了。</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>static inline int sk_rmem_schedule(struct sock *sk, int size)
</span><span class='line'>{
</span><span class='line'>&#9;if (!sk_has_account(sk))
</span><span class='line'>&#9;&#9;return 1;
</span><span class='line'>&#9;return size &lt;= sk-&gt;sk_forward_alloc ||
</span><span class='line'>&#9;&#9;__sk_mem_schedule(sk, size, SK_MEM_RECV);
</span><span class='line'>}</span></code></pre></td></tr></table></div></figure>


<h4>tcp_prune_queue</h4>

<p>最后是tcp_prune_queue，这个函数主要是用来丢掉一些skb，因为到这个函数就说明我们的内存使用已经到极限了，因此我们要合并一些buf。这个合并也就是将序列号连续的段进行合并。</p>

<p>这里我们要知道tcp的包是有序的，因此内核中tcp专门有一个队列来保存那些Out of order segments。因此我们这里会先处理这个队列里面的skb。</p>

<p>然后调用tcp_collapse来处理接收队列里面的skb。和上面的类似。</p>

<p>这里要注意，合并的话都是按页来合并，也就是先分配一页大小的内存，然后将老的skb复制进去，最后free掉老的buf。</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
<span class='line-number'>16</span>
<span class='line-number'>17</span>
<span class='line-number'>18</span>
<span class='line-number'>19</span>
<span class='line-number'>20</span>
<span class='line-number'>21</span>
<span class='line-number'>22</span>
<span class='line-number'>23</span>
<span class='line-number'>24</span>
<span class='line-number'>25</span>
<span class='line-number'>26</span>
<span class='line-number'>27</span>
<span class='line-number'>28</span>
<span class='line-number'>29</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>static int tcp_prune_queue(struct sock *sk)
</span><span class='line'>{
</span><span class='line'>&#9;struct tcp_sock *tp = tcp_sk(sk);
</span><span class='line'>&#9;..................................
</span><span class='line'>&#9;// 如果rmem_alloc过于大，则重新计算窗口的大小。一半都会缩小窗口。
</span><span class='line'>&#9;if (atomic_read(&sk-&gt;sk_rmem_alloc) &gt;= sk-&gt;sk_rcvbuf)
</span><span class='line'>&#9;&#9;tcp_clamp_window(sk);
</span><span class='line'>&#9;// 如果处于pressure区域，则调整窗口大小。这里也是缩小窗口。
</span><span class='line'>&#9;else if (tcp_memory_pressure)
</span><span class='line'>&#9;&#9;tp-&gt;rcv_ssthresh = min(tp-&gt;rcv_ssthresh, 4U * tp-&gt;advmss);
</span><span class='line'>
</span><span class='line'>&#9;// 处理ofo队列。
</span><span class='line'>&#9;tcp_collapse_ofo_queue(sk);
</span><span class='line'>&#9;// 如果接收队列为非空，则调用tcp_collapse来处理sk_receive_queue
</span><span class='line'>&#9;if (!skb_queue_empty(&sk-&gt;sk_receive_queue))
</span><span class='line'>&#9;&#9;tcp_collapse(sk, &sk-&gt;sk_receive_queue,
</span><span class='line'>&#9;&#9;&#9;&#9; skb_peek(&sk-&gt;sk_receive_queue),
</span><span class='line'>&#9;&#9;&#9;&#9; NULL,
</span><span class='line'>&#9;&#9;&#9;&#9; tp-&gt;copied_seq, tp-&gt;rcv_nxt);
</span><span class='line'>&#9;// 更新全局的已分配内存的大小，也就是memory_allocated，接下来会详细介绍这个函数。
</span><span class='line'>&#9;sk_mem_reclaim(sk);
</span><span class='line'>
</span><span class='line'>&#9;// 如果调整后小于sk_rcvbuf,则返回0.
</span><span class='line'>&#9;if (atomic_read(&sk-&gt;sk_rmem_alloc) &lt;= sk-&gt;sk_rcvbuf)
</span><span class='line'>&#9;&#9;return 0;
</span><span class='line'>
</span><span class='line'>&#9;......................................
</span><span class='line'>&#9;return -1;
</span><span class='line'>}</span></code></pre></td></tr></table></div></figure>


<h4>tcp_collapse_ofo_queue 尝试减小ofo queue占内存的大小</h4>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
<span class='line-number'>16</span>
<span class='line-number'>17</span>
<span class='line-number'>18</span>
<span class='line-number'>19</span>
<span class='line-number'>20</span>
<span class='line-number'>21</span>
<span class='line-number'>22</span>
<span class='line-number'>23</span>
<span class='line-number'>24</span>
<span class='line-number'>25</span>
<span class='line-number'>26</span>
<span class='line-number'>27</span>
<span class='line-number'>28</span>
<span class='line-number'>29</span>
<span class='line-number'>30</span>
<span class='line-number'>31</span>
<span class='line-number'>32</span>
<span class='line-number'>33</span>
<span class='line-number'>34</span>
<span class='line-number'>35</span>
<span class='line-number'>36</span>
<span class='line-number'>37</span>
<span class='line-number'>38</span>
<span class='line-number'>39</span>
<span class='line-number'>40</span>
<span class='line-number'>41</span>
<span class='line-number'>42</span>
<span class='line-number'>43</span>
<span class='line-number'>44</span>
<span class='line-number'>45</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>/* Collapse ofo queue. Algorithm: select contiguous sequence of skbs
</span><span class='line'> * and tcp_collapse() them until all the queue is collapsed.
</span><span class='line'> */
</span><span class='line'>static void tcp_collapse_ofo_queue(struct sock *sk)
</span><span class='line'>{
</span><span class='line'>&#9;struct tcp_sock *tp = tcp_sk(sk);
</span><span class='line'>&#9;struct sk_buff *skb = skb_peek(&tp-&gt;out_of_order_queue);
</span><span class='line'>&#9;struct sk_buff *head;
</span><span class='line'>&#9;u32 start, end;
</span><span class='line'>
</span><span class='line'>&#9;if (skb == NULL)
</span><span class='line'>&#9;&#9;return;
</span><span class='line'>
</span><span class='line'>&#9;start = TCP_SKB_CB(skb)-&gt;seq;
</span><span class='line'>&#9;end = TCP_SKB_CB(skb)-&gt;end_seq;
</span><span class='line'>&#9;head = skb;
</span><span class='line'>
</span><span class='line'>&#9;for (;;) {
</span><span class='line'>&#9;&#9;struct sk_buff *next = NULL;
</span><span class='line'>
</span><span class='line'>&#9;&#9;if (!skb_queue_is_last(&tp-&gt;out_of_order_queue, skb))
</span><span class='line'>&#9;&#9;&#9;next = skb_queue_next(&tp-&gt;out_of_order_queue, skb);
</span><span class='line'>&#9;&#9;skb = next;
</span><span class='line'>
</span><span class='line'>&#9;&#9;/* Segment is terminated when we see gap or when
</span><span class='line'>&#9;&#9; * we are at the end of all the queue. */
</span><span class='line'>&#9;&#9;if (!skb ||
</span><span class='line'>&#9;&#9;&#9;after(TCP_SKB_CB(skb)-&gt;seq, end) ||
</span><span class='line'>&#9;&#9;&#9;before(TCP_SKB_CB(skb)-&gt;end_seq, start)) {  // 找到ofo queue中连续的一段skb，即 prev-&gt;end_seq &gt;= next-&gt;seq
</span><span class='line'>&#9;&#9;&#9;tcp_collapse(sk, &tp-&gt;out_of_order_queue,
</span><span class='line'>&#9;&#9;&#9;&#9;&#9; head, skb, start, end);            // 尝试减小这一段连续skb占用的内存
</span><span class='line'>&#9;&#9;&#9;head = skb;
</span><span class='line'>&#9;&#9;&#9;if (!skb)
</span><span class='line'>&#9;&#9;&#9;&#9;break;
</span><span class='line'>&#9;&#9;&#9;/* Start new segment */
</span><span class='line'>&#9;&#9;&#9;start = TCP_SKB_CB(skb)-&gt;seq;               // 下个skb就是新的一段的开始
</span><span class='line'>&#9;&#9;&#9;end = TCP_SKB_CB(skb)-&gt;end_seq;
</span><span class='line'>&#9;&#9;} else {
</span><span class='line'>&#9;&#9;&#9;if (before(TCP_SKB_CB(skb)-&gt;seq, start))    // 这种情况只可能是tcp_collapse中大包拆成小包，拆到一半内存不够，没拆完导致。
</span><span class='line'>&#9;&#9;&#9;&#9;start = TCP_SKB_CB(skb)-&gt;seq;
</span><span class='line'>&#9;&#9;&#9;if (after(TCP_SKB_CB(skb)-&gt;end_seq, end))
</span><span class='line'>&#9;&#9;&#9;&#9;end = TCP_SKB_CB(skb)-&gt;end_seq;
</span><span class='line'>&#9;&#9;}
</span><span class='line'>&#9;}
</span><span class='line'>}</span></code></pre></td></tr></table></div></figure>


<h4>tcp_collapse，gro上来的包有可能是大于4k的包，所以这个函数有时是在拆包，利弊难定</h4>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
<span class='line-number'>16</span>
<span class='line-number'>17</span>
<span class='line-number'>18</span>
<span class='line-number'>19</span>
<span class='line-number'>20</span>
<span class='line-number'>21</span>
<span class='line-number'>22</span>
<span class='line-number'>23</span>
<span class='line-number'>24</span>
<span class='line-number'>25</span>
<span class='line-number'>26</span>
<span class='line-number'>27</span>
<span class='line-number'>28</span>
<span class='line-number'>29</span>
<span class='line-number'>30</span>
<span class='line-number'>31</span>
<span class='line-number'>32</span>
<span class='line-number'>33</span>
<span class='line-number'>34</span>
<span class='line-number'>35</span>
<span class='line-number'>36</span>
<span class='line-number'>37</span>
<span class='line-number'>38</span>
<span class='line-number'>39</span>
<span class='line-number'>40</span>
<span class='line-number'>41</span>
<span class='line-number'>42</span>
<span class='line-number'>43</span>
<span class='line-number'>44</span>
<span class='line-number'>45</span>
<span class='line-number'>46</span>
<span class='line-number'>47</span>
<span class='line-number'>48</span>
<span class='line-number'>49</span>
<span class='line-number'>50</span>
<span class='line-number'>51</span>
<span class='line-number'>52</span>
<span class='line-number'>53</span>
<span class='line-number'>54</span>
<span class='line-number'>55</span>
<span class='line-number'>56</span>
<span class='line-number'>57</span>
<span class='line-number'>58</span>
<span class='line-number'>59</span>
<span class='line-number'>60</span>
<span class='line-number'>61</span>
<span class='line-number'>62</span>
<span class='line-number'>63</span>
<span class='line-number'>64</span>
<span class='line-number'>65</span>
<span class='line-number'>66</span>
<span class='line-number'>67</span>
<span class='line-number'>68</span>
<span class='line-number'>69</span>
<span class='line-number'>70</span>
<span class='line-number'>71</span>
<span class='line-number'>72</span>
<span class='line-number'>73</span>
<span class='line-number'>74</span>
<span class='line-number'>75</span>
<span class='line-number'>76</span>
<span class='line-number'>77</span>
<span class='line-number'>78</span>
<span class='line-number'>79</span>
<span class='line-number'>80</span>
<span class='line-number'>81</span>
<span class='line-number'>82</span>
<span class='line-number'>83</span>
<span class='line-number'>84</span>
<span class='line-number'>85</span>
<span class='line-number'>86</span>
<span class='line-number'>87</span>
<span class='line-number'>88</span>
<span class='line-number'>89</span>
<span class='line-number'>90</span>
<span class='line-number'>91</span>
<span class='line-number'>92</span>
<span class='line-number'>93</span>
<span class='line-number'>94</span>
<span class='line-number'>95</span>
<span class='line-number'>96</span>
<span class='line-number'>97</span>
<span class='line-number'>98</span>
<span class='line-number'>99</span>
<span class='line-number'>100</span>
<span class='line-number'>101</span>
<span class='line-number'>102</span>
<span class='line-number'>103</span>
<span class='line-number'>104</span>
<span class='line-number'>105</span>
<span class='line-number'>106</span>
<span class='line-number'>107</span>
<span class='line-number'>108</span>
<span class='line-number'>109</span>
<span class='line-number'>110</span>
<span class='line-number'>111</span>
<span class='line-number'>112</span>
<span class='line-number'>113</span>
<span class='line-number'>114</span>
<span class='line-number'>115</span>
<span class='line-number'>116</span>
<span class='line-number'>117</span>
<span class='line-number'>118</span>
<span class='line-number'>119</span>
<span class='line-number'>120</span>
<span class='line-number'>121</span>
<span class='line-number'>122</span>
<span class='line-number'>123</span>
<span class='line-number'>124</span>
<span class='line-number'>125</span>
<span class='line-number'>126</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>// 删除一个skb，返回下个skb
</span><span class='line'>static struct sk_buff *tcp_collapse_one(struct sock *sk, struct sk_buff *skb,
</span><span class='line'>&#9;&#9;&#9;&#9;&#9;struct sk_buff_head *list)
</span><span class='line'>{
</span><span class='line'>&#9;struct sk_buff *next = NULL;
</span><span class='line'>
</span><span class='line'>&#9;if (!skb_queue_is_last(list, skb))
</span><span class='line'>&#9;&#9;next = skb_queue_next(list, skb);
</span><span class='line'>
</span><span class='line'>&#9;__skb_unlink(skb, list);
</span><span class='line'>&#9;__kfree_skb(skb);
</span><span class='line'>&#9;NET_INC_STATS_BH(sock_net(sk), LINUX_MIB_TCPRCVCOLLAPSED);
</span><span class='line'>
</span><span class='line'>&#9;return next;
</span><span class='line'>}
</span><span class='line'>
</span><span class='line'>/* Collapse contiguous sequence of skbs head..tail with
</span><span class='line'> * sequence numbers start..end.
</span><span class='line'> *
</span><span class='line'> * If tail is NULL, this means until the end of the list.
</span><span class='line'> *
</span><span class='line'> * Segments with FIN/SYN are not collapsed (only because this
</span><span class='line'> * simplifies code)
</span><span class='line'> */
</span><span class='line'>static void
</span><span class='line'>tcp_collapse(struct sock *sk, struct sk_buff_head *list,
</span><span class='line'>&#9;&#9; struct sk_buff *head, struct sk_buff *tail,
</span><span class='line'>&#9;&#9; u32 start, u32 end)
</span><span class='line'>{
</span><span class='line'>&#9;struct sk_buff *skb, *n;
</span><span class='line'>&#9;bool end_of_skbs;
</span><span class='line'>
</span><span class='line'>&#9;/* First, check that queue is collapsible and find
</span><span class='line'>&#9; * the point where collapsing can be useful. */
</span><span class='line'>&#9;skb = head;
</span><span class='line'>restart:
</span><span class='line'>&#9;end_of_skbs = true;
</span><span class='line'>&#9;skb_queue_walk_from_safe(list, skb, n) {
</span><span class='line'>&#9;&#9;if (skb == tail)
</span><span class='line'>&#9;&#9;&#9;break;
</span><span class='line'>&#9;&#9;/* No new bits? It is possible on ofo queue. */
</span><span class='line'>&#9;&#9;if (!before(start, TCP_SKB_CB(skb)-&gt;end_seq)) { // 这种情况现在是不会出现的，以前代码有可能出现？？
</span><span class='line'>&#9;&#9;&#9;skb = tcp_collapse_one(sk, skb, list);
</span><span class='line'>&#9;&#9;&#9;if (!skb)
</span><span class='line'>&#9;&#9;&#9;&#9;break;
</span><span class='line'>&#9;&#9;&#9;goto restart;
</span><span class='line'>&#9;&#9;}
</span><span class='line'>
</span><span class='line'>&#9;&#9;/* The first skb to collapse is:
</span><span class='line'>&#9;&#9; * - not SYN/FIN and
</span><span class='line'>&#9;&#9; * - bloated or contains data before "start" or
</span><span class='line'>&#9;&#9; *   overlaps to the next one.
</span><span class='line'>&#9;&#9; */
</span><span class='line'>&#9;&#9;if (!tcp_hdr(skb)-&gt;syn && !tcp_hdr(skb)-&gt;fin &&         // SYN，FIN 不合并，简化操作
</span><span class='line'>&#9;&#9;&#9;(tcp_win_from_space(skb-&gt;truesize) &gt; skb-&gt;len ||    // 合并后可能减小空间的情况才合并
</span><span class='line'>&#9;&#9;&#9; before(TCP_SKB_CB(skb)-&gt;seq, start))) {            // seq到start的数据已经被读走了，有减小空间的可能
</span><span class='line'>&#9;&#9;&#9;end_of_skbs = false;
</span><span class='line'>&#9;&#9;&#9;break;
</span><span class='line'>&#9;&#9;}
</span><span class='line'>
</span><span class='line'>&#9;&#9;if (!skb_queue_is_last(list, skb)) {
</span><span class='line'>&#9;&#9;&#9;struct sk_buff *next = skb_queue_next(list, skb);
</span><span class='line'>&#9;&#9;&#9;if (next != tail &&
</span><span class='line'>&#9;&#9;&#9;&#9;TCP_SKB_CB(skb)-&gt;end_seq != TCP_SKB_CB(next)-&gt;seq) { // 两个skb之间有交集，有减小空间可能
</span><span class='line'>&#9;&#9;&#9;&#9;end_of_skbs = false;
</span><span class='line'>&#9;&#9;&#9;&#9;break;
</span><span class='line'>&#9;&#9;&#9;}
</span><span class='line'>&#9;&#9;}
</span><span class='line'>
</span><span class='line'>&#9;&#9;/* Decided to skip this, advance start seq. */
</span><span class='line'>&#9;&#9;start = TCP_SKB_CB(skb)-&gt;end_seq;     // 否则向后继续找可能减小空间的第一个skb
</span><span class='line'>&#9;}
</span><span class='line'>&#9;if (end_of_skbs || tcp_hdr(skb)-&gt;syn || tcp_hdr(skb)-&gt;fin)
</span><span class='line'>&#9;&#9;return;
</span><span class='line'>
</span><span class='line'>&#9;while (before(start, end)) {  // 落在在start到end的包就是这次要合并的
</span><span class='line'>&#9;&#9;struct sk_buff *nskb;
</span><span class='line'>&#9;&#9;unsigned int header = skb_headroom(skb); // skb中协议头的大小
</span><span class='line'>&#9;&#9;int copy = SKB_MAX_ORDER(header, 0);     // 一个页（4k）中出去协议头空间的大小，也就是能容下的数据大小
</span><span class='line'>
</span><span class='line'>&#9;&#9;/* Too big header? This can happen with IPv6. */
</span><span class='line'>&#9;&#9;if (copy &lt; 0)
</span><span class='line'>&#9;&#9;&#9;return;
</span><span class='line'>&#9;&#9;if (end - start &lt; copy)
</span><span class='line'>&#9;&#9;&#9;copy = end - start;
</span><span class='line'>&#9;&#9;nskb = alloc_skb(copy + header, GFP_ATOMIC);
</span><span class='line'>&#9;&#9;if (!nskb)
</span><span class='line'>&#9;&#9;&#9;return;
</span><span class='line'>
</span><span class='line'>&#9;&#9;skb_set_mac_header(nskb, skb_mac_header(skb) - skb-&gt;head);
</span><span class='line'>&#9;&#9;skb_set_network_header(nskb, (skb_network_header(skb) -
</span><span class='line'>&#9;&#9;&#9;&#9;&#9;&#9;  skb-&gt;head));
</span><span class='line'>&#9;&#9;skb_set_transport_header(nskb, (skb_transport_header(skb) -
</span><span class='line'>&#9;&#9;&#9;&#9;&#9;&#9;skb-&gt;head));
</span><span class='line'>&#9;&#9;skb_reserve(nskb, header);
</span><span class='line'>&#9;&#9;memcpy(nskb-&gt;head, skb-&gt;head, header);
</span><span class='line'>&#9;&#9;memcpy(nskb-&gt;cb, skb-&gt;cb, sizeof(skb-&gt;cb));
</span><span class='line'>&#9;&#9;TCP_SKB_CB(nskb)-&gt;seq = TCP_SKB_CB(nskb)-&gt;end_seq = start;
</span><span class='line'>&#9;&#9;__skb_queue_before(list, skb, nskb);
</span><span class='line'>&#9;&#9;skb_set_owner_r(nskb, sk);
</span><span class='line'>
</span><span class='line'>&#9;&#9;/* Copy data, releasing collapsed skbs. */
</span><span class='line'>&#9;&#9;while (copy &gt; 0) {    // 如果copy = 0，这里就会出BUG，但如果没有认为改，是不会的。ipv6会吗？？？。后面版本改进这函数了，也不会出现copy=0了
</span><span class='line'>&#9;&#9;&#9;int offset = start - TCP_SKB_CB(skb)-&gt;seq;
</span><span class='line'>&#9;&#9;&#9;int size = TCP_SKB_CB(skb)-&gt;end_seq - start;
</span><span class='line'>
</span><span class='line'>&#9;&#9;&#9;BUG_ON(offset &lt; 0);
</span><span class='line'>&#9;&#9;&#9;if (size &gt; 0) { // copy旧的skb数据到新的skb上
</span><span class='line'>&#9;&#9;&#9;&#9;size = min(copy, size);
</span><span class='line'>&#9;&#9;&#9;&#9;if (skb_copy_bits(skb, offset, skb_put(nskb, size), size))
</span><span class='line'>&#9;&#9;&#9;&#9;&#9;BUG();
</span><span class='line'>&#9;&#9;&#9;&#9;TCP_SKB_CB(nskb)-&gt;end_seq += size;
</span><span class='line'>&#9;&#9;&#9;&#9;copy -= size;
</span><span class='line'>&#9;&#9;&#9;&#9;start += size;
</span><span class='line'>&#9;&#9;&#9;}
</span><span class='line'>&#9;&#9;&#9;if (!before(start, TCP_SKB_CB(skb)-&gt;end_seq)) { // 旧的skb被copy完了就删掉
</span><span class='line'>&#9;&#9;&#9;&#9;skb = tcp_collapse_one(sk, skb, list);
</span><span class='line'>&#9;&#9;&#9;&#9;if (!skb ||
</span><span class='line'>&#9;&#9;&#9;&#9;&#9;skb == tail ||
</span><span class='line'>&#9;&#9;&#9;&#9;&#9;tcp_hdr(skb)-&gt;syn ||
</span><span class='line'>&#9;&#9;&#9;&#9;&#9;tcp_hdr(skb)-&gt;fin)
</span><span class='line'>&#9;&#9;&#9;&#9;&#9;return;
</span><span class='line'>&#9;&#9;&#9;}
</span><span class='line'>&#9;&#9;}
</span><span class='line'>&#9;}
</span><span class='line'>}</span></code></pre></td></tr></table></div></figure>


<p>来看sk_mem_reclaim函数，它只是简单的封装了<code>__sk_mem_reclaim</code>：</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>static inline void sk_mem_reclaim(struct sock *sk)
</span><span class='line'>{
</span><span class='line'>&#9;if (!sk_has_account(sk))
</span><span class='line'>&#9;&#9;return;
</span><span class='line'>&#9;// 如果sk_forward_alloc大于1页则调用__sk_mem_reclaim，我们知道sk_forward_alloc是以页为单位的，因此这里也就是和大于0一样。
</span><span class='line'>&#9;if (sk-&gt;sk_forward_alloc &gt;= SK_MEM_QUANTUM)
</span><span class='line'>&#9;&#9;__sk_mem_reclaim(sk);
</span><span class='line'>}</span></code></pre></td></tr></table></div></figure>


<p><code>__sk_mem_reclaim</code>就是真正操作的函数，它会更新memory_allocated：</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>void __sk_mem_reclaim(struct sock *sk)
</span><span class='line'>{
</span><span class='line'>&#9;struct proto *prot = sk-&gt;sk_prot;
</span><span class='line'>&#9;// 更新memory_allocated，这里我们知道memory_allocated也是以页为单位的，因此需要将sk_forward_alloc转化为页。
</span><span class='line'>&#9;atomic_sub(sk-&gt;sk_forward_alloc &gt;&gt; SK_MEM_QUANTUM_SHIFT,prot-&gt;memory_allocated);
</span><span class='line'>
</span><span class='line'>&#9;// 更新这个sk的sk_forward_alloc为一页。
</span><span class='line'>&#9;sk-&gt;sk_forward_alloc &= SK_MEM_QUANTUM - 1;
</span><span class='line'>&#9;// 判断是否处于pressure区域，是的话更新memory_pressure变量。
</span><span class='line'>&#9;if (prot-&gt;memory_pressure && *prot-&gt;memory_pressure &&(atomic_read(prot-&gt;memory_allocated) &lt; （prot-&gt;sysctl_mem[0]))
</span><span class='line'>&#9;&#9;*prot-&gt;memory_pressure = 0;
</span><span class='line'>}</span></code></pre></td></tr></table></div></figure>


<p>最后看一下读buf的释放。这个函数会在kfree_skb中被调用。</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>void sock_rfree(struct sk_buff *skb)
</span><span class='line'>{
</span><span class='line'>
</span><span class='line'>&#9;struct sock *sk = skb-&gt;sk;
</span><span class='line'>&#9;// 更新rmem_alloc
</span><span class='line'>&#9;atomic_sub(skb-&gt;truesize, &sk-&gt;sk_rmem_alloc);
</span><span class='line'>&#9;// 更新forward_alloc.
</span><span class='line'>&#9;sk_mem_uncharge(skb-&gt;sk, skb-&gt;truesize);
</span><span class='line'>}</span></code></pre></td></tr></table></div></figure>



</div>
  
  


    </article>
  
  <div class="pagination">
    
      <a class="prev" href="/posts/178">&larr; Older</a>
    
    <a href="/blog/archives">Blog Archives</a>
    
    <a class="next" href="/posts/176">Newer &rarr;</a>
    
  </div>
</div>
<aside class="sidebar">
  
    <section>
<h1>Categories
<span class='right_span'>(887)</span>

</h1>
<head>
</head>
<body>
<div id="menu">
<ul>
<li class='catclass'><a href='/blog/cats/blog/'>blog</a><a href='##' onmousedown=showDiv('blog') id='aexp_blog'><span class='exp_style' id='exp_blog'>[+]</span></a><span class='right_span'>(13)</span></li>
<div id='blog' class='catsub'><li><a href='/blog/cats/blog~hello/?opendiv=blog'>hello</a><a href='##' onmousedown=showDiv('blog~hello') id='aexp_blog~hello'><span class='exp_style' id='exp_blog~hello'>[+]</span></a><span class='right_span'>1</span></li>
<div id='blog~hello' class='catsub2'><li><a href='/blog/cats/blog~hello~hi/?opendiv=blog~hello'>hi</a><span class='right_span'>1</span></li>
</div><script language='javascript' type='text/javascript'>
if (!document.getElementById('blog~hello')) document.getElementById('aexp_blog~hello').style.visibility = 'hidden';
</script>
<li><a href='/blog/cats/blog~jekyll/?opendiv=blog'>jekyll</a><a href='##' onmousedown=showDiv('blog~jekyll') id='aexp_blog~jekyll'><span class='exp_style' id='exp_blog~jekyll'>[+]</span></a><span class='right_span'>2</span></li>
<script language='javascript' type='text/javascript'>
if (!document.getElementById('blog~jekyll')) document.getElementById('aexp_blog~jekyll').style.visibility = 'hidden';
</script>
<li><a href='/blog/cats/blog~markdown/?opendiv=blog'>markdown</a><a href='##' onmousedown=showDiv('blog~markdown') id='aexp_blog~markdown'><span class='exp_style' id='exp_blog~markdown'>[+]</span></a><span class='right_span'>1</span></li>
<script language='javascript' type='text/javascript'>
if (!document.getElementById('blog~markdown')) document.getElementById('aexp_blog~markdown').style.visibility = 'hidden';
</script>
<li><a href='/blog/cats/blog~octopress/?opendiv=blog'>octopress</a><a href='##' onmousedown=showDiv('blog~octopress') id='aexp_blog~octopress'><span class='exp_style' id='exp_blog~octopress'>[+]</span></a><span class='right_span'>7</span></li>
<script language='javascript' type='text/javascript'>
if (!document.getElementById('blog~octopress')) document.getElementById('aexp_blog~octopress').style.visibility = 'hidden';
</script>
<li><a href='/blog/cats/blog~ruby/?opendiv=blog'>ruby</a><a href='##' onmousedown=showDiv('blog~ruby') id='aexp_blog~ruby'><span class='exp_style' id='exp_blog~ruby'>[+]</span></a><span class='right_span'>2</span></li>
</div><script language='javascript' type='text/javascript'>
if (!document.getElementById('blog')) document.getElementById('aexp_blog').style.visibility = 'hidden';
if (!document.getElementById('blog~ruby')) document.getElementById('aexp_blog~ruby').style.visibility = 'hidden';
</script>
<li class='catclass'><a href='/blog/cats/language/'>language</a><a href='##' onmousedown=showDiv('language') id='aexp_language'><span class='exp_style' id='exp_language'>[+]</span></a><span class='right_span'>(134)</span></li>
<div id='language' class='catsub'><li><a href='/blog/cats/language~c/?opendiv=language'>c</a><a href='##' onmousedown=showDiv('language~c') id='aexp_language~c'><span class='exp_style' id='exp_language~c'>[+]</span></a><span class='right_span'>32</span></li>
<script language='javascript' type='text/javascript'>
if (!document.getElementById('language~c')) document.getElementById('aexp_language~c').style.visibility = 'hidden';
</script>
<li><a href='/blog/cats/language~excel/?opendiv=language'>excel</a><a href='##' onmousedown=showDiv('language~excel') id='aexp_language~excel'><span class='exp_style' id='exp_language~excel'>[+]</span></a><span class='right_span'>3</span></li>
<script language='javascript' type='text/javascript'>
if (!document.getElementById('language~excel')) document.getElementById('aexp_language~excel').style.visibility = 'hidden';
</script>
<li><a href='/blog/cats/language~java/?opendiv=language'>java</a><a href='##' onmousedown=showDiv('language~java') id='aexp_language~java'><span class='exp_style' id='exp_language~java'>[+]</span></a><span class='right_span'>11</span></li>
<script language='javascript' type='text/javascript'>
if (!document.getElementById('language~java')) document.getElementById('aexp_language~java').style.visibility = 'hidden';
</script>
<li><a href='/blog/cats/language~jsp/?opendiv=language'>jsp</a><a href='##' onmousedown=showDiv('language~jsp') id='aexp_language~jsp'><span class='exp_style' id='exp_language~jsp'>[+]</span></a><span class='right_span'>3</span></li>
<script language='javascript' type='text/javascript'>
if (!document.getElementById('language~jsp')) document.getElementById('aexp_language~jsp').style.visibility = 'hidden';
</script>
<li><a href='/blog/cats/language~php/?opendiv=language'>php</a><a href='##' onmousedown=showDiv('language~php') id='aexp_language~php'><span class='exp_style' id='exp_language~php'>[+]</span></a><span class='right_span'>39</span></li>
<script language='javascript' type='text/javascript'>
if (!document.getElementById('language~php')) document.getElementById('aexp_language~php').style.visibility = 'hidden';
</script>
<li><a href='/blog/cats/language~python/?opendiv=language'>python</a><a href='##' onmousedown=showDiv('language~python') id='aexp_language~python'><span class='exp_style' id='exp_language~python'>[+]</span></a><span class='right_span'>4</span></li>
<script language='javascript' type='text/javascript'>
if (!document.getElementById('language~python')) document.getElementById('aexp_language~python').style.visibility = 'hidden';
</script>
<li><a href='/blog/cats/language~web/?opendiv=language'>web</a><a href='##' onmousedown=showDiv('language~web') id='aexp_language~web'><span class='exp_style' id='exp_language~web'>[+]</span></a><span class='right_span'>42</span></li>
</div><script language='javascript' type='text/javascript'>
if (!document.getElementById('language')) document.getElementById('aexp_language').style.visibility = 'hidden';
if (!document.getElementById('language~web')) document.getElementById('aexp_language~web').style.visibility = 'hidden';
</script>
<li class='catclass'><a href='/blog/cats/compiler/'>compiler</a><a href='##' onmousedown=showDiv('compiler') id='aexp_compiler'><span class='exp_style' id='exp_compiler'>[+]</span></a><span class='right_span'>(14)</span></li>
<div id='compiler' class='catsub'><li><a href='/blog/cats/compiler~base/?opendiv=compiler'>base</a><a href='##' onmousedown=showDiv('compiler~base') id='aexp_compiler~base'><span class='exp_style' id='exp_compiler~base'>[+]</span></a><span class='right_span'>10</span></li>
<script language='javascript' type='text/javascript'>
if (!document.getElementById('compiler~base')) document.getElementById('aexp_compiler~base').style.visibility = 'hidden';
</script>
<li><a href='/blog/cats/compiler~make/?opendiv=compiler'>make</a><a href='##' onmousedown=showDiv('compiler~make') id='aexp_compiler~make'><span class='exp_style' id='exp_compiler~make'>[+]</span></a><span class='right_span'>4</span></li>
</div><script language='javascript' type='text/javascript'>
if (!document.getElementById('compiler')) document.getElementById('aexp_compiler').style.visibility = 'hidden';
if (!document.getElementById('compiler~make')) document.getElementById('aexp_compiler~make').style.visibility = 'hidden';
</script>
<li class='catclass'><a href='/blog/cats/assembly/'>assembly</a><a href='##' onmousedown=showDiv('assembly') id='aexp_assembly'><span class='exp_style' id='exp_assembly'>[+]</span></a><span class='right_span'>(16)</span></li>
<div id='assembly' class='catsub'><li><a href='/blog/cats/assembly~arm/?opendiv=assembly'>arm</a><a href='##' onmousedown=showDiv('assembly~arm') id='aexp_assembly~arm'><span class='exp_style' id='exp_assembly~arm'>[+]</span></a><span class='right_span'>2</span></li>
<script language='javascript' type='text/javascript'>
if (!document.getElementById('assembly~arm')) document.getElementById('aexp_assembly~arm').style.visibility = 'hidden';
</script>
<li><a href='/blog/cats/assembly~base/?opendiv=assembly'>base</a><a href='##' onmousedown=showDiv('assembly~base') id='aexp_assembly~base'><span class='exp_style' id='exp_assembly~base'>[+]</span></a><span class='right_span'>13</span></li>
<script language='javascript' type='text/javascript'>
if (!document.getElementById('assembly~base')) document.getElementById('aexp_assembly~base').style.visibility = 'hidden';
</script>
<li><a href='/blog/cats/assembly~win/?opendiv=assembly'>win</a><a href='##' onmousedown=showDiv('assembly~win') id='aexp_assembly~win'><span class='exp_style' id='exp_assembly~win'>[+]</span></a><span class='right_span'>1</span></li>
</div><script language='javascript' type='text/javascript'>
if (!document.getElementById('assembly')) document.getElementById('aexp_assembly').style.visibility = 'hidden';
if (!document.getElementById('assembly~win')) document.getElementById('aexp_assembly~win').style.visibility = 'hidden';
</script>
<li class='catclass'><a href='/blog/cats/tools/'>tools</a><a href='##' onmousedown=showDiv('tools') id='aexp_tools'><span class='exp_style' id='exp_tools'>[+]</span></a><span class='right_span'>(190)</span></li>
<div id='tools' class='catsub'><li><a href='/blog/cats/tools~apache2/?opendiv=tools'>apache2</a><a href='##' onmousedown=showDiv('tools~apache2') id='aexp_tools~apache2'><span class='exp_style' id='exp_tools~apache2'>[+]</span></a><span class='right_span'>8</span></li>
<script language='javascript' type='text/javascript'>
if (!document.getElementById('tools~apache2')) document.getElementById('aexp_tools~apache2').style.visibility = 'hidden';
</script>
<li><a href='/blog/cats/tools~base/?opendiv=tools'>base</a><a href='##' onmousedown=showDiv('tools~base') id='aexp_tools~base'><span class='exp_style' id='exp_tools~base'>[+]</span></a><span class='right_span'>18</span></li>
<script language='javascript' type='text/javascript'>
if (!document.getElementById('tools~base')) document.getElementById('aexp_tools~base').style.visibility = 'hidden';
</script>
<li><a href='/blog/cats/tools~ci/?opendiv=tools'>ci</a><a href='##' onmousedown=showDiv('tools~ci') id='aexp_tools~ci'><span class='exp_style' id='exp_tools~ci'>[+]</span></a><span class='right_span'>4</span></li>
<script language='javascript' type='text/javascript'>
if (!document.getElementById('tools~ci')) document.getElementById('aexp_tools~ci').style.visibility = 'hidden';
</script>
<li><a href='/blog/cats/tools~cloud/?opendiv=tools'>cloud</a><a href='##' onmousedown=showDiv('tools~cloud') id='aexp_tools~cloud'><span class='exp_style' id='exp_tools~cloud'>[+]</span></a><span class='right_span'>1</span></li>
<script language='javascript' type='text/javascript'>
if (!document.getElementById('tools~cloud')) document.getElementById('aexp_tools~cloud').style.visibility = 'hidden';
</script>
<li><a href='/blog/cats/tools~command/?opendiv=tools'>command</a><a href='##' onmousedown=showDiv('tools~command') id='aexp_tools~command'><span class='exp_style' id='exp_tools~command'>[+]</span></a><span class='right_span'>30</span></li>
<script language='javascript' type='text/javascript'>
if (!document.getElementById('tools~command')) document.getElementById('aexp_tools~command').style.visibility = 'hidden';
</script>
<li><a href='/blog/cats/tools~dns/?opendiv=tools'>dns</a><a href='##' onmousedown=showDiv('tools~dns') id='aexp_tools~dns'><span class='exp_style' id='exp_tools~dns'>[+]</span></a><span class='right_span'>6</span></li>
<script language='javascript' type='text/javascript'>
if (!document.getElementById('tools~dns')) document.getElementById('aexp_tools~dns').style.visibility = 'hidden';
</script>
<li><a href='/blog/cats/tools~git/?opendiv=tools'>git</a><a href='##' onmousedown=showDiv('tools~git') id='aexp_tools~git'><span class='exp_style' id='exp_tools~git'>[+]</span></a><span class='right_span'>14</span></li>
<script language='javascript' type='text/javascript'>
if (!document.getElementById('tools~git')) document.getElementById('aexp_tools~git').style.visibility = 'hidden';
</script>
<li><a href='/blog/cats/tools~graphviz,-codeviz/?opendiv=tools'>graphviz、codeviz</a><a href='##' onmousedown=showDiv('tools~graphviz、codeviz') id='aexp_tools~graphviz、codeviz'><span class='exp_style' id='exp_tools~graphviz、codeviz'>[+]</span></a><span class='right_span'>1</span></li>
<script language='javascript' type='text/javascript'>
if (!document.getElementById('tools~graphviz、codeviz')) document.getElementById('aexp_tools~graphviz、codeviz').style.visibility = 'hidden';
</script>
<li><a href='/blog/cats/tools~haproxy/?opendiv=tools'>haproxy</a><a href='##' onmousedown=showDiv('tools~haproxy') id='aexp_tools~haproxy'><span class='exp_style' id='exp_tools~haproxy'>[+]</span></a><span class='right_span'>9</span></li>
<script language='javascript' type='text/javascript'>
if (!document.getElementById('tools~haproxy')) document.getElementById('aexp_tools~haproxy').style.visibility = 'hidden';
</script>
<li><a href='/blog/cats/tools~isal/?opendiv=tools'>isal</a><a href='##' onmousedown=showDiv('tools~isal') id='aexp_tools~isal'><span class='exp_style' id='exp_tools~isal'>[+]</span></a><span class='right_span'>3</span></li>
<script language='javascript' type='text/javascript'>
if (!document.getElementById('tools~isal')) document.getElementById('aexp_tools~isal').style.visibility = 'hidden';
</script>
<li><a href='/blog/cats/tools~mysql/?opendiv=tools'>mysql</a><a href='##' onmousedown=showDiv('tools~mysql') id='aexp_tools~mysql'><span class='exp_style' id='exp_tools~mysql'>[+]</span></a><span class='right_span'>28</span></li>
<script language='javascript' type='text/javascript'>
if (!document.getElementById('tools~mysql')) document.getElementById('aexp_tools~mysql').style.visibility = 'hidden';
</script>
<li><a href='/blog/cats/tools~nginx/?opendiv=tools'>nginx</a><a href='##' onmousedown=showDiv('tools~nginx') id='aexp_tools~nginx'><span class='exp_style' id='exp_tools~nginx'>[+]</span></a><span class='right_span'>17</span></li>
<script language='javascript' type='text/javascript'>
if (!document.getElementById('tools~nginx')) document.getElementById('aexp_tools~nginx').style.visibility = 'hidden';
</script>
<li><a href='/blog/cats/tools~obs/?opendiv=tools'>obs</a><a href='##' onmousedown=showDiv('tools~obs') id='aexp_tools~obs'><span class='exp_style' id='exp_tools~obs'>[+]</span></a><span class='right_span'>2</span></li>
<script language='javascript' type='text/javascript'>
if (!document.getElementById('tools~obs')) document.getElementById('aexp_tools~obs').style.visibility = 'hidden';
</script>
<li><a href='/blog/cats/tools~openvpn/?opendiv=tools'>openvpn</a><a href='##' onmousedown=showDiv('tools~openvpn') id='aexp_tools~openvpn'><span class='exp_style' id='exp_tools~openvpn'>[+]</span></a><span class='right_span'>1</span></li>
<script language='javascript' type='text/javascript'>
if (!document.getElementById('tools~openvpn')) document.getElementById('aexp_tools~openvpn').style.visibility = 'hidden';
</script>
<li><a href='/blog/cats/tools~oracle/?opendiv=tools'>oracle</a><a href='##' onmousedown=showDiv('tools~oracle') id='aexp_tools~oracle'><span class='exp_style' id='exp_tools~oracle'>[+]</span></a><span class='right_span'>2</span></li>
<script language='javascript' type='text/javascript'>
if (!document.getElementById('tools~oracle')) document.getElementById('aexp_tools~oracle').style.visibility = 'hidden';
</script>
<li><a href='/blog/cats/tools~picture/?opendiv=tools'>picture</a><a href='##' onmousedown=showDiv('tools~picture') id='aexp_tools~picture'><span class='exp_style' id='exp_tools~picture'>[+]</span></a><span class='right_span'>2</span></li>
<script language='javascript' type='text/javascript'>
if (!document.getElementById('tools~picture')) document.getElementById('aexp_tools~picture').style.visibility = 'hidden';
</script>
<li><a href='/blog/cats/tools~redis/?opendiv=tools'>redis</a><a href='##' onmousedown=showDiv('tools~redis') id='aexp_tools~redis'><span class='exp_style' id='exp_tools~redis'>[+]</span></a><span class='right_span'>2</span></li>
<script language='javascript' type='text/javascript'>
if (!document.getElementById('tools~redis')) document.getElementById('aexp_tools~redis').style.visibility = 'hidden';
</script>
<li><a href='/blog/cats/tools~smb/?opendiv=tools'>smb</a><a href='##' onmousedown=showDiv('tools~smb') id='aexp_tools~smb'><span class='exp_style' id='exp_tools~smb'>[+]</span></a><span class='right_span'>3</span></li>
<script language='javascript' type='text/javascript'>
if (!document.getElementById('tools~smb')) document.getElementById('aexp_tools~smb').style.visibility = 'hidden';
</script>
<li><a href='/blog/cats/tools~socksvpn/?opendiv=tools'>socksvpn</a><a href='##' onmousedown=showDiv('tools~socksvpn') id='aexp_tools~socksvpn'><span class='exp_style' id='exp_tools~socksvpn'>[+]</span></a><span class='right_span'>3</span></li>
<script language='javascript' type='text/javascript'>
if (!document.getElementById('tools~socksvpn')) document.getElementById('aexp_tools~socksvpn').style.visibility = 'hidden';
</script>
<li><a href='/blog/cats/tools~sqlmap/?opendiv=tools'>sqlmap</a><a href='##' onmousedown=showDiv('tools~sqlmap') id='aexp_tools~sqlmap'><span class='exp_style' id='exp_tools~sqlmap'>[+]</span></a><span class='right_span'>3</span></li>
<script language='javascript' type='text/javascript'>
if (!document.getElementById('tools~sqlmap')) document.getElementById('aexp_tools~sqlmap').style.visibility = 'hidden';
</script>
<li><a href='/blog/cats/tools~sqlserver/?opendiv=tools'>sqlserver</a><a href='##' onmousedown=showDiv('tools~sqlserver') id='aexp_tools~sqlserver'><span class='exp_style' id='exp_tools~sqlserver'>[+]</span></a><span class='right_span'>8</span></li>
<script language='javascript' type='text/javascript'>
if (!document.getElementById('tools~sqlserver')) document.getElementById('aexp_tools~sqlserver').style.visibility = 'hidden';
</script>
<li><a href='/blog/cats/tools~squid/?opendiv=tools'>squid</a><a href='##' onmousedown=showDiv('tools~squid') id='aexp_tools~squid'><span class='exp_style' id='exp_tools~squid'>[+]</span></a><span class='right_span'>4</span></li>
<script language='javascript' type='text/javascript'>
if (!document.getElementById('tools~squid')) document.getElementById('aexp_tools~squid').style.visibility = 'hidden';
</script>
<li><a href='/blog/cats/tools~ssh/?opendiv=tools'>ssh</a><a href='##' onmousedown=showDiv('tools~ssh') id='aexp_tools~ssh'><span class='exp_style' id='exp_tools~ssh'>[+]</span></a><span class='right_span'>6</span></li>
<script language='javascript' type='text/javascript'>
if (!document.getElementById('tools~ssh')) document.getElementById('aexp_tools~ssh').style.visibility = 'hidden';
</script>
<li><a href='/blog/cats/tools~ssl/?opendiv=tools'>ssl</a><a href='##' onmousedown=showDiv('tools~ssl') id='aexp_tools~ssl'><span class='exp_style' id='exp_tools~ssl'>[+]</span></a><span class='right_span'>3</span></li>
<script language='javascript' type='text/javascript'>
if (!document.getElementById('tools~ssl')) document.getElementById('aexp_tools~ssl').style.visibility = 'hidden';
</script>
<li><a href='/blog/cats/tools~switch/?opendiv=tools'>switch</a><a href='##' onmousedown=showDiv('tools~switch') id='aexp_tools~switch'><span class='exp_style' id='exp_tools~switch'>[+]</span></a><span class='right_span'>2</span></li>
<script language='javascript' type='text/javascript'>
if (!document.getElementById('tools~switch')) document.getElementById('aexp_tools~switch').style.visibility = 'hidden';
</script>
<li><a href='/blog/cats/tools~vim/?opendiv=tools'>vim</a><a href='##' onmousedown=showDiv('tools~vim') id='aexp_tools~vim'><span class='exp_style' id='exp_tools~vim'>[+]</span></a><span class='right_span'>8</span></li>
<script language='javascript' type='text/javascript'>
if (!document.getElementById('tools~vim')) document.getElementById('aexp_tools~vim').style.visibility = 'hidden';
</script>
<li><a href='/blog/cats/tools~wxwork/?opendiv=tools'>wxwork</a><a href='##' onmousedown=showDiv('tools~wxwork') id='aexp_tools~wxwork'><span class='exp_style' id='exp_tools~wxwork'>[+]</span></a><span class='right_span'>2</span></li>
</div><script language='javascript' type='text/javascript'>
if (!document.getElementById('tools')) document.getElementById('aexp_tools').style.visibility = 'hidden';
if (!document.getElementById('tools~wxwork')) document.getElementById('aexp_tools~wxwork').style.visibility = 'hidden';
</script>
<li class='catclass'><a href='/blog/cats/system/'>system</a><a href='##' onmousedown=showDiv('system') id='aexp_system'><span class='exp_style' id='exp_system'>[+]</span></a><span class='right_span'>(102)</span></li>
<div id='system' class='catsub'><li><a href='/blog/cats/system~base/?opendiv=system'>base</a><a href='##' onmousedown=showDiv('system~base') id='aexp_system~base'><span class='exp_style' id='exp_system~base'>[+]</span></a><span class='right_span'>20</span></li>
<script language='javascript' type='text/javascript'>
if (!document.getElementById('system~base')) document.getElementById('aexp_system~base').style.visibility = 'hidden';
</script>
<li><a href='/blog/cats/system~centos/?opendiv=system'>centos</a><a href='##' onmousedown=showDiv('system~centos') id='aexp_system~centos'><span class='exp_style' id='exp_system~centos'>[+]</span></a><span class='right_span'>12</span></li>
<script language='javascript' type='text/javascript'>
if (!document.getElementById('system~centos')) document.getElementById('aexp_system~centos').style.visibility = 'hidden';
</script>
<li><a href='/blog/cats/system~cgroup/?opendiv=system'>cgroup</a><a href='##' onmousedown=showDiv('system~cgroup') id='aexp_system~cgroup'><span class='exp_style' id='exp_system~cgroup'>[+]</span></a><span class='right_span'>10</span></li>
<script language='javascript' type='text/javascript'>
if (!document.getElementById('system~cgroup')) document.getElementById('aexp_system~cgroup').style.visibility = 'hidden';
</script>
<li><a href='/blog/cats/system~docker/?opendiv=system'>docker</a><a href='##' onmousedown=showDiv('system~docker') id='aexp_system~docker'><span class='exp_style' id='exp_system~docker'>[+]</span></a><span class='right_span'>6</span></li>
<script language='javascript' type='text/javascript'>
if (!document.getElementById('system~docker')) document.getElementById('aexp_system~docker').style.visibility = 'hidden';
</script>
<li><a href='/blog/cats/system~fs/?opendiv=system'>fs</a><a href='##' onmousedown=showDiv('system~fs') id='aexp_system~fs'><span class='exp_style' id='exp_system~fs'>[+]</span></a><span class='right_span'>9</span></li>
<script language='javascript' type='text/javascript'>
if (!document.getElementById('system~fs')) document.getElementById('aexp_system~fs').style.visibility = 'hidden';
</script>
<li><a href='/blog/cats/system~grub/?opendiv=system'>grub</a><a href='##' onmousedown=showDiv('system~grub') id='aexp_system~grub'><span class='exp_style' id='exp_system~grub'>[+]</span></a><span class='right_span'>4</span></li>
<script language='javascript' type='text/javascript'>
if (!document.getElementById('system~grub')) document.getElementById('aexp_system~grub').style.visibility = 'hidden';
</script>
<li><a href='/blog/cats/system~hik/?opendiv=system'>hik</a><a href='##' onmousedown=showDiv('system~hik') id='aexp_system~hik'><span class='exp_style' id='exp_system~hik'>[+]</span></a><span class='right_span'>4</span></li>
<script language='javascript' type='text/javascript'>
if (!document.getElementById('system~hik')) document.getElementById('aexp_system~hik').style.visibility = 'hidden';
</script>
<li><a href='/blog/cats/system~influx/?opendiv=system'>influx</a><a href='##' onmousedown=showDiv('system~influx') id='aexp_system~influx'><span class='exp_style' id='exp_system~influx'>[+]</span></a><span class='right_span'>4</span></li>
<script language='javascript' type='text/javascript'>
if (!document.getElementById('system~influx')) document.getElementById('aexp_system~influx').style.visibility = 'hidden';
</script>
<li><a href='/blog/cats/system~kvm/?opendiv=system'>kvm</a><a href='##' onmousedown=showDiv('system~kvm') id='aexp_system~kvm'><span class='exp_style' id='exp_system~kvm'>[+]</span></a><span class='right_span'>10</span></li>
<script language='javascript' type='text/javascript'>
if (!document.getElementById('system~kvm')) document.getElementById('aexp_system~kvm').style.visibility = 'hidden';
</script>
<li><a href='/blog/cats/system~mail/?opendiv=system'>mail</a><a href='##' onmousedown=showDiv('system~mail') id='aexp_system~mail'><span class='exp_style' id='exp_system~mail'>[+]</span></a><span class='right_span'>3</span></li>
<script language='javascript' type='text/javascript'>
if (!document.getElementById('system~mail')) document.getElementById('aexp_system~mail').style.visibility = 'hidden';
</script>
<li><a href='/blog/cats/system~namespace/?opendiv=system'>namespace</a><a href='##' onmousedown=showDiv('system~namespace') id='aexp_system~namespace'><span class='exp_style' id='exp_system~namespace'>[+]</span></a><span class='right_span'>2</span></li>
<script language='javascript' type='text/javascript'>
if (!document.getElementById('system~namespace')) document.getElementById('aexp_system~namespace').style.visibility = 'hidden';
</script>
<li><a href='/blog/cats/system~ubuntu/?opendiv=system'>ubuntu</a><a href='##' onmousedown=showDiv('system~ubuntu') id='aexp_system~ubuntu'><span class='exp_style' id='exp_system~ubuntu'>[+]</span></a><span class='right_span'>18</span></li>
</div><script language='javascript' type='text/javascript'>
if (!document.getElementById('system')) document.getElementById('aexp_system').style.visibility = 'hidden';
if (!document.getElementById('system~ubuntu')) document.getElementById('aexp_system~ubuntu').style.visibility = 'hidden';
</script>
<li class='catclass'><a href='/blog/cats/kernel/'>kernel</a><a href='##' onmousedown=showDiv('kernel') id='aexp_kernel'><span class='exp_style' id='exp_kernel'>[+]</span></a><span class='right_span'>(273)</span></li>
<div id='kernel' class='catsub'><li><a href='/blog/cats/kernel~10gb/?opendiv=kernel'>10gb</a><a href='##' onmousedown=showDiv('kernel~10gb') id='aexp_kernel~10gb'><span class='exp_style' id='exp_kernel~10gb'>[+]</span></a><span class='right_span'>7</span></li>
<script language='javascript' type='text/javascript'>
if (!document.getElementById('kernel~10gb')) document.getElementById('aexp_kernel~10gb').style.visibility = 'hidden';
</script>
<li><a href='/blog/cats/kernel~base/?opendiv=kernel'>base</a><a href='##' onmousedown=showDiv('kernel~base') id='aexp_kernel~base'><span class='exp_style' id='exp_kernel~base'>[+]</span></a><span class='right_span'>21</span></li>
<script language='javascript' type='text/javascript'>
if (!document.getElementById('kernel~base')) document.getElementById('aexp_kernel~base').style.visibility = 'hidden';
</script>
<li><a href='/blog/cats/kernel~bonding/?opendiv=kernel'>bonding</a><a href='##' onmousedown=showDiv('kernel~bonding') id='aexp_kernel~bonding'><span class='exp_style' id='exp_kernel~bonding'>[+]</span></a><span class='right_span'>2</span></li>
<script language='javascript' type='text/javascript'>
if (!document.getElementById('kernel~bonding')) document.getElementById('aexp_kernel~bonding').style.visibility = 'hidden';
</script>
<li><a href='/blog/cats/kernel~clock/?opendiv=kernel'>clock</a><a href='##' onmousedown=showDiv('kernel~clock') id='aexp_kernel~clock'><span class='exp_style' id='exp_kernel~clock'>[+]</span></a><span class='right_span'>9</span></li>
<script language='javascript' type='text/javascript'>
if (!document.getElementById('kernel~clock')) document.getElementById('aexp_kernel~clock').style.visibility = 'hidden';
</script>
<li><a href='/blog/cats/kernel~crypto/?opendiv=kernel'>crypto</a><a href='##' onmousedown=showDiv('kernel~crypto') id='aexp_kernel~crypto'><span class='exp_style' id='exp_kernel~crypto'>[+]</span></a><span class='right_span'>2</span></li>
<script language='javascript' type='text/javascript'>
if (!document.getElementById('kernel~crypto')) document.getElementById('aexp_kernel~crypto').style.visibility = 'hidden';
</script>
<li><a href='/blog/cats/kernel~fpu/?opendiv=kernel'>fpu</a><a href='##' onmousedown=showDiv('kernel~fpu') id='aexp_kernel~fpu'><span class='exp_style' id='exp_kernel~fpu'>[+]</span></a><span class='right_span'>2</span></li>
<script language='javascript' type='text/javascript'>
if (!document.getElementById('kernel~fpu')) document.getElementById('aexp_kernel~fpu').style.visibility = 'hidden';
</script>
<li><a href='/blog/cats/kernel~fs/?opendiv=kernel'>fs</a><a href='##' onmousedown=showDiv('kernel~fs') id='aexp_kernel~fs'><span class='exp_style' id='exp_kernel~fs'>[+]</span></a><span class='right_span'>2</span></li>
<script language='javascript' type='text/javascript'>
if (!document.getElementById('kernel~fs')) document.getElementById('aexp_kernel~fs').style.visibility = 'hidden';
</script>
<li><a href='/blog/cats/kernel~ipsec/?opendiv=kernel'>ipsec</a><a href='##' onmousedown=showDiv('kernel~ipsec') id='aexp_kernel~ipsec'><span class='exp_style' id='exp_kernel~ipsec'>[+]</span></a><span class='right_span'>13</span></li>
<script language='javascript' type='text/javascript'>
if (!document.getElementById('kernel~ipsec')) document.getElementById('aexp_kernel~ipsec').style.visibility = 'hidden';
</script>
<li><a href='/blog/cats/kernel~irq/?opendiv=kernel'>irq</a><a href='##' onmousedown=showDiv('kernel~irq') id='aexp_kernel~irq'><span class='exp_style' id='exp_kernel~irq'>[+]</span></a><span class='right_span'>11</span></li>
<script language='javascript' type='text/javascript'>
if (!document.getElementById('kernel~irq')) document.getElementById('aexp_kernel~irq').style.visibility = 'hidden';
</script>
<li><a href='/blog/cats/kernel~kexec/?opendiv=kernel'>kexec</a><a href='##' onmousedown=showDiv('kernel~kexec') id='aexp_kernel~kexec'><span class='exp_style' id='exp_kernel~kexec'>[+]</span></a><span class='right_span'>1</span></li>
<script language='javascript' type='text/javascript'>
if (!document.getElementById('kernel~kexec')) document.getElementById('aexp_kernel~kexec').style.visibility = 'hidden';
</script>
<li><a href='/blog/cats/kernel~mm/?opendiv=kernel'>mm</a><a href='##' onmousedown=showDiv('kernel~mm') id='aexp_kernel~mm'><span class='exp_style' id='exp_kernel~mm'>[+]</span></a><span class='right_span'>34</span></li>
<script language='javascript' type='text/javascript'>
if (!document.getElementById('kernel~mm')) document.getElementById('aexp_kernel~mm').style.visibility = 'hidden';
</script>
<li><a href='/blog/cats/kernel~mptcp/?opendiv=kernel'>mptcp</a><a href='##' onmousedown=showDiv('kernel~mptcp') id='aexp_kernel~mptcp'><span class='exp_style' id='exp_kernel~mptcp'>[+]</span></a><span class='right_span'>13</span></li>
<script language='javascript' type='text/javascript'>
if (!document.getElementById('kernel~mptcp')) document.getElementById('aexp_kernel~mptcp').style.visibility = 'hidden';
</script>
<li><a href='/blog/cats/kernel~net/?opendiv=kernel'>net</a><a href='##' onmousedown=showDiv('kernel~net') id='aexp_kernel~net'><span class='exp_style' id='exp_kernel~net'>[+]</span></a><span class='right_span'>113</span></li>
<script language='javascript' type='text/javascript'>
if (!document.getElementById('kernel~net')) document.getElementById('aexp_kernel~net').style.visibility = 'hidden';
</script>
<li><a href='/blog/cats/kernel~proc/?opendiv=kernel'>proc</a><a href='##' onmousedown=showDiv('kernel~proc') id='aexp_kernel~proc'><span class='exp_style' id='exp_kernel~proc'>[+]</span></a><span class='right_span'>6</span></li>
<script language='javascript' type='text/javascript'>
if (!document.getElementById('kernel~proc')) document.getElementById('aexp_kernel~proc').style.visibility = 'hidden';
</script>
<li><a href='/blog/cats/kernel~sched/?opendiv=kernel'>sched</a><a href='##' onmousedown=showDiv('kernel~sched') id='aexp_kernel~sched'><span class='exp_style' id='exp_kernel~sched'>[+]</span></a><span class='right_span'>20</span></li>
<script language='javascript' type='text/javascript'>
if (!document.getElementById('kernel~sched')) document.getElementById('aexp_kernel~sched').style.visibility = 'hidden';
</script>
<li><a href='/blog/cats/kernel~signature/?opendiv=kernel'>signature</a><a href='##' onmousedown=showDiv('kernel~signature') id='aexp_kernel~signature'><span class='exp_style' id='exp_kernel~signature'>[+]</span></a><span class='right_span'>5</span></li>
<script language='javascript' type='text/javascript'>
if (!document.getElementById('kernel~signature')) document.getElementById('aexp_kernel~signature').style.visibility = 'hidden';
</script>
<li><a href='/blog/cats/kernel~sound/?opendiv=kernel'>sound</a><a href='##' onmousedown=showDiv('kernel~sound') id='aexp_kernel~sound'><span class='exp_style' id='exp_kernel~sound'>[+]</span></a><span class='right_span'>5</span></li>
<script language='javascript' type='text/javascript'>
if (!document.getElementById('kernel~sound')) document.getElementById('aexp_kernel~sound').style.visibility = 'hidden';
</script>
<li><a href='/blog/cats/kernel~tcp/?opendiv=kernel'>tcp</a><a href='##' onmousedown=showDiv('kernel~tcp') id='aexp_kernel~tcp'><span class='exp_style' id='exp_kernel~tcp'>[+]</span></a><span class='right_span'>3</span></li>
<script language='javascript' type='text/javascript'>
if (!document.getElementById('kernel~tcp')) document.getElementById('aexp_kernel~tcp').style.visibility = 'hidden';
</script>
<li><a href='/blog/cats/kernel~vpn/?opendiv=kernel'>vpn</a><a href='##' onmousedown=showDiv('kernel~vpn') id='aexp_kernel~vpn'><span class='exp_style' id='exp_kernel~vpn'>[+]</span></a><span class='right_span'>4</span></li>
</div><script language='javascript' type='text/javascript'>
if (!document.getElementById('kernel')) document.getElementById('aexp_kernel').style.visibility = 'hidden';
if (!document.getElementById('kernel~vpn')) document.getElementById('aexp_kernel~vpn').style.visibility = 'hidden';
</script>
<li class='catclass'><a href='/blog/cats/debug/'>debug</a><a href='##' onmousedown=showDiv('debug') id='aexp_debug'><span class='exp_style' id='exp_debug'>[+]</span></a><span class='right_span'>(84)</span></li>
<div id='debug' class='catsub'><li><a href='/blog/cats/debug~base/?opendiv=debug'>base</a><a href='##' onmousedown=showDiv('debug~base') id='aexp_debug~base'><span class='exp_style' id='exp_debug~base'>[+]</span></a><span class='right_span'>19</span></li>
<script language='javascript' type='text/javascript'>
if (!document.getElementById('debug~base')) document.getElementById('aexp_debug~base').style.visibility = 'hidden';
</script>
<li><a href='/blog/cats/debug~dwarf/?opendiv=debug'>dwarf</a><a href='##' onmousedown=showDiv('debug~dwarf') id='aexp_debug~dwarf'><span class='exp_style' id='exp_debug~dwarf'>[+]</span></a><span class='right_span'>5</span></li>
<script language='javascript' type='text/javascript'>
if (!document.getElementById('debug~dwarf')) document.getElementById('aexp_debug~dwarf').style.visibility = 'hidden';
</script>
<li><a href='/blog/cats/debug~gdb/?opendiv=debug'>gdb</a><a href='##' onmousedown=showDiv('debug~gdb') id='aexp_debug~gdb'><span class='exp_style' id='exp_debug~gdb'>[+]</span></a><span class='right_span'>11</span></li>
<script language='javascript' type='text/javascript'>
if (!document.getElementById('debug~gdb')) document.getElementById('aexp_debug~gdb').style.visibility = 'hidden';
</script>
<li><a href='/blog/cats/debug~http/?opendiv=debug'>http</a><a href='##' onmousedown=showDiv('debug~http') id='aexp_debug~http'><span class='exp_style' id='exp_debug~http'>[+]</span></a><span class='right_span'>1</span></li>
<script language='javascript' type='text/javascript'>
if (!document.getElementById('debug~http')) document.getElementById('aexp_debug~http').style.visibility = 'hidden';
</script>
<li><a href='/blog/cats/debug~kdump,-crash/?opendiv=debug'>kdump、crash</a><a href='##' onmousedown=showDiv('debug~kdump、crash') id='aexp_debug~kdump、crash'><span class='exp_style' id='exp_debug~kdump、crash'>[+]</span></a><span class='right_span'>13</span></li>
<script language='javascript' type='text/javascript'>
if (!document.getElementById('debug~kdump、crash')) document.getElementById('aexp_debug~kdump、crash').style.visibility = 'hidden';
</script>
<li><a href='/blog/cats/debug~kgdb/?opendiv=debug'>kgdb</a><a href='##' onmousedown=showDiv('debug~kgdb') id='aexp_debug~kgdb'><span class='exp_style' id='exp_debug~kgdb'>[+]</span></a><span class='right_span'>3</span></li>
<script language='javascript' type='text/javascript'>
if (!document.getElementById('debug~kgdb')) document.getElementById('aexp_debug~kgdb').style.visibility = 'hidden';
</script>
<li><a href='/blog/cats/debug~kprobe/?opendiv=debug'>kprobe</a><a href='##' onmousedown=showDiv('debug~kprobe') id='aexp_debug~kprobe'><span class='exp_style' id='exp_debug~kprobe'>[+]</span></a><span class='right_span'>4</span></li>
<script language='javascript' type='text/javascript'>
if (!document.getElementById('debug~kprobe')) document.getElementById('aexp_debug~kprobe').style.visibility = 'hidden';
</script>
<li><a href='/blog/cats/debug~ksplice/?opendiv=debug'>ksplice</a><a href='##' onmousedown=showDiv('debug~ksplice') id='aexp_debug~ksplice'><span class='exp_style' id='exp_debug~ksplice'>[+]</span></a><span class='right_span'>3</span></li>
<script language='javascript' type='text/javascript'>
if (!document.getElementById('debug~ksplice')) document.getElementById('aexp_debug~ksplice').style.visibility = 'hidden';
</script>
<li><a href='/blog/cats/debug~mark/?opendiv=debug'>mark</a><a href='##' onmousedown=showDiv('debug~mark') id='aexp_debug~mark'><span class='exp_style' id='exp_debug~mark'>[+]</span></a><span class='right_span'>18</span></li>
<script language='javascript' type='text/javascript'>
if (!document.getElementById('debug~mark')) document.getElementById('aexp_debug~mark').style.visibility = 'hidden';
</script>
<li><a href='/blog/cats/debug~perf/?opendiv=debug'>perf</a><a href='##' onmousedown=showDiv('debug~perf') id='aexp_debug~perf'><span class='exp_style' id='exp_debug~perf'>[+]</span></a><span class='right_span'>2</span></li>
<script language='javascript' type='text/javascript'>
if (!document.getElementById('debug~perf')) document.getElementById('aexp_debug~perf').style.visibility = 'hidden';
</script>
<li><a href='/blog/cats/debug~systemtap/?opendiv=debug'>systemtap</a><a href='##' onmousedown=showDiv('debug~systemtap') id='aexp_debug~systemtap'><span class='exp_style' id='exp_debug~systemtap'>[+]</span></a><span class='right_span'>5</span></li>
</div><script language='javascript' type='text/javascript'>
if (!document.getElementById('debug')) document.getElementById('aexp_debug').style.visibility = 'hidden';
if (!document.getElementById('debug~systemtap')) document.getElementById('aexp_debug~systemtap').style.visibility = 'hidden';
</script>
<li class='catclass'><a href='/blog/cats/android/'>android</a><a href='##' onmousedown=showDiv('android') id='aexp_android'><span class='exp_style' id='exp_android'>[+]</span></a><span class='right_span'>(28)</span></li>
<div id='android' class='catsub'><li><a href='/blog/cats/android~base/?opendiv=android'>base</a><a href='##' onmousedown=showDiv('android~base') id='aexp_android~base'><span class='exp_style' id='exp_android~base'>[+]</span></a><span class='right_span'>15</span></li>
<script language='javascript' type='text/javascript'>
if (!document.getElementById('android~base')) document.getElementById('aexp_android~base').style.visibility = 'hidden';
</script>
<li><a href='/blog/cats/android~g9300/?opendiv=android'>g9300</a><a href='##' onmousedown=showDiv('android~g9300') id='aexp_android~g9300'><span class='exp_style' id='exp_android~g9300'>[+]</span></a><span class='right_span'>4</span></li>
<script language='javascript' type='text/javascript'>
if (!document.getElementById('android~g9300')) document.getElementById('aexp_android~g9300').style.visibility = 'hidden';
</script>
<li><a href='/blog/cats/android~i9507v/?opendiv=android'>i9507v</a><a href='##' onmousedown=showDiv('android~i9507v') id='aexp_android~i9507v'><span class='exp_style' id='exp_android~i9507v'>[+]</span></a><span class='right_span'>1</span></li>
<script language='javascript' type='text/javascript'>
if (!document.getElementById('android~i9507v')) document.getElementById('aexp_android~i9507v').style.visibility = 'hidden';
</script>
<li><a href='/blog/cats/android~me722/?opendiv=android'>me722</a><a href='##' onmousedown=showDiv('android~me722') id='aexp_android~me722'><span class='exp_style' id='exp_android~me722'>[+]</span></a><span class='right_span'>3</span></li>
<script language='javascript' type='text/javascript'>
if (!document.getElementById('android~me722')) document.getElementById('aexp_android~me722').style.visibility = 'hidden';
</script>
<li><a href='/blog/cats/android~nx403a/?opendiv=android'>nx403a</a><a href='##' onmousedown=showDiv('android~nx403a') id='aexp_android~nx403a'><span class='exp_style' id='exp_android~nx403a'>[+]</span></a><span class='right_span'>3</span></li>
<script language='javascript' type='text/javascript'>
if (!document.getElementById('android~nx403a')) document.getElementById('aexp_android~nx403a').style.visibility = 'hidden';
</script>
<li><a href='/blog/cats/android~s5830/?opendiv=android'>s5830</a><a href='##' onmousedown=showDiv('android~s5830') id='aexp_android~s5830'><span class='exp_style' id='exp_android~s5830'>[+]</span></a><span class='right_span'>2</span></li>
</div><script language='javascript' type='text/javascript'>
if (!document.getElementById('android')) document.getElementById('aexp_android').style.visibility = 'hidden';
if (!document.getElementById('android~s5830')) document.getElementById('aexp_android~s5830').style.visibility = 'hidden';
</script>
<li class='catclass'><a href='/blog/cats/algorithm/'>algorithm</a><a href='##' onmousedown=showDiv('algorithm') id='aexp_algorithm'><span class='exp_style' id='exp_algorithm'>[+]</span></a><span class='right_span'>(33)</span></li>
<div id='algorithm' class='catsub'><li><a href='/blog/cats/algorithm~base/?opendiv=algorithm'>base</a><a href='##' onmousedown=showDiv('algorithm~base') id='aexp_algorithm~base'><span class='exp_style' id='exp_algorithm~base'>[+]</span></a><span class='right_span'>24</span></li>
<script language='javascript' type='text/javascript'>
if (!document.getElementById('algorithm~base')) document.getElementById('aexp_algorithm~base').style.visibility = 'hidden';
</script>
<li><a href='/blog/cats/algorithm~dp/?opendiv=algorithm'>dp</a><a href='##' onmousedown=showDiv('algorithm~dp') id='aexp_algorithm~dp'><span class='exp_style' id='exp_algorithm~dp'>[+]</span></a><span class='right_span'>1</span></li>
<script language='javascript' type='text/javascript'>
if (!document.getElementById('algorithm~dp')) document.getElementById('aexp_algorithm~dp').style.visibility = 'hidden';
</script>
<li><a href='/blog/cats/algorithm~ds/?opendiv=algorithm'>ds</a><a href='##' onmousedown=showDiv('algorithm~ds') id='aexp_algorithm~ds'><span class='exp_style' id='exp_algorithm~ds'>[+]</span></a><span class='right_span'>4</span></li>
<script language='javascript' type='text/javascript'>
if (!document.getElementById('algorithm~ds')) document.getElementById('aexp_algorithm~ds').style.visibility = 'hidden';
</script>
<li><a href='/blog/cats/algorithm~game/?opendiv=algorithm'>game</a><a href='##' onmousedown=showDiv('algorithm~game') id='aexp_algorithm~game'><span class='exp_style' id='exp_algorithm~game'>[+]</span></a><span class='right_span'>2</span></li>
<script language='javascript' type='text/javascript'>
if (!document.getElementById('algorithm~game')) document.getElementById('aexp_algorithm~game').style.visibility = 'hidden';
</script>
<li><a href='/blog/cats/algorithm~tc/?opendiv=algorithm'>tc</a><a href='##' onmousedown=showDiv('algorithm~tc') id='aexp_algorithm~tc'><span class='exp_style' id='exp_algorithm~tc'>[+]</span></a><span class='right_span'>2</span></li>
</div><script language='javascript' type='text/javascript'>
if (!document.getElementById('algorithm')) document.getElementById('aexp_algorithm').style.visibility = 'hidden';
if (!document.getElementById('algorithm~tc')) document.getElementById('aexp_algorithm~tc').style.visibility = 'hidden';
</script>

</ul>
</div>
</body>
</html>
</section>

<section>
<h1>Date Categories
<span class='right_span'>(887)</span>

</h1>
<head>
</head>
<body>
<div id="menu">
<ul>
<li class='catclass'><a href='/blog/cats/2024/'>2024</a><a href='##' onmousedown=showDiv('2024')><span class='exp_style' id='exp_2024'>[+]</span></a><span class='right_span'>(7)</span></li>
<div id='2024' class='catsub'><li><a href='/blog/cats/2024~03/?opendiv=2024'>2024-03</a><span class='right_span'>1</span></li>
<li><a href='/blog/cats/2024~02/?opendiv=2024'>2024-02</a><span class='right_span'>4</span></li>
<li><a href='/blog/cats/2024~01/?opendiv=2024'>2024-01</a><span class='right_span'>2</span></li>
</div><li class='catclass'><a href='/blog/cats/2023/'>2023</a><a href='##' onmousedown=showDiv('2023')><span class='exp_style' id='exp_2023'>[+]</span></a><span class='right_span'>(87)</span></li>
<div id='2023' class='catsub'><li><a href='/blog/cats/2023~12/?opendiv=2023'>2023-12</a><span class='right_span'>3</span></li>
<li><a href='/blog/cats/2023~11/?opendiv=2023'>2023-11</a><span class='right_span'>4</span></li>
<li><a href='/blog/cats/2023~10/?opendiv=2023'>2023-10</a><span class='right_span'>7</span></li>
<li><a href='/blog/cats/2023~09/?opendiv=2023'>2023-09</a><span class='right_span'>10</span></li>
<li><a href='/blog/cats/2023~08/?opendiv=2023'>2023-08</a><span class='right_span'>1</span></li>
<li><a href='/blog/cats/2023~07/?opendiv=2023'>2023-07</a><span class='right_span'>23</span></li>
<li><a href='/blog/cats/2023~06/?opendiv=2023'>2023-06</a><span class='right_span'>6</span></li>
<li><a href='/blog/cats/2023~05/?opendiv=2023'>2023-05</a><span class='right_span'>3</span></li>
<li><a href='/blog/cats/2023~04/?opendiv=2023'>2023-04</a><span class='right_span'>4</span></li>
<li><a href='/blog/cats/2023~03/?opendiv=2023'>2023-03</a><span class='right_span'>2</span></li>
<li><a href='/blog/cats/2023~02/?opendiv=2023'>2023-02</a><span class='right_span'>6</span></li>
<li><a href='/blog/cats/2023~01/?opendiv=2023'>2023-01</a><span class='right_span'>18</span></li>
</div><li class='catclass'><a href='/blog/cats/2022/'>2022</a><a href='##' onmousedown=showDiv('2022')><span class='exp_style' id='exp_2022'>[+]</span></a><span class='right_span'>(83)</span></li>
<div id='2022' class='catsub'><li><a href='/blog/cats/2022~12/?opendiv=2022'>2022-12</a><span class='right_span'>9</span></li>
<li><a href='/blog/cats/2022~11/?opendiv=2022'>2022-11</a><span class='right_span'>16</span></li>
<li><a href='/blog/cats/2022~10/?opendiv=2022'>2022-10</a><span class='right_span'>17</span></li>
<li><a href='/blog/cats/2022~09/?opendiv=2022'>2022-09</a><span class='right_span'>10</span></li>
<li><a href='/blog/cats/2022~08/?opendiv=2022'>2022-08</a><span class='right_span'>29</span></li>
<li><a href='/blog/cats/2022~07/?opendiv=2022'>2022-07</a><span class='right_span'>2</span></li>
</div><li class='catclass'><a href='/blog/cats/2021/'>2021</a><a href='##' onmousedown=showDiv('2021')><span class='exp_style' id='exp_2021'>[+]</span></a><span class='right_span'>(73)</span></li>
<div id='2021' class='catsub'><li><a href='/blog/cats/2021~07/?opendiv=2021'>2021-07</a><span class='right_span'>18</span></li>
<li><a href='/blog/cats/2021~06/?opendiv=2021'>2021-06</a><span class='right_span'>34</span></li>
<li><a href='/blog/cats/2021~05/?opendiv=2021'>2021-05</a><span class='right_span'>5</span></li>
<li><a href='/blog/cats/2021~04/?opendiv=2021'>2021-04</a><span class='right_span'>13</span></li>
<li><a href='/blog/cats/2021~03/?opendiv=2021'>2021-03</a><span class='right_span'>2</span></li>
<li><a href='/blog/cats/2021~01/?opendiv=2021'>2021-01</a><span class='right_span'>1</span></li>
</div><li class='catclass'><a href='/blog/cats/2020/'>2020</a><a href='##' onmousedown=showDiv('2020')><span class='exp_style' id='exp_2020'>[+]</span></a><span class='right_span'>(70)</span></li>
<div id='2020' class='catsub'><li><a href='/blog/cats/2020~12/?opendiv=2020'>2020-12</a><span class='right_span'>6</span></li>
<li><a href='/blog/cats/2020~11/?opendiv=2020'>2020-11</a><span class='right_span'>11</span></li>
<li><a href='/blog/cats/2020~10/?opendiv=2020'>2020-10</a><span class='right_span'>8</span></li>
<li><a href='/blog/cats/2020~09/?opendiv=2020'>2020-09</a><span class='right_span'>8</span></li>
<li><a href='/blog/cats/2020~08/?opendiv=2020'>2020-08</a><span class='right_span'>6</span></li>
<li><a href='/blog/cats/2020~07/?opendiv=2020'>2020-07</a><span class='right_span'>11</span></li>
<li><a href='/blog/cats/2020~05/?opendiv=2020'>2020-05</a><span class='right_span'>19</span></li>
<li><a href='/blog/cats/2020~01/?opendiv=2020'>2020-01</a><span class='right_span'>1</span></li>
</div><li class='catclass'><a href='/blog/cats/2019/'>2019</a><a href='##' onmousedown=showDiv('2019')><span class='exp_style' id='exp_2019'>[+]</span></a><span class='right_span'>(22)</span></li>
<div id='2019' class='catsub'><li><a href='/blog/cats/2019~12/?opendiv=2019'>2019-12</a><span class='right_span'>8</span></li>
<li><a href='/blog/cats/2019~10/?opendiv=2019'>2019-10</a><span class='right_span'>2</span></li>
<li><a href='/blog/cats/2019~08/?opendiv=2019'>2019-08</a><span class='right_span'>4</span></li>
<li><a href='/blog/cats/2019~06/?opendiv=2019'>2019-06</a><span class='right_span'>5</span></li>
<li><a href='/blog/cats/2019~01/?opendiv=2019'>2019-01</a><span class='right_span'>3</span></li>
</div><li class='catclass'><a href='/blog/cats/2018/'>2018</a><a href='##' onmousedown=showDiv('2018')><span class='exp_style' id='exp_2018'>[+]</span></a><span class='right_span'>(56)</span></li>
<div id='2018' class='catsub'><li><a href='/blog/cats/2018~12/?opendiv=2018'>2018-12</a><span class='right_span'>2</span></li>
<li><a href='/blog/cats/2018~11/?opendiv=2018'>2018-11</a><span class='right_span'>8</span></li>
<li><a href='/blog/cats/2018~10/?opendiv=2018'>2018-10</a><span class='right_span'>1</span></li>
<li><a href='/blog/cats/2018~09/?opendiv=2018'>2018-09</a><span class='right_span'>1</span></li>
<li><a href='/blog/cats/2018~08/?opendiv=2018'>2018-08</a><span class='right_span'>1</span></li>
<li><a href='/blog/cats/2018~07/?opendiv=2018'>2018-07</a><span class='right_span'>7</span></li>
<li><a href='/blog/cats/2018~06/?opendiv=2018'>2018-06</a><span class='right_span'>5</span></li>
<li><a href='/blog/cats/2018~04/?opendiv=2018'>2018-04</a><span class='right_span'>6</span></li>
<li><a href='/blog/cats/2018~03/?opendiv=2018'>2018-03</a><span class='right_span'>10</span></li>
<li><a href='/blog/cats/2018~02/?opendiv=2018'>2018-02</a><span class='right_span'>6</span></li>
<li><a href='/blog/cats/2018~01/?opendiv=2018'>2018-01</a><span class='right_span'>9</span></li>
</div><li class='catclass'><a href='/blog/cats/2017/'>2017</a><a href='##' onmousedown=showDiv('2017')><span class='exp_style' id='exp_2017'>[+]</span></a><span class='right_span'>(10)</span></li>
<div id='2017' class='catsub'><li><a href='/blog/cats/2017~12/?opendiv=2017'>2017-12</a><span class='right_span'>2</span></li>
<li><a href='/blog/cats/2017~07/?opendiv=2017'>2017-07</a><span class='right_span'>8</span></li>
</div><li class='catclass'><a href='/blog/cats/2016/'>2016</a><a href='##' onmousedown=showDiv('2016')><span class='exp_style' id='exp_2016'>[+]</span></a><span class='right_span'>(21)</span></li>
<div id='2016' class='catsub'><li><a href='/blog/cats/2016~08/?opendiv=2016'>2016-08</a><span class='right_span'>1</span></li>
<li><a href='/blog/cats/2016~05/?opendiv=2016'>2016-05</a><span class='right_span'>2</span></li>
<li><a href='/blog/cats/2016~03/?opendiv=2016'>2016-03</a><span class='right_span'>11</span></li>
<li><a href='/blog/cats/2016~02/?opendiv=2016'>2016-02</a><span class='right_span'>1</span></li>
<li><a href='/blog/cats/2016~01/?opendiv=2016'>2016-01</a><span class='right_span'>6</span></li>
</div><li class='catclass'><a href='/blog/cats/2015/'>2015</a><a href='##' onmousedown=showDiv('2015')><span class='exp_style' id='exp_2015'>[+]</span></a><span class='right_span'>(207)</span></li>
<div id='2015' class='catsub'><li><a href='/blog/cats/2015~12/?opendiv=2015'>2015-12</a><span class='right_span'>4</span></li>
<li><a href='/blog/cats/2015~11/?opendiv=2015'>2015-11</a><span class='right_span'>9</span></li>
<li><a href='/blog/cats/2015~10/?opendiv=2015'>2015-10</a><span class='right_span'>2</span></li>
<li><a href='/blog/cats/2015~09/?opendiv=2015'>2015-09</a><span class='right_span'>18</span></li>
<li><a href='/blog/cats/2015~08/?opendiv=2015'>2015-08</a><span class='right_span'>25</span></li>
<li><a href='/blog/cats/2015~07/?opendiv=2015'>2015-07</a><span class='right_span'>31</span></li>
<li><a href='/blog/cats/2015~06/?opendiv=2015'>2015-06</a><span class='right_span'>24</span></li>
<li><a href='/blog/cats/2015~05/?opendiv=2015'>2015-05</a><span class='right_span'>22</span></li>
<li><a href='/blog/cats/2015~04/?opendiv=2015'>2015-04</a><span class='right_span'>23</span></li>
<li><a href='/blog/cats/2015~03/?opendiv=2015'>2015-03</a><span class='right_span'>19</span></li>
<li><a href='/blog/cats/2015~02/?opendiv=2015'>2015-02</a><span class='right_span'>11</span></li>
<li><a href='/blog/cats/2015~01/?opendiv=2015'>2015-01</a><span class='right_span'>19</span></li>
</div><li class='catclass'><a href='/blog/cats/2014/'>2014</a><a href='##' onmousedown=showDiv('2014')><span class='exp_style' id='exp_2014'>[+]</span></a><span class='right_span'>(112)</span></li>
<div id='2014' class='catsub'><li><a href='/blog/cats/2014~12/?opendiv=2014'>2014-12</a><span class='right_span'>21</span></li>
<li><a href='/blog/cats/2014~11/?opendiv=2014'>2014-11</a><span class='right_span'>19</span></li>
<li><a href='/blog/cats/2014~10/?opendiv=2014'>2014-10</a><span class='right_span'>13</span></li>
<li><a href='/blog/cats/2014~09/?opendiv=2014'>2014-09</a><span class='right_span'>7</span></li>
<li><a href='/blog/cats/2014~08/?opendiv=2014'>2014-08</a><span class='right_span'>15</span></li>
<li><a href='/blog/cats/2014~07/?opendiv=2014'>2014-07</a><span class='right_span'>2</span></li>
<li><a href='/blog/cats/2014~06/?opendiv=2014'>2014-06</a><span class='right_span'>4</span></li>
<li><a href='/blog/cats/2014~05/?opendiv=2014'>2014-05</a><span class='right_span'>7</span></li>
<li><a href='/blog/cats/2014~04/?opendiv=2014'>2014-04</a><span class='right_span'>9</span></li>
<li><a href='/blog/cats/2014~03/?opendiv=2014'>2014-03</a><span class='right_span'>2</span></li>
<li><a href='/blog/cats/2014~02/?opendiv=2014'>2014-02</a><span class='right_span'>11</span></li>
<li><a href='/blog/cats/2014~01/?opendiv=2014'>2014-01</a><span class='right_span'>2</span></li>
</div><li class='catclass'><a href='/blog/cats/2013/'>2013</a><a href='##' onmousedown=showDiv('2013')><span class='exp_style' id='exp_2013'>[+]</span></a><span class='right_span'>(60)</span></li>
<div id='2013' class='catsub'><li><a href='/blog/cats/2013~12/?opendiv=2013'>2013-12</a><span class='right_span'>5</span></li>
<li><a href='/blog/cats/2013~11/?opendiv=2013'>2013-11</a><span class='right_span'>8</span></li>
<li><a href='/blog/cats/2013~10/?opendiv=2013'>2013-10</a><span class='right_span'>8</span></li>
<li><a href='/blog/cats/2013~09/?opendiv=2013'>2013-09</a><span class='right_span'>5</span></li>
<li><a href='/blog/cats/2013~08/?opendiv=2013'>2013-08</a><span class='right_span'>5</span></li>
<li><a href='/blog/cats/2013~07/?opendiv=2013'>2013-07</a><span class='right_span'>3</span></li>
<li><a href='/blog/cats/2013~06/?opendiv=2013'>2013-06</a><span class='right_span'>9</span></li>
<li><a href='/blog/cats/2013~05/?opendiv=2013'>2013-05</a><span class='right_span'>8</span></li>
<li><a href='/blog/cats/2013~03/?opendiv=2013'>2013-03</a><span class='right_span'>6</span></li>
<li><a href='/blog/cats/2013~02/?opendiv=2013'>2013-02</a><span class='right_span'>2</span></li>
<li><a href='/blog/cats/2013~01/?opendiv=2013'>2013-01</a><span class='right_span'>1</span></li>
</div><li class='catclass'><a href='/blog/cats/2012/'>2012</a><a href='##' onmousedown=showDiv('2012')><span class='exp_style' id='exp_2012'>[+]</span></a><span class='right_span'>(35)</span></li>
<div id='2012' class='catsub'><li><a href='/blog/cats/2012~12/?opendiv=2012'>2012-12</a><span class='right_span'>4</span></li>
<li><a href='/blog/cats/2012~11/?opendiv=2012'>2012-11</a><span class='right_span'>2</span></li>
<li><a href='/blog/cats/2012~10/?opendiv=2012'>2012-10</a><span class='right_span'>4</span></li>
<li><a href='/blog/cats/2012~08/?opendiv=2012'>2012-08</a><span class='right_span'>1</span></li>
<li><a href='/blog/cats/2012~05/?opendiv=2012'>2012-05</a><span class='right_span'>2</span></li>
<li><a href='/blog/cats/2012~04/?opendiv=2012'>2012-04</a><span class='right_span'>9</span></li>
<li><a href='/blog/cats/2012~03/?opendiv=2012'>2012-03</a><span class='right_span'>6</span></li>
<li><a href='/blog/cats/2012~02/?opendiv=2012'>2012-02</a><span class='right_span'>5</span></li>
<li><a href='/blog/cats/2012~01/?opendiv=2012'>2012-01</a><span class='right_span'>2</span></li>
</div><li class='catclass'><a href='/blog/cats/2011/'>2011</a><a href='##' onmousedown=showDiv('2011')><span class='exp_style' id='exp_2011'>[+]</span></a><span class='right_span'>(35)</span></li>
<div id='2011' class='catsub'><li><a href='/blog/cats/2011~12/?opendiv=2011'>2011-12</a><span class='right_span'>8</span></li>
<li><a href='/blog/cats/2011~11/?opendiv=2011'>2011-11</a><span class='right_span'>4</span></li>
<li><a href='/blog/cats/2011~08/?opendiv=2011'>2011-08</a><span class='right_span'>3</span></li>
<li><a href='/blog/cats/2011~07/?opendiv=2011'>2011-07</a><span class='right_span'>3</span></li>
<li><a href='/blog/cats/2011~06/?opendiv=2011'>2011-06</a><span class='right_span'>1</span></li>
<li><a href='/blog/cats/2011~05/?opendiv=2011'>2011-05</a><span class='right_span'>1</span></li>
<li><a href='/blog/cats/2011~04/?opendiv=2011'>2011-04</a><span class='right_span'>1</span></li>
<li><a href='/blog/cats/2011~03/?opendiv=2011'>2011-03</a><span class='right_span'>11</span></li>
<li><a href='/blog/cats/2011~02/?opendiv=2011'>2011-02</a><span class='right_span'>2</span></li>
<li><a href='/blog/cats/2011~01/?opendiv=2011'>2011-01</a><span class='right_span'>1</span></li>
</div><li class='catclass'><a href='/blog/cats/2010/'>2010</a><a href='##' onmousedown=showDiv('2010')><span class='exp_style' id='exp_2010'>[+]</span></a><span class='right_span'>(1)</span></li>
<div id='2010' class='catsub'><li><a href='/blog/cats/2010~07/?opendiv=2010'>2010-07</a><span class='right_span'>1</span></li>
</div><li class='catclass'><a href='/blog/cats/2009/'>2009</a><a href='##' onmousedown=showDiv('2009')><span class='exp_style' id='exp_2009'>[+]</span></a><span class='right_span'>(8)</span></li>
<div id='2009' class='catsub'><li><a href='/blog/cats/2009~12/?opendiv=2009'>2009-12</a><span class='right_span'>1</span></li>
<li><a href='/blog/cats/2009~10/?opendiv=2009'>2009-10</a><span class='right_span'>4</span></li>
<li><a href='/blog/cats/2009~09/?opendiv=2009'>2009-09</a><span class='right_span'>2</span></li>
<li><a href='/blog/cats/2009~07/?opendiv=2009'>2009-07</a><span class='right_span'>1</span></li>
</div>
</ul>
</div>
</body>
</html>
</section>

<section>
<h1>Tags</h1>
<ul class="tag-cloud">
<a style="font-size: 124%" href="/tags/10gb/">10gb(7)</a>
<a style="font-size: 131%" href="/tags/gdb/">gdb(9)</a>
<a style="font-size: 127%" href="/tags/git/">git(8)</a>
<a style="font-size: 114%" href="/tags/ipv6/">ipv6(5)</a>
<a style="font-size: 124%" href="/tags/ixgbe/">ixgbe(7)</a>
<a style="font-size: 150%" href="/tags/koj/">koj(18)</a>
<a style="font-size: 100%" href="/tags/lvs/">lvs(3)</a>
<a style="font-size: 131%" href="/tags/mptcp/">mptcp(9)</a>
<a style="font-size: 119%" href="/tags/nginx/">nginx(6)</a>
<a style="font-size: 108%" href="/tags/squid/">squid(4)</a>
<a style="font-size: 131%" href="/tags/vpn/">vpn(9)</a>
<a style="font-size: 108%" href="/tags/shu-ju-cai-ji/">数据采集(4)</a>
<a style="font-size: 141%" href="/tags/hui-bian/">汇编(13)</a>

</ul>
</section>
<section>
  <h1>Recent Posts</h1>
  <ul id="recent_posts">
    
      <li class="post">
        <a href="/blog/2024/03/01/nginx-proxy/">nginx配置多个域名, http https共用配置</a>
      </li>
    
      <li class="post">
        <a href="/blog/2024/02/26/lang-web-FormData/">Ajax使用FormData上传文件</a>
      </li>
    
      <li class="post">
        <a href="/blog/2024/02/26/lang-web-pdf-view/">pdf预览 jquery.media.js</a>
      </li>
    
      <li class="post">
        <a href="/blog/2024/02/26/vim-syntax-off/">Vim 在处理长字符串时变得非常慢</a>
      </li>
    
      <li class="post">
        <a href="/blog/2024/02/26/lang-web-shuffle/">javascript随机打乱数组</a>
      </li>
    
      <li class="post">
        <a href="/blog/2024/01/06/lang-php-gd-random/">php的GD库,相同的字符串生成相同的二维码</a>
      </li>
    
      <li class="post">
        <a href="/blog/2024/01/06/lang-php-gd/">php的GD库imagettftext中文乱码</a>
      </li>
    
      <li class="post">
        <a href="/blog/2023/12/10/lang-php-mem/">PHP数组实际占用内存大小的分析</a>
      </li>
    
      <li class="post">
        <a href="/blog/2023/12/10/mysqldump-len/">mysqldump 参数 net-buffer-length</a>
      </li>
    
      <li class="post">
        <a href="/blog/2023/12/10/ubuntu-vulkan/">Ubuntu安装vulkan</a>
      </li>
    
  </ul>
</section>

<section>
  <h1>GitHub</h1>
  
  <a href="https://github.com/abcdxyzk">abcdxyzk on GitHub</a>
  
</section>

<section>
<h1>Links</h1>
<ul>
	<li>
		<a href='https://blog.csdn.net/abcdxyzk2?type=blog' target=_blank>CSDN博客</a>
	</li>
	<li>
		<a href='https://www.cnblogs.com/abcdxyzk' target=_blank>博客园</a>
	</li>
	<li>
		<a href='http://blog.chinaunix.net/uid/29997432.html' target=_blank>ChinaUnix博客</a>
	</li>
	<li>
		<a href='https://blog.51cto.com/u_16189960' target=_blank>51CTO博客</a>
	</li>
	<li>
		<a href='https://segmentfault.com/a/1190000044015394' target=_blank>segmentfault博客</a>
	</li>
	<li>
		<a href='http://hi.baidu.com/abcdxyzk' target=_blank>hi.baidu</a>
	</li>
	<li>
		<a href='http://blog.csdn.net/zhangskd' target=_blank>zhangsk</a>
	</li>
	<li>
		<a href='http://blog.csdn.net/justlinux2010' target=_blank>justlinux2010</a>
	</li>
	<li>
		<a href='http://simohayha.iteye.com/' target=_blank>simohayha</a>
	</li>
	<li>
		<a href='http://linux.chinaunix.net/techdoc/net/' target=_blank>技术文档</a>
	</li>
	<li>
		<a href='http://blog.csdn.net/cybertan' target=_blank>cybertan</a>
	</li>
	<li>
		<a href='http://blog.csdn.net/newnewman80' target=_blank>newnewman80</a>
	</li>
	<li>
		<a href='http://www.cppblog.com/fwxjj/' target=_blank>fwxjj</a>
	</li>
	<li>
		<a href='http://blog.csdn.net/ustc_dylan' target=_blank>ustc_dylan</a>
	</li>
	<li>
		<a href='http://blog.csdn.net/nkguohao' target=_blank>nkguohao</a>
	</li>
	<li>
		<a href='http://blog.csdn.net/yusiguyuan' target=_blank>yusiguyuan</a>
	</li>
	<li>
		<a href='http://www.oenhan.com/' target=_blank>oenhan</a>
	</li>
	<li>
		<a href='http://blog.csdn.net/bullbat' target=_blank>bullbat</a>
	</li>
	<li>
		<a href='http://www.wowotech.net/' target=_blank>wowotech</a>
	</li>
	<li>
		<a href='http://www.lenky.info/' target=_blank>lenky</a>
	</li>
	<li>
		<a href='http://smilejay.com/' target=_blank>smilejay</a>
	</li>
	<li>
		<a href='http://blog.chinaunix.net/uid/10167808.html' target=_blank>godbach</a>
	</li>
</ul>
</section>

  
<section id="comment_sidebar">
<h1>Recent Comments</h1>

<!--
<script type="text/javascript" src="http://abcdxyzk.disqus.com/recent_comments_widget.js?num_items=5&hide_avatars=0&avatar_size=32&excerpt_length=20"></script><a href="http://disqus.com/">Powered by Disqus</a>
-->

</section>


</aside>

    </div>
  </div>
  <footer role="contentinfo">  Copyright &copy; 2024 - kk -
  <span class="credit">Powered by <a href="http://octopress.org">Octopress</a></span>
  <a title="Top" href="#" id="scroll2top" style="position: fixed; height: 50px; bottom: 30px; right: 25px; cursor: pointer; z-index: 9999; display: block; opacity: 1;"><img src="/images/scrollup.png"></a>
  <script src="/javascripts/scroll2top.js"></script>

<!-- Matomo -->
<script>
  var _paq = window._paq = window._paq || [];
  /* tracker methods like "setCustomDimension" should be called before "trackPageView" */
  _paq.push(['trackPageView']);
  _paq.push(['enableLinkTracking']);
  (function() {
    var u="//www.abcxyzkk.xyz/matomo/";
    _paq.push(['setTrackerUrl', u+'matomo.php']);
    _paq.push(['setSiteId', '1']);
    var d=document, g=d.createElement('script'), s=d.getElementsByTagName('script')[0];
    g.async=true; g.src=u+'matomo.js'; s.parentNode.insertBefore(g,s);
  })();
</script>
<!-- End Matomo Code -->


<!-- Histats.com  (div with counter) --><div id="histats_counter"></div>
<!-- Histats.com  START  (aync)-->
<!--
<script type="text/javascript">var _Hasync= _Hasync|| [];
_Hasync.push(['Histats.start', '1,4673876,4,107,170,20,00010000']);
_Hasync.push(['Histats.fasi', '1']);
_Hasync.push(['Histats.track_hits', '']);
(function() {
var hs = document.createElement('script'); hs.type = 'text/javascript'; hs.async = true;
hs.src = ('//s10.histats.com/js15_as.js');
(document.getElementsByTagName('head')[0] || document.getElementsByTagName('body')[0]).appendChild(hs);
})();</script>
<noscript><a href="/" target="_blank"><img  src="//sstatic1.histats.com/0.gif?4673876&101" alt="simple hit counter" border="0"></a></noscript>
-->
<!-- Histats.com  END  -->

<!--  <script type="text/javascript">var cnzz_protocol = (("https:" == document.location.protocol) ? " https://" : " http://");document.write(unescape("%3Cspan id='cnzz_stat_icon_1253604690'%3E%3C/span%3E%3Cscript src='" + cnzz_protocol + "s95.cnzz.com/z_stat.php%3Fid%3D1253604690' type='text/javascript'%3E%3C/script%3E"));</script>
-->


<!--
<script>

// TODO 无法获取框架内元素
function autoads()
{
try {
	console.log('start');
	var txt = document.getElementById('mys-content').innerHTML;
	var len = txt.length;
	var url = '';
	console.log(len);
	for (var i = 0; i < len - 10; i ++) {
		if (txt.substring(i, i + 6) == 'href="') {
			i = i + 6;
			url = '';
			for ( ; i < len; i ++) {
				if (txt[i] == '"')
					break;
				url += txt[i];
			}
			url = url.replace(/&amp;/g, '&');
		//	console.log(url);
		}
	}
	console.log(url);
	if (url != '' && Math.random() < 0.3)
		window.open(url, "_blank");
} catch (e) {
}
}

window.onload = function() {
	setTimeout("autoads()", 5*1000);
}
</script>
-->


</footer>
  

<script type="text/javascript">
      var disqus_shortname = 'abcdxyzk';
      
</script>





</body>
</html>
